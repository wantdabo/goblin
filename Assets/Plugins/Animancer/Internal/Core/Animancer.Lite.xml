<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Animancer.Lite</name>
    </assembly>
    <members>
        <member name="T:Animancer.FastComparer">
            <summary>
            An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> which ignores overloaded equality operators so it is faster than
            <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/> for types derived from <see cref="T:UnityEngine.Object"/>.
            </summary>
            <remarks>
            This class is used in <see cref="P:Animancer.AnimancerPlayable.StateDictionary.EqualityComparer"/> by default.
            <para></para>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/playing/states#performance">Performance</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/FastComparer
            
        </member>
        <member name="F:Animancer.FastComparer.Instance">
            <summary>Singleton instance.</summary>
        </member>
        <member name="M:Animancer.FastComparer.System#Collections#Generic#IEqualityComparer{System#Object}#Equals(System.Object,System.Object)">
            <summary>Calls <see cref="M:System.Object.Equals(System.Object,System.Object)"/>.</summary>
        </member>
        <member name="M:Animancer.FastComparer.System#Collections#Generic#IEqualityComparer{System#Object}#GetHashCode(System.Object)">
            <summary>Calls <see cref="M:System.Object.GetHashCode"/>.</summary>
        </member>
        <member name="T:Animancer.FastReferenceComparer">
            <summary>
            An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> which uses <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> to be even faster than
            <see cref="T:Animancer.FastComparer"/>. Unfortunately this means it will not work for boxed value types (such as enums).
            </summary>
            <remarks>
            This class can be used in <see cref="P:Animancer.AnimancerPlayable.StateDictionary.EqualityComparer"/>.
            <para></para>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/playing/states#performance">Performance</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/FastReferenceComparer
            
        </member>
        <member name="F:Animancer.FastReferenceComparer.Instance">
            <summary>Singleton instance.</summary>
        </member>
        <member name="M:Animancer.FastReferenceComparer.System#Collections#Generic#IEqualityComparer{System#Object}#Equals(System.Object,System.Object)">
            <summary>Calls <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.</summary>
        </member>
        <member name="M:Animancer.FastReferenceComparer.System#Collections#Generic#IEqualityComparer{System#Object}#GetHashCode(System.Object)">
            <summary>Calls <see cref="M:System.Object.GetHashCode"/>.</summary>
        </member>
        <member name="T:Animancer.FastEnumerator`1">
            <summary>
            An <see cref="T:System.Collections.Generic.IEnumerator`1"/> for any <see cref="T:System.Collections.Generic.IList`1"/> doesn't bother checking if the target has been
            modified. This gives it good performance but also makes it slightly less safe to use.
            </summary>
            <remarks>
            This struct also implements <see cref="T:System.Collections.Generic.IEnumerable`1"/> so it can be used in <c>foreach</c> statements and
            <see cref="T:System.Collections.Generic.IList`1"/> to allow the target collection to be modified without breaking the enumerator (though
            doing so is still somewhat dangerous so use with care).
            </remarks>
            <example><code>
            var numbers = new int[] { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, };
            var count = 4;
            foreach (var number in new FastEnumerator&lt;int&gt;(numbers, count))
            {
                Debug.Log(number);
            }
            
            // Log Output:
            // 9
            // 8
            // 7
            // 6
            </code></example>
        </member>
        <member name="F:Animancer.FastEnumerator`1.List">
            <summary>The target <see cref="T:System.Collections.Generic.IList`1"/>.</summary>
        </member>
        <member name="P:Animancer.FastEnumerator`1.Count">
            <summary>[<see cref="T:System.Collections.Generic.ICollection`1"/>]
            The number of items in the <see cref="F:Animancer.FastEnumerator`1.List"/> (which can be less than the
            <see cref="P:System.Collections.Generic.ICollection`1.Count"/> of the <see cref="F:Animancer.FastEnumerator`1.List"/>).
            </summary>
        </member>
        <member name="P:Animancer.FastEnumerator`1.Index">
            <summary>The position of the <see cref="P:Animancer.FastEnumerator`1.Current"/> item in the <see cref="F:Animancer.FastEnumerator`1.List"/>.</summary>
        </member>
        <member name="P:Animancer.FastEnumerator`1.Current">
            <summary>The item at the current <see cref="P:Animancer.FastEnumerator`1.Index"/> in the <see cref="F:Animancer.FastEnumerator`1.List"/>.</summary>
        </member>
        <member name="P:Animancer.FastEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>The item at the current <see cref="P:Animancer.FastEnumerator`1.Index"/> in the <see cref="F:Animancer.FastEnumerator`1.List"/>.</summary>
        </member>
        <member name="M:Animancer.FastEnumerator`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Creates a new <see cref="T:Animancer.FastEnumerator`1"/>.</summary>
            <exception cref="T:System.NullReferenceException">
            The `list` is null. Use the <c>default</c> <see cref="T:Animancer.FastEnumerator`1"/> instead.
            </exception>
        </member>
        <member name="M:Animancer.FastEnumerator`1.#ctor(System.Collections.Generic.IList{`0},System.Int32)">
            <summary>Creates a new <see cref="T:Animancer.FastEnumerator`1"/>.</summary>
            <exception cref="T:System.NullReferenceException">
            The `list` is null. Use the <c>default</c> <see cref="T:Animancer.FastEnumerator`1"/> instead.
            </exception>
        </member>
        <member name="M:Animancer.FastEnumerator`1.MoveNext">
            <summary>Moves to the next item in the <see cref="F:Animancer.FastEnumerator`1.List"/> and returns true if there is one.</summary>
            <remarks>At the end of the <see cref="F:Animancer.FastEnumerator`1.List"/> the <see cref="P:Animancer.FastEnumerator`1.Index"/> is set to <see cref="F:System.Int32.MinValue"/>.</remarks>
        </member>
        <member name="M:Animancer.FastEnumerator`1.MovePrevious">
            <summary>Moves to the previous item in the <see cref="F:Animancer.FastEnumerator`1.List"/> and returns true if there is one.</summary>
            <remarks>At the end of the <see cref="F:Animancer.FastEnumerator`1.List"/> the <see cref="P:Animancer.FastEnumerator`1.Index"/> is set to <c>-1</c>.</remarks>
        </member>
        <member name="M:Animancer.FastEnumerator`1.Reset">
            <summary>[<see cref="T:System.Collections.IEnumerator"/>] Reverts this enumerator to the start of the <see cref="F:Animancer.FastEnumerator`1.List"/>.</summary>
        </member>
        <member name="M:Animancer.FastEnumerator`1.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.FastEnumerator`1.GetEnumerator">
            <summary>Returns <c>this</c>.</summary>
        </member>
        <member name="M:Animancer.FastEnumerator`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.FastEnumerator`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.FastEnumerator`1.IndexOf(`0)">
            <summary>[<see cref="T:System.Collections.Generic.IList`1"/>] Returns the first index of the `item` in the <see cref="F:Animancer.FastEnumerator`1.List"/>.</summary>
        </member>
        <member name="P:Animancer.FastEnumerator`1.Item(System.Int32)">
            <summary>[<see cref="T:System.Collections.Generic.IList`1"/>] The item at the specified `index` in the <see cref="F:Animancer.FastEnumerator`1.List"/>.</summary>
        </member>
        <member name="M:Animancer.FastEnumerator`1.Insert(System.Int32,`0)">
            <summary>[<see cref="T:System.Collections.Generic.IList`1"/>] Inserts the `item` at the specified `index` in the <see cref="F:Animancer.FastEnumerator`1.List"/>.</summary>
        </member>
        <member name="M:Animancer.FastEnumerator`1.RemoveAt(System.Int32)">
            <summary>[<see cref="T:System.Collections.Generic.IList`1"/>] Removes the item at the specified `index` from the <see cref="F:Animancer.FastEnumerator`1.List"/>.</summary>
        </member>
        <member name="P:Animancer.FastEnumerator`1.IsReadOnly">
            <summary>[<see cref="T:System.Collections.Generic.ICollection`1"/>] Is the <see cref="F:Animancer.FastEnumerator`1.List"/> read-only?</summary>
        </member>
        <member name="M:Animancer.FastEnumerator`1.Contains(`0)">
            <summary>[<see cref="T:System.Collections.Generic.ICollection`1"/>] Does the <see cref="F:Animancer.FastEnumerator`1.List"/> contain the `item`?</summary>
        </member>
        <member name="M:Animancer.FastEnumerator`1.Add(`0)">
            <summary>[<see cref="T:System.Collections.Generic.ICollection`1"/>] Adds the `item` to the end of the <see cref="F:Animancer.FastEnumerator`1.List"/>.</summary>
        </member>
        <member name="M:Animancer.FastEnumerator`1.Remove(`0)">
            <summary>[<see cref="T:System.Collections.Generic.ICollection`1"/>] Removes the `item` from the <see cref="F:Animancer.FastEnumerator`1.List"/> and returns true if successful.</summary>
        </member>
        <member name="M:Animancer.FastEnumerator`1.Clear">
            <summary>[<see cref="T:System.Collections.Generic.ICollection`1"/>] Removes everything from the <see cref="F:Animancer.FastEnumerator`1.List"/>.</summary>
        </member>
        <member name="M:Animancer.FastEnumerator`1.CopyTo(`0[],System.Int32)">
            <summary>[<see cref="T:System.Collections.Generic.ICollection`1"/>] Copies the contents of the <see cref="F:Animancer.FastEnumerator`1.List"/> into the `array`.</summary>
        </member>
        <member name="M:Animancer.FastEnumerator`1.AssertIndex(System.Int32)">
            <summary>[Assert-Only] Throws an exception unless 0 &lt;= `index` &lt; <see cref="P:Animancer.FastEnumerator`1.Count"/>.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:Animancer.FastEnumerator`1.AssertCount(System.Int32)">
            <summary>[Assert-Only] Throws an exception unless 0 &lt; `count` &lt;= <see cref="P:System.Collections.Generic.ICollection`1.Count"/>.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException"/>
        </member>
        <member name="T:Animancer.Key">
            <summary>Stores the index of an object in a <see cref="T:Animancer.Key.KeyedList`1"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer/Key
            
        </member>
        <member name="T:Animancer.Key.IListItem">
            <summary>An object with a <see cref="T:Animancer.Key"/> so it can be used in a <see cref="T:Animancer.Key.KeyedList`1"/>.</summary>
            <example>
            It's usually easiest to just inherit from <see cref="T:Animancer.Key"/>, but otherwise the recommended
            implementation looks like this:
            <para></para><code>
            class MyClass : Key.IListItem
            {
                Key Key.IListItem.Key { get; } = new Key();
                // Don't use expression bodied ...Key => new... because that would create a new one every time.
            }
            </code></example>
            https://kybernetik.com.au/animancer/api/Animancer/IListItem
            
        </member>
        <member name="P:Animancer.Key.IListItem.Key">
            <summary>
            The <see cref="T:Animancer.Key"/> which stores the <see cref="T:Animancer.Key.KeyedList`1"/> index of this object.
            </summary>
        </member>
        <member name="F:Animancer.Key.NotInList">
            <summary>The <see cref="F:Animancer.Key._Index"/> which indicates that an item isn't in a list.</summary>
        </member>
        <member name="F:Animancer.Key._Index">
            <summary>The current position of this key in the list.</summary>
        </member>
        <member name="M:Animancer.Key.IndexOf(Animancer.Key)">
            <summary>Returns location of this object in the list (or <c>-1</c> if it is not currently in a keyed list).</summary>
        </member>
        <member name="M:Animancer.Key.IsInList(Animancer.Key)">
            <summary>Is the `key` currently in a keyed list?</summary>
        </member>
        <member name="P:Animancer.Key.Animancer#Key#IListItem#Key">
            <summary>A <see cref="T:Animancer.Key"/> is its own <see cref="P:Animancer.Key.IListItem.Key"/>.</summary>
        </member>
        <member name="T:Animancer.Key.KeyedList`1">
            <summary>A <see cref="T:System.Collections.Generic.List`1"/> which can remove items without needing to search the entire collection.</summary>
            <remarks>
            This implementation has several restrictions compared to a regular <see cref="T:System.Collections.Generic.List`1"/>:
            <list type="bullet">
            <item>Items must implement <see cref="T:Animancer.Key.IListItem"/> or inherit from <see cref="T:Animancer.Key"/>.</item>
            <item>Items cannot be <c>null</c>.</item>
            <item>Items can only be in one <see cref="T:Animancer.Key.KeyedList`1"/> at a time and cannot appear multiple times in it.</item>
            </list>
            This class is nested inside <see cref="T:Animancer.Key"/> so it can modify the private <see cref="F:Animancer.Key._Index"/> without
            exposing that capability to anything else.
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/KeyedList_1
            
        </member>
        <member name="M:Animancer.Key.KeyedList`1.#ctor">
            <summary>Creates a new <see cref="T:Animancer.Key.KeyedList`1"/> using the default <see cref="T:System.Collections.Generic.List`1"/> constructor.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.#ctor(System.Int32)">
            <summary>Creates a new <see cref="T:Animancer.Key.KeyedList`1"/> with the specified initial `capacity`.</summary>
        </member>
        <member name="P:Animancer.Key.KeyedList`1.Count">
            <summary>The number of items currently in the list.</summary>
        </member>
        <member name="P:Animancer.Key.KeyedList`1.Capacity">
            <summary>The number of items that this list can contain before resizing is required.</summary>
        </member>
        <member name="P:Animancer.Key.KeyedList`1.Item(System.Int32)">
            <summary>The item at the specified `index`.</summary>
            <exception cref="T:System.ArgumentException">The `value` was already in a keyed list (setter only).</exception>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.Contains(`0)">
            <summary>Indicates whether the `item` is currently in this list.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.IndexOf(`0)">
            <summary>Returns the index of the `item` in this list or <c>-1</c> if it is not in this list.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.Add(`0)">
            <summary>Adds the `item` to the end of this list.</summary>
            <exception cref="T:System.ArgumentException">The `item` was already in a keyed list.</exception>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.AddNew(`0)">
            <summary>Adds the `item` to the end of this list if it wasn't already in it.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.Insert(System.Int32,`0)">
            <summary>Adds the `item` to this list at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.RemoveAt(System.Int32)">
            <summary>Removes the item at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.RemoveAtSwap(System.Int32)">
            <summary>Removes the item at the specified `index` by swapping the last item in this list into its place.</summary>
            <remarks>
            This does not maintain the order of items, but is more efficient than <see cref="M:Animancer.Key.KeyedList`1.RemoveAt(System.Int32)"/> because
            it avoids the need to move every item after the target down one place.
            </remarks>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.Remove(`0)">
            <summary>Removes the `item` from this list.</summary>
            <exception cref="T:System.ArgumentException">The `item` is not in this list.</exception>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.RemoveSwap(`0)">
            <summary>Removes the `item` by swapping the last item in this list into its place.</summary>
            <remarks>
            This does not maintain the order of items, but is more efficient than <see cref="M:Animancer.Key.KeyedList`1.Remove(`0)"/> because
            it avoids the need to move every item after the target down one place.
            </remarks>
            <exception cref="T:System.ArgumentException">The `item` is not in this list.</exception>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.Clear">
            <summary>Removes all items from this list.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.CopyTo(`0[],System.Int32)">
            <summary>Copies all the items from this list into the `array`, starting at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies all the items from this list into the `array`, starting at the specified `index`.</summary>
        </member>
        <member name="P:Animancer.Key.KeyedList`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>Returns false.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.GetEnumerator">
            <summary>Returns an enumerator that iterates through this list.</summary>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Key.KeyedList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Key.KeyedList`1.System#Collections#ICollection#IsSynchronized">
            <summary>Is this list thread safe?</summary>
        </member>
        <member name="P:Animancer.Key.KeyedList`1.System#Collections#ICollection#SyncRoot">
            <summary>An object that can be used to synchronize access to this <see cref="T:System.Collections.ICollection"/>.</summary>
        </member>
        <member name="T:Animancer.LazyStack`1">
            <summary>A simple stack implementation that tracks an active index without actually adding or removing objects.</summary>
            https://kybernetik.com.au/animancer/api/Animancer/LazyStack_1
            
        </member>
        <member name="F:Animancer.LazyStack`1.Stack">
            <summary>The underlying collection of objects.</summary>
            <remarks>
            This is not a <see cref="T:System.Collections.Generic.Stack`1"/> because that class comes from a different assembly that might not
            otherwise need to be included in builds, so using a <see cref="T:System.Collections.Generic.List`1"/> can slightly reduce build size.
            </remarks>
        </member>
        <member name="F:Animancer.LazyStack`1._CurrentIndex">
            <summary>The index of the <see cref="P:Animancer.LazyStack`1.Current"/> object in the <see cref="F:Animancer.LazyStack`1.Stack"/>.</summary>
        </member>
        <member name="P:Animancer.LazyStack`1.Current">
            <summary>The object currently on the top of the stack.</summary>
        </member>
        <member name="M:Animancer.LazyStack`1.#ctor">
            <summary>Creates a new <see cref="T:Animancer.LazyStack`1"/> with a default internal list capacity of 16.</summary>
        </member>
        <member name="M:Animancer.LazyStack`1.#ctor(System.Int32)">
            <summary>Creates a new <see cref="T:Animancer.LazyStack`1"/> with the specified internal list capacity.</summary>
        </member>
        <member name="M:Animancer.LazyStack`1.Increment">
            <summary>Moves to the next object in the stack.</summary>
        </member>
        <member name="M:Animancer.LazyStack`1.Decrement">
            <summary>Moves to the previous object in the stack.</summary>
        </member>
        <member name="T:Animancer.ObjectPool">
            <summary>Convenience methods for accessing <see cref="T:Animancer.ObjectPool`1"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer/ObjectPool
            
        </member>
        <member name="M:Animancer.ObjectPool.Acquire``1">
            <summary>Returns a spare item if there are any, or creates a new one.</summary>
            <remarks>Remember to <see cref="M:Animancer.ObjectPool.Release``1(``0)"/> it when you are done.</remarks>
        </member>
        <member name="M:Animancer.ObjectPool.Acquire``1(``0@)">
            <summary>Returns a spare `item` if there are any, or creates a new one.</summary>
            <remarks>Remember to <see cref="M:Animancer.ObjectPool.Release``1(``0)"/> it when you are done.</remarks>
        </member>
        <member name="M:Animancer.ObjectPool.Release``1(``0)">
            <summary>Adds the `item` to the list of spares so it can be reused.</summary>
        </member>
        <member name="M:Animancer.ObjectPool.Release``1(``0@)">
            <summary>Adds the `item` to the list of spares so it can be reused and sets it to <c>null</c>.</summary>
        </member>
        <member name="F:Animancer.ObjectPool.NotClearError">
            <summary>An error message for when something has been modified after being released to the pool.</summary>
        </member>
        <member name="M:Animancer.ObjectPool.AcquireList``1">
            <summary>Returns a spare <see cref="T:System.Collections.Generic.List`1"/> if there are any, or creates a new one.</summary>
            <remarks>Remember to <see cref="M:Animancer.ObjectPool.Release``1(System.Collections.Generic.List{``0})"/> it when you are done.</remarks>
        </member>
        <member name="M:Animancer.ObjectPool.Acquire``1(System.Collections.Generic.List{``0}@)">
            <summary>Returns a spare <see cref="T:System.Collections.Generic.List`1"/> if there are any, or creates a new one.</summary>
            <remarks>Remember to <see cref="M:Animancer.ObjectPool.Release``1(System.Collections.Generic.List{``0})"/> it when you are done.</remarks>
        </member>
        <member name="M:Animancer.ObjectPool.Release``1(System.Collections.Generic.List{``0})">
            <summary>Clears the `list` and adds it to the list of spares so it can be reused.</summary>
        </member>
        <member name="M:Animancer.ObjectPool.Release``1(System.Collections.Generic.List{``0}@)">
            <summary>Clears the `list`, adds it to the list of spares so it can be reused, and sets it to <c>null</c>.</summary>
        </member>
        <member name="M:Animancer.ObjectPool.AcquireSet``1">
            <summary>Returns a spare <see cref="T:System.Collections.Generic.HashSet`1"/> if there are any, or creates a new one.</summary>
            <remarks>Remember to <see cref="M:Animancer.ObjectPool.Release``1(System.Collections.Generic.HashSet{``0})"/> it when you are done.</remarks>
        </member>
        <member name="M:Animancer.ObjectPool.Acquire``1(System.Collections.Generic.HashSet{``0}@)">
            <summary>Returns a spare <see cref="T:System.Collections.Generic.HashSet`1"/> if there are any, or creates a new one.</summary>
            <remarks>Remember to <see cref="M:Animancer.ObjectPool.Release``1(System.Collections.Generic.HashSet{``0})"/> it when you are done.</remarks>
        </member>
        <member name="M:Animancer.ObjectPool.Release``1(System.Collections.Generic.HashSet{``0})">
            <summary>Clears the `set` and adds it to the list of spares so it can be reused.</summary>
        </member>
        <member name="M:Animancer.ObjectPool.Release``1(System.Collections.Generic.HashSet{``0}@)">
            <summary>Clears the `set`, adds it to the list of spares so it can be reused, and sets it to <c>null</c>.</summary>
        </member>
        <member name="M:Animancer.ObjectPool.AcquireStringBuilder">
            <summary>Returns a spare <see cref="T:System.Text.StringBuilder"/> if there are any, or creates a new one.</summary>
            <remarks>Remember to <see cref="M:Animancer.ObjectPool.Release(System.Text.StringBuilder)"/> it when you are done.</remarks>
        </member>
        <member name="M:Animancer.ObjectPool.Release(System.Text.StringBuilder)">
            <summary>Sets the <see cref="P:System.Text.StringBuilder.Length"/> = 0 and adds it to the list of spares so it can be reused.</summary>
        </member>
        <member name="M:Animancer.ObjectPool.ReleaseToString(System.Text.StringBuilder)">
            <summary>[Animancer Extension] Calls <see cref="M:System.Text.StringBuilder.ToString"/> and <see cref="M:Animancer.ObjectPool.Release(System.Text.StringBuilder)"/>.</summary>
        </member>
        <member name="T:Animancer.ObjectPool.Disposable">
            <summary>Convenience wrappers for <see cref="T:Animancer.ObjectPool`1.Disposable"/>.</summary>
        </member>
        <member name="M:Animancer.ObjectPool.Disposable.Acquire``1(``0@)">
            <summary>
            Creates a new <see cref="T:Animancer.ObjectPool`1.Disposable"/> and calls <see cref="M:Animancer.ObjectPool`1.Acquire"/> to set the
            <see cref="F:Animancer.ObjectPool`1.Disposable.Item"/> and `item`.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.Disposable.AcquireList``1(System.Collections.Generic.List{``0}@)">
            <summary>
            Creates a new <see cref="T:Animancer.ObjectPool`1.Disposable"/> and calls <see cref="M:Animancer.ObjectPool`1.Acquire"/> to set the
            <see cref="F:Animancer.ObjectPool`1.Disposable.Item"/> and `item`.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.Disposable.AcquireSet``1(System.Collections.Generic.HashSet{``0}@)">
            <summary>
            Creates a new <see cref="T:Animancer.ObjectPool`1.Disposable"/> and calls <see cref="M:Animancer.ObjectPool`1.Acquire"/> to set the
            <see cref="F:Animancer.ObjectPool`1.Disposable.Item"/> and `item`.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.Disposable.AcquireContent(UnityEngine.GUIContent@,System.String,System.String,System.Boolean)">
            <summary>
            Creates a new <see cref="T:Animancer.ObjectPool`1.Disposable"/> and calls <see cref="M:Animancer.ObjectPool`1.Acquire"/> to set the
            <see cref="F:Animancer.ObjectPool`1.Disposable.Item"/> and `item`.
            </summary>
        </member>
        <member name="M:Animancer.ObjectPool.Disposable.AcquireContent(UnityEngine.GUIContent@,UnityEditor.SerializedProperty,System.Boolean)">
            <summary>[Editor-Only]
            Creates a new <see cref="T:Animancer.ObjectPool`1.Disposable"/> and calls <see cref="M:Animancer.ObjectPool`1.Acquire"/> to set the
            <see cref="F:Animancer.ObjectPool`1.Disposable.Item"/> and `item`.
            </summary>
        </member>
        <member name="T:Animancer.ObjectPool`1">
            <summary>A simple object pooling system.</summary>
            <remarks><typeparamref name="T"/> must not inherit from <see cref="T:UnityEngine.Component"/> or <see cref="T:UnityEngine.ScriptableObject"/>.</remarks>
            https://kybernetik.com.au/animancer/api/Animancer/ObjectPool_1
            
        </member>
        <member name="P:Animancer.ObjectPool`1.Count">
            <summary>The number of spare items currently in the pool.</summary>
        </member>
        <member name="M:Animancer.ObjectPool`1.IncreaseCountTo(System.Int32)">
            <summary>Increases the <see cref="P:Animancer.ObjectPool`1.Count"/> to equal the `count` if it was lower.</summary>
        </member>
        <member name="P:Animancer.ObjectPool`1.Capacity">
            <summary>The <see cref="P:System.Collections.Generic.List`1.Capacity"/> of the internal list of spare items.</summary>
        </member>
        <member name="M:Animancer.ObjectPool`1.IncreaseCapacityTo(System.Int32)">
            <summary>Increases the <see cref="P:Animancer.ObjectPool`1.Capacity"/> to equal the `capacity` if it was lower.</summary>
        </member>
        <member name="M:Animancer.ObjectPool`1.Acquire">
            <summary>Returns a spare item if there are any, or creates a new one.</summary>
            <remarks>Remember to <see cref="M:Animancer.ObjectPool`1.Release(`0)"/> it when you are done.</remarks>
        </member>
        <member name="M:Animancer.ObjectPool`1.Release(`0)">
            <summary>Adds the `item` to the list of spares so it can be reused.</summary>
        </member>
        <member name="M:Animancer.ObjectPool`1.GetDetails">
            <summary>Returns a description of the state of this pool.</summary>
        </member>
        <member name="T:Animancer.ObjectPool`1.Disposable">
            <summary>
            An <see cref="T:System.IDisposable"/> to allow pooled objects to be acquired and released within <c>using</c>
            statements instead of needing to manually release everything.
            </summary>
        </member>
        <member name="F:Animancer.ObjectPool`1.Disposable.Item">
            <summary>The object acquired from the <see cref="T:Animancer.ObjectPool`1"/>.</summary>
        </member>
        <member name="F:Animancer.ObjectPool`1.Disposable.OnRelease">
            <summary>Called by <see cref="M:System.IDisposable.Dispose"/>.</summary>
        </member>
        <member name="M:Animancer.ObjectPool`1.Disposable.#ctor(`0@,System.Action{`0})">
            <summary>
            Creates a new <see cref="T:Animancer.ObjectPool`1.Disposable"/> and calls <see cref="M:Animancer.ObjectPool`1.Acquire"/> to set the
            <see cref="F:Animancer.ObjectPool`1.Disposable.Item"/> and `item`.
            </summary>
        </member>
        <member name="T:Animancer.ControllerState">
            <summary>[Pro-Only] An <see cref="T:Animancer.AnimancerState"/> which plays a <see cref="T:UnityEngine.RuntimeAnimatorController"/>.</summary>
            <remarks>
            You can control this state very similarly to an <see cref="T:UnityEngine.Animator"/> via its <see cref="P:Animancer.ControllerState.Playable"/> property.
            <para></para>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/animator-controllers">Animator Controllers</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/ControllerState
            
            https://kybernetik.com.au/animancer/api/Animancer/ControllerState
            https://kybernetik.com.au/animancer/api/Animancer/ControllerState
            https://kybernetik.com.au/animancer/api/Animancer/ControllerState
        </member>
        <member name="T:Animancer.ControllerState.ITransition">
            <summary>An <see cref="T:Animancer.ITransition`1"/> that creates a <see cref="T:Animancer.ControllerState"/>.</summary>
        </member>
        <member name="P:Animancer.ControllerState.Controller">
            <summary>The <see cref="T:UnityEngine.RuntimeAnimatorController"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ControllerState.MainObject">
            <summary>The <see cref="T:UnityEngine.RuntimeAnimatorController"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ControllerState.Playable">
            <summary>The internal system which plays the <see cref="T:UnityEngine.RuntimeAnimatorController"/>.</summary>
        </member>
        <member name="T:Animancer.ControllerState.ActionOnStop">
            <summary>Determines what a layer does when <see cref="M:Animancer.ControllerState.Stop"/> is called.</summary>
        </member>
        <member name="F:Animancer.ControllerState.ActionOnStop.DefaultState">
            <summary>Reset the layer to the first state it was in.</summary>
        </member>
        <member name="F:Animancer.ControllerState.ActionOnStop.RewindTime">
            <summary>Rewind the current state's time to 0.</summary>
        </member>
        <member name="F:Animancer.ControllerState.ActionOnStop.Continue">
            <summary>Allow the current state to stay at its current time.</summary>
        </member>
        <member name="P:Animancer.ControllerState.ActionsOnStop">
            <summary>Determines what each layer does when <see cref="M:Animancer.ControllerState.Stop"/> is called.</summary>
            <remarks>
            If empty, all layers will reset to their <see cref="F:Animancer.ControllerState.ActionOnStop.DefaultState"/>.
            <para></para>
            If this array is smaller than the <see cref="M:UnityEngine.Animations.AnimatorControllerPlayable.GetLayerCount"/>, any additional
            layers will use the last value in this array.
            </remarks>
        </member>
        <member name="P:Animancer.ControllerState.DefaultStateHashes">
            <summary>
            The <see cref="P:UnityEngine.AnimatorStateInfo.shortNameHash"/> of the default state on each layer, used to reset to
            those states when <see cref="M:Animancer.ControllerState.ApplyActionsOnStop"/> is called for layers using
            <see cref="F:Animancer.ControllerState.ActionOnStop.DefaultState"/>.
            </summary>
            <remarks>Gathered using <see cref="M:Animancer.ControllerState.GatherDefaultStates"/>.</remarks>
        </member>
        <member name="P:Animancer.ControllerState.UnsupportedEventsMessage">
            <summary>[Assert-Only] Animancer Events doesn't work properly on <see cref="T:Animancer.ControllerState"/>s.</summary>
        </member>
        <member name="P:Animancer.ControllerState.UnsupportedSpeedMessage">
            <summary>[Assert-Only]
            <see cref="M:UnityEngine.Playables.PlayableExtensions.SetSpeed``1(``0,System.Double)"/> does nothing on <see cref="T:Animancer.ControllerState"/>s.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.AssertParameterValue(System.Single,System.String)">
            <summary>[Assert-Conditional] Asserts that the `value` is valid.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The `value` is NaN or Infinity.</exception>
        </member>
        <member name="M:Animancer.ControllerState.CopyIKFlags(Animancer.AnimancerNode)">
            <summary>IK cannot be dynamically enabled on a <see cref="T:Animancer.ControllerState"/>.</summary>
        </member>
        <member name="P:Animancer.ControllerState.ApplyAnimatorIK">
            <summary>IK cannot be dynamically enabled on a <see cref="T:Animancer.ControllerState"/>.</summary>
        </member>
        <member name="P:Animancer.ControllerState.ApplyFootIK">
            <summary>IK cannot be dynamically enabled on a <see cref="T:Animancer.ControllerState"/>.</summary>
        </member>
        <member name="P:Animancer.ControllerState.ParameterCount">
            <summary>The number of parameters being wrapped by this state.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetParameterHash(System.Int32)">
            <summary>Returns the hash of a parameter being wrapped by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't wrap any parameters.</exception>
        </member>
        <member name="M:Animancer.ControllerState.#ctor(UnityEngine.RuntimeAnimatorController)">
            <summary>Creates a new <see cref="T:Animancer.ControllerState"/> to play the `controller`.</summary>
        </member>
        <member name="M:Animancer.ControllerState.#ctor(UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.ActionOnStop[])">
            <summary>Creates a new <see cref="T:Animancer.ControllerState"/> to play the `controller`.</summary>
        </member>
        <member name="M:Animancer.ControllerState.CreatePlayable(UnityEngine.Playables.Playable@)">
            <summary>Creates and assigns the <see cref="T:UnityEngine.Animations.AnimatorControllerPlayable"/> managed by this state.</summary>
        </member>
        <member name="M:Animancer.ControllerState.RecreatePlayable">
            <summary>
            Stores the values of all parameters, calls <see cref="M:Animancer.AnimancerNode.DestroyPlayable"/>, then restores the
            parameter values.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.GetStateInfo(System.Int32)">
            <summary>
            Returns the current state on the specified `layer`, or the next state if it is currently in a transition.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.RawTime">
            <summary>
            The <see cref="P:UnityEngine.AnimatorStateInfo.normalizedTime"/> * <see cref="P:UnityEngine.AnimatorStateInfo.length"/> of layer 0.
            </summary>
        </member>
        <member name="P:Animancer.ControllerState.Length">
            <summary>The current <see cref="P:UnityEngine.AnimatorStateInfo.length"/> of layer 0.</summary>
        </member>
        <member name="P:Animancer.ControllerState.IsLooping">
            <summary>Indicates whether the current state on layer 0 will loop back to the start when it reaches the end.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GatherDefaultStates">
            <summary>Gathers the <see cref="P:Animancer.ControllerState.DefaultStateHashes"/> from the current states on each layer.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Stop">
            <summary>
            Stops the animation and makes it inactive immediately so it no longer affects the output.
            Also calls <see cref="M:Animancer.ControllerState.ApplyActionsOnStop"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.ApplyActionsOnStop">
            <summary>Applies the <see cref="P:Animancer.ControllerState.ActionsOnStop"/> to their corresponding layers.</summary>
            <exception cref="T:System.NullReferenceException"><see cref="P:Animancer.ControllerState.DefaultStateHashes"/> is null.</exception>
        </member>
        <member name="M:Animancer.ControllerState.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ControllerState.Destroy">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ControllerState.Clone(Animancer.AnimancerPlayable)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ControllerState.Animancer#ICopyable{Animancer#ControllerState}#CopyFrom(Animancer.ControllerState)">
            <inheritdoc/>
        </member>
        <member name="F:Animancer.ControllerState.DefaultFadeDuration">
            <summary>
            The default constant for fade duration parameters which causes it to use the
            <see cref="P:Animancer.AnimancerPlayable.DefaultFadeDuration"/> instead.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.GetFadeDuration(System.Single)">
            <summary>
            Returns the `fadeDuration` if it is zero or positive. Otherwise returns the
            <see cref="P:Animancer.AnimancerPlayable.DefaultFadeDuration"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.CrossFade(System.Int32,System.Single,System.Int32,System.Single)">
            <summary>Starts a transition from the current state to the specified state using normalized times.</summary>
            <remarks>If `fadeDuration` is negative, it uses the <see cref="P:Animancer.AnimancerPlayable.DefaultFadeDuration"/>.</remarks>
        </member>
        <member name="M:Animancer.ControllerState.CrossFade(System.String,System.Single,System.Int32,System.Single)">
            <summary>Starts a transition from the current state to the specified state using normalized times.</summary>
            <remarks>If `fadeDuration` is negative, it uses the <see cref="P:Animancer.AnimancerPlayable.DefaultFadeDuration"/>.</remarks>
        </member>
        <member name="M:Animancer.ControllerState.CrossFadeInFixedTime(System.Int32,System.Single,System.Int32,System.Single)">
            <summary>Starts a transition from the current state to the specified state using times in seconds.</summary>
            <remarks>If `fadeDuration` is negative, it uses the <see cref="P:Animancer.AnimancerPlayable.DefaultFadeDuration"/>.</remarks>
        </member>
        <member name="M:Animancer.ControllerState.CrossFadeInFixedTime(System.String,System.Single,System.Int32,System.Single)">
            <summary>Starts a transition from the current state to the specified state using times in seconds.</summary>
            <remarks>If `fadeDuration` is negative, it uses the <see cref="P:Animancer.AnimancerPlayable.DefaultFadeDuration"/>.</remarks>
        </member>
        <member name="M:Animancer.ControllerState.Play(System.Int32,System.Int32,System.Single)">
            <summary>Plays the specified state immediately, starting from a particular normalized time.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Play(System.String,System.Int32,System.Single)">
            <summary>Plays the specified state immediately, starting from a particular normalized time.</summary>
        </member>
        <member name="M:Animancer.ControllerState.PlayInFixedTime(System.Int32,System.Int32,System.Single)">
            <summary>Plays the specified state immediately, starting from a particular time (in seconds).</summary>
        </member>
        <member name="M:Animancer.ControllerState.PlayInFixedTime(System.String,System.Int32,System.Single)">
            <summary>Plays the specified state immediately, starting from a particular time (in seconds).</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetBool(System.Int32)">
            <summary>Gets the value of the specified boolean parameter.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetBool(System.String)">
            <summary>Gets the value of the specified boolean parameter.</summary>
        </member>
        <member name="M:Animancer.ControllerState.SetBool(System.Int32,System.Boolean)">
            <summary>Sets the value of the specified boolean parameter.</summary>
        </member>
        <member name="M:Animancer.ControllerState.SetBool(System.String,System.Boolean)">
            <summary>Sets the value of the specified boolean parameter.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetFloat(System.Int32)">
            <summary>Gets the value of the specified float parameter.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetFloat(System.String)">
            <summary>Gets the value of the specified float parameter.</summary>
        </member>
        <member name="M:Animancer.ControllerState.SetFloat(System.Int32,System.Single)">
            <summary>Sets the value of the specified float parameter.</summary>
        </member>
        <member name="M:Animancer.ControllerState.SetFloat(System.String,System.Single)">
            <summary>Sets the value of the specified float parameter.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetInteger(System.Int32)">
            <summary>Gets the value of the specified integer parameter.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetInteger(System.String)">
            <summary>Gets the value of the specified integer parameter.</summary>
        </member>
        <member name="M:Animancer.ControllerState.SetInteger(System.Int32,System.Int32)">
            <summary>Sets the value of the specified integer parameter.</summary>
        </member>
        <member name="M:Animancer.ControllerState.SetInteger(System.String,System.Int32)">
            <summary>Sets the value of the specified integer parameter.</summary>
        </member>
        <member name="M:Animancer.ControllerState.SetTrigger(System.Int32)">
            <summary>Sets the specified trigger parameter to true.</summary>
        </member>
        <member name="M:Animancer.ControllerState.SetTrigger(System.String)">
            <summary>Sets the specified trigger parameter to true.</summary>
        </member>
        <member name="M:Animancer.ControllerState.ResetTrigger(System.Int32)">
            <summary>Resets the specified trigger parameter to false.</summary>
        </member>
        <member name="M:Animancer.ControllerState.ResetTrigger(System.String)">
            <summary>Resets the specified trigger parameter to false.</summary>
        </member>
        <member name="M:Animancer.ControllerState.IsParameterControlledByCurve(System.Int32)">
            <summary>Indicates whether the specified parameter is controlled by an <see cref="T:UnityEngine.AnimationClip"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.IsParameterControlledByCurve(System.String)">
            <summary>Indicates whether the specified parameter is controlled by an <see cref="T:UnityEngine.AnimationClip"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetParameter(System.Int32)">
            <summary>Gets the details of one of the <see cref="P:Animancer.ControllerState.Controller"/>'s parameters.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetParameterCount">
            <summary>Gets the number of parameters in the <see cref="P:Animancer.ControllerState.Controller"/>.</summary>
        </member>
        <member name="P:Animancer.ControllerState.parameterCount">
            <summary>The number of parameters in the <see cref="P:Animancer.ControllerState.Controller"/>.</summary>
        </member>
        <member name="P:Animancer.ControllerState.parameters">
            <summary>The parameters in the <see cref="P:Animancer.ControllerState.Controller"/>.</summary>
            <remarks>
            This property allocates a new array when first accessed. To avoid that, you can use
            <see cref="M:Animancer.ControllerState.GetParameterCount"/> and <see cref="M:Animancer.ControllerState.GetParameter(System.Int32)"/> instead.
            </remarks>
        </member>
        <member name="M:Animancer.ControllerState.SetFloat(System.String,System.Single,System.Single,System.Single,System.Single)">
            <summary>Sets the value of the specified float parameter with smoothing.</summary>
        </member>
        <member name="M:Animancer.ControllerState.SetFloat(System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>Sets the value of the specified float parameter with smoothing.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetLayerWeight(System.Int32)">
            <summary>Gets the weight of the layer at the specified index.</summary>
        </member>
        <member name="M:Animancer.ControllerState.SetLayerWeight(System.Int32,System.Single)">
            <summary>Sets the weight of the layer at the specified index.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetLayerCount">
            <summary>Gets the number of layers in the <see cref="P:Animancer.ControllerState.Controller"/>.</summary>
        </member>
        <member name="P:Animancer.ControllerState.layerCount">
            <summary>The number of layers in the <see cref="P:Animancer.ControllerState.Controller"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetLayerIndex(System.String)">
            <summary>Gets the index of the layer with the specified name.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetLayerName(System.Int32)">
            <summary>Gets the name of the layer with the specified index.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetCurrentAnimatorStateInfo(System.Int32)">
            <summary>Returns information about the current state.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetNextAnimatorStateInfo(System.Int32)">
            <summary>Returns information about the next state being transitioned towards.</summary>
        </member>
        <member name="M:Animancer.ControllerState.HasState(System.Int32,System.Int32)">
            <summary>Indicates whether the specified layer contains the specified state.</summary>
        </member>
        <member name="M:Animancer.ControllerState.IsInTransition(System.Int32)">
            <summary>Indicates whether the specified layer is currently executing a transition.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetAnimatorTransitionInfo(System.Int32)">
            <summary>Gets information about the current transition.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetCurrentAnimatorClipInfo(System.Int32)">
            <summary>Gets information about the <see cref="T:UnityEngine.AnimationClip"/>s currently being played.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetCurrentAnimatorClipInfo(System.Int32,System.Collections.Generic.List{UnityEngine.AnimatorClipInfo})">
            <summary>Gets information about the <see cref="T:UnityEngine.AnimationClip"/>s currently being played.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetCurrentAnimatorClipInfoCount(System.Int32)">
            <summary>Gets the number of <see cref="T:UnityEngine.AnimationClip"/>s currently being played.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetNextAnimatorClipInfo(System.Int32)">
            <summary>Gets information about the <see cref="T:UnityEngine.AnimationClip"/>s currently being transitioned towards.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetNextAnimatorClipInfo(System.Int32,System.Collections.Generic.List{UnityEngine.AnimatorClipInfo})">
            <summary>Gets information about the <see cref="T:UnityEngine.AnimationClip"/>s currently being transitioned towards.</summary>
        </member>
        <member name="M:Animancer.ControllerState.GetNextAnimatorClipInfoCount(System.Int32)">
            <summary>Gets the number of <see cref="T:UnityEngine.AnimationClip"/>s currently being transitioned towards.</summary>
        </member>
        <member name="T:Animancer.ControllerState.DampedFloatParameter">
            <summary>
            A wrapper for <see cref="M:UnityEngine.Mathf.SmoothDamp(System.Single,System.Single,System.Single@,System.Single,System.Single,System.Single)"/> to control float
            parameters in <see cref="T:Animancer.ControllerState"/>s similar to
            <see cref="M:UnityEngine.Animator.SetFloat(System.Int32,System.Single,System.Single,System.Single)"/>.
            </summary>
        </member>
        <member name="F:Animancer.ControllerState.DampedFloatParameter.parameter">
            <summary>The name of this parameter.</summary>
        </member>
        <member name="F:Animancer.ControllerState.DampedFloatParameter.smoothTime">
            <summary>The amount of time allowed to smooth out a value change.</summary>
        </member>
        <member name="F:Animancer.ControllerState.DampedFloatParameter.currentValue">
            <summary>The last value the parameter was set to.</summary>
        </member>
        <member name="F:Animancer.ControllerState.DampedFloatParameter.targetValue">
            <summary>The value that the parameter is moving towards.</summary>
        </member>
        <member name="F:Animancer.ControllerState.DampedFloatParameter.maxSpeed">
            <summary>The maximum speed that the current value can move towards the target.</summary>
        </member>
        <member name="F:Animancer.ControllerState.DampedFloatParameter.velocity">
            <summary>The speed at which the value is currently moving.</summary>
        </member>
        <member name="M:Animancer.ControllerState.DampedFloatParameter.#ctor(Animancer.ControllerState.ParameterID,System.Single,System.Single,System.Single)">
            <summary>Creates a new <see cref="T:Animancer.ControllerState.DampedFloatParameter"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.DampedFloatParameter.Apply(Animancer.ControllerState)">
            <summary>Updates the target parameter.</summary>
        </member>
        <member name="M:Animancer.ControllerState.DampedFloatParameter.Apply(Animancer.ControllerState,System.Single)">
            <summary>Updates the target parameter.</summary>
        </member>
        <member name="M:Animancer.ControllerState.CreateDrawer">
            <summary>[Editor-Only] Returns a <see cref="T:Animancer.ControllerState.Drawer"/> for this state.</summary>
        </member>
        <member name="T:Animancer.ControllerState.Drawer">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.#ctor(Animancer.ControllerState)">
            <summary>Creates a new <see cref="T:Animancer.ControllerState.Drawer"/> to manage the Inspector GUI for the `state`.</summary>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.DoDetailsGUI">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.GatherParameters">
            <summary>Fills the <see cref="F:Animancer.ControllerState.Drawer.Parameters"/> list with the current parameter details.</summary>
        </member>
        <member name="P:Animancer.ControllerState.Drawer.ParameterCount">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.GetParameterName(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.GetParameterType(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.GetParameterValue(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ControllerState.Drawer.SetParameterValue(System.Int32,System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.ControllerState.ParameterID">
            <summary>A wrapper for the name and hash of an <see cref="T:UnityEngine.AnimatorControllerParameter"/>.</summary>
        </member>
        <member name="F:Animancer.ControllerState.ParameterID.Name">
            <summary>The name of this parameter.</summary>
        </member>
        <member name="F:Animancer.ControllerState.ParameterID.Hash">
            <summary>The name hash of this parameter.</summary>
        </member>
        <member name="M:Animancer.ControllerState.ParameterID.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Animancer.ControllerState.ParameterID"/> with the specified <see cref="F:Animancer.ControllerState.ParameterID.Name"/> and uses
            <see cref="M:UnityEngine.Animator.StringToHash(System.String)"/> to calculate the <see cref="F:Animancer.ControllerState.ParameterID.Hash"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.ParameterID.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Animancer.ControllerState.ParameterID"/> with the specified <see cref="F:Animancer.ControllerState.ParameterID.Hash"/> and leaves the
            <see cref="F:Animancer.ControllerState.ParameterID.Name"/> null.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.ParameterID.#ctor(System.String,System.Int32)">
            <summary>Creates a new <see cref="T:Animancer.ControllerState.ParameterID"/> with the specified <see cref="F:Animancer.ControllerState.ParameterID.Name"/> and <see cref="F:Animancer.ControllerState.ParameterID.Hash"/>.</summary>
            <remarks>This constructor does not verify that the `hash` actually corresponds to the `name`.</remarks>
        </member>
        <member name="M:Animancer.ControllerState.ParameterID.op_Implicit(System.String)~Animancer.ControllerState.ParameterID">
            <summary>
            Creates a new <see cref="T:Animancer.ControllerState.ParameterID"/> with the specified <see cref="F:Animancer.ControllerState.ParameterID.Name"/> and uses
            <see cref="M:UnityEngine.Animator.StringToHash(System.String)"/> to calculate the <see cref="F:Animancer.ControllerState.ParameterID.Hash"/>.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.ParameterID.op_Implicit(System.Int32)~Animancer.ControllerState.ParameterID">
            <summary>
            Creates a new <see cref="T:Animancer.ControllerState.ParameterID"/> with the specified <see cref="F:Animancer.ControllerState.ParameterID.Hash"/> and leaves the
            <see cref="F:Animancer.ControllerState.ParameterID.Name"/> null.
            </summary>
        </member>
        <member name="M:Animancer.ControllerState.ParameterID.op_Implicit(Animancer.ControllerState.ParameterID)~System.Int32">
            <summary>Returns the <see cref="F:Animancer.ControllerState.ParameterID.Hash"/>.</summary>
        </member>
        <member name="M:Animancer.ControllerState.ParameterID.ValidateHasParameter(UnityEngine.RuntimeAnimatorController,UnityEngine.AnimatorControllerParameterType)">
            <summary>[Editor-Conditional]
            Throws if the `controller` doesn't have a parameter with the specified <see cref="F:Animancer.ControllerState.ParameterID.Hash"/>
            and `type`.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.ControllerState.ParameterID.GetParameterDetails(UnityEngine.RuntimeAnimatorController)">
            <summary>[Editor-Only] Returns the hash mapped to the type of all parameters in the `controller`.</summary>
            <remarks>This doesn't work for if the `controller` was loaded from an Asset Bundle.</remarks>
        </member>
        <member name="M:Animancer.ControllerState.ParameterID.ToString">
            <summary>Returns a string containing the <see cref="F:Animancer.ControllerState.ParameterID.Name"/> and <see cref="F:Animancer.ControllerState.ParameterID.Hash"/>.</summary>
        </member>
        <member name="T:Animancer.Float1ControllerState">
            <summary>[Pro-Only] A <see cref="T:Animancer.ControllerState"/> which manages one float parameter.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/animator-controllers">Animator Controllers</see>
            </remarks>
            <seealso cref="T:Animancer.Float2ControllerState"/>
            <seealso cref="T:Animancer.Float3ControllerState"/>
            https://kybernetik.com.au/animancer/api/Animancer/Float1ControllerState
            
        </member>
        <member name="T:Animancer.Float1ControllerState.ITransition">
            <summary>An <see cref="T:Animancer.ITransition`1"/> that creates a <see cref="T:Animancer.Float1ControllerState"/>.</summary>
        </member>
        <member name="P:Animancer.Float1ControllerState.ParameterID">
            <summary>The identifier of the parameter which <see cref="P:Animancer.Float1ControllerState.Parameter"/> will get and set.</summary>
        </member>
        <member name="P:Animancer.Float1ControllerState.Parameter">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float1ControllerState.ParameterID"/>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The value is NaN or Infinity.</exception>
        </member>
        <member name="M:Animancer.Float1ControllerState.#ctor(UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.ParameterID,Animancer.ControllerState.ActionOnStop[])">
            <summary>Creates a new <see cref="T:Animancer.Float1ControllerState"/> to play the `controller`.</summary>
        </member>
        <member name="M:Animancer.Float1ControllerState.#ctor(UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.ParameterID)">
            <summary>Creates a new <see cref="T:Animancer.Float1ControllerState"/> to play the `controller`.</summary>
        </member>
        <member name="P:Animancer.Float1ControllerState.ParameterCount">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Float1ControllerState.GetParameterHash(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Float1ControllerState.Clone(Animancer.AnimancerPlayable)">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.Float2ControllerState">
            <summary>[Pro-Only] A <see cref="T:Animancer.ControllerState"/> which manages two float parameters.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/animator-controllers">Animator Controllers</see>
            </remarks>
            <seealso cref="T:Animancer.Float1ControllerState"/>
            <seealso cref="T:Animancer.Float3ControllerState"/>
            https://kybernetik.com.au/animancer/api/Animancer/Float2ControllerState
            
        </member>
        <member name="T:Animancer.Float2ControllerState.ITransition">
            <summary>An <see cref="T:Animancer.ITransition`1"/> that creates a <see cref="T:Animancer.Float2ControllerState"/>.</summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterXID">
            <summary>The identifier of the parameter which <see cref="P:Animancer.Float2ControllerState.ParameterX"/> will get and set.</summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterX">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float2ControllerState.ParameterXID"/>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The value is NaN or Infinity.</exception>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterYID">
            <summary>The identifier of the parameter which <see cref="P:Animancer.Float2ControllerState.ParameterY"/> will get and set.</summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterY">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float2ControllerState.ParameterYID"/>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The value is NaN or Infinity.</exception>
        </member>
        <member name="P:Animancer.Float2ControllerState.Parameter">
            <summary>
            Gets and sets <see cref="P:Animancer.Float2ControllerState.ParameterX"/> and <see cref="P:Animancer.Float2ControllerState.ParameterY"/>.
            </summary>
        </member>
        <member name="M:Animancer.Float2ControllerState.#ctor(UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.ParameterID,Animancer.ControllerState.ParameterID,Animancer.ControllerState.ActionOnStop[])">
            <summary>Creates a new <see cref="T:Animancer.Float2ControllerState"/> to play the `controller`.</summary>
        </member>
        <member name="M:Animancer.Float2ControllerState.#ctor(UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.ParameterID,Animancer.ControllerState.ParameterID)">
            <summary>Creates a new <see cref="T:Animancer.Float2ControllerState"/> to play the `controller`.</summary>
        </member>
        <member name="P:Animancer.Float2ControllerState.ParameterCount">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Float2ControllerState.GetParameterHash(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Float2ControllerState.Clone(Animancer.AnimancerPlayable)">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.Float3ControllerState">
            <summary>[Pro-Only] A <see cref="T:Animancer.ControllerState"/> which manages three float parameters.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/animator-controllers">Animator Controllers</see>
            </remarks>
            <seealso cref="T:Animancer.Float1ControllerState"/>
            <seealso cref="T:Animancer.Float2ControllerState"/>
            https://kybernetik.com.au/animancer/api/Animancer/Float3ControllerState
            
        </member>
        <member name="T:Animancer.Float3ControllerState.ITransition">
            <summary>An <see cref="T:Animancer.ITransition`1"/> that creates a <see cref="T:Animancer.Float3ControllerState"/>.</summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterXID">
            <summary>The identifier of the parameter which <see cref="P:Animancer.Float3ControllerState.ParameterX"/> will get and set.</summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterX">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float3ControllerState.ParameterXID"/>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The value is NaN or Infinity.</exception>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterYID">
            <summary>The identifier of the parameter which <see cref="P:Animancer.Float3ControllerState.ParameterY"/> will get and set.</summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterY">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float3ControllerState.ParameterYID"/>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The value is NaN or Infinity.</exception>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterZID">
            <summary>The identifier of the parameter which <see cref="P:Animancer.Float3ControllerState.ParameterZ"/> will get and set.</summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterZ">
            <summary>
            Gets and sets a float parameter in the <see cref="P:Animancer.ControllerState.Controller"/> using the
            <see cref="P:Animancer.Float3ControllerState.ParameterZID"/>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The value is NaN or Infinity.</exception>
        </member>
        <member name="P:Animancer.Float3ControllerState.Parameter">
            <summary>
            Gets and sets <see cref="P:Animancer.Float3ControllerState.ParameterX"/>, <see cref="P:Animancer.Float3ControllerState.ParameterY"/>, and <see cref="P:Animancer.Float3ControllerState.ParameterZ"/>.
            </summary>
        </member>
        <member name="M:Animancer.Float3ControllerState.#ctor(UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.ParameterID,Animancer.ControllerState.ParameterID,Animancer.ControllerState.ParameterID,Animancer.ControllerState.ActionOnStop[])">
            <summary>Creates a new <see cref="T:Animancer.Float3ControllerState"/> to play the `controller`.</summary>
        </member>
        <member name="M:Animancer.Float3ControllerState.#ctor(UnityEngine.RuntimeAnimatorController,Animancer.ControllerState.ParameterID,Animancer.ControllerState.ParameterID,Animancer.ControllerState.ParameterID)">
            <summary>Creates a new <see cref="T:Animancer.Float3ControllerState"/> to play the `controller`.</summary>
        </member>
        <member name="P:Animancer.Float3ControllerState.ParameterCount">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Float3ControllerState.GetParameterHash(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Float3ControllerState.Clone(Animancer.AnimancerPlayable)">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.AnimancerEvent">
            <summary>
            A <see cref="F:Animancer.AnimancerEvent.callback"/> delegate paired with a <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> to determine when to invoke it.
            </summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/events/animancer">Animancer Events</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/AnimancerEvent
            
            https://kybernetik.com.au/animancer/api/Animancer/AnimancerEvent
        </member>
        <member name="F:Animancer.AnimancerEvent.normalizedTime">
            <summary>The <see cref="P:Animancer.AnimancerState.NormalizedTime"/> at which to invoke the <see cref="F:Animancer.AnimancerEvent.callback"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.callback">
            <summary>The delegate to invoke when the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> passes.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.AlmostOne">
            <summary>The largest possible float value less than 1.</summary>
            <remarks>
            This value is useful for placing events at the end of a looping animation since they do not allow the
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> to be greater than or equal to 1.
            </remarks>
        </member>
        <member name="F:Animancer.AnimancerEvent.DummyCallback">
            <summary>Does nothing.</summary>
            <remarks>This delegate is used for events which would otherwise have a <c>null</c> <see cref="F:Animancer.AnimancerEvent.callback"/>.</remarks>
        </member>
        <member name="M:Animancer.AnimancerEvent.Dummy">
            <summary>Does nothing.</summary>
            <remarks>Used by <see cref="F:Animancer.AnimancerEvent.DummyCallback"/>.</remarks>
        </member>
        <member name="M:Animancer.AnimancerEvent.IsNullOrDummy(System.Action)">
            <summary>Is the `callback` <c>null</c> or the <see cref="F:Animancer.AnimancerEvent.DummyCallback"/>?</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.#ctor(System.Single,System.Action)">
            <summary>Creates a new <see cref="T:Animancer.AnimancerEvent"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.ToString">
            <summary>Returns a string describing the details of this event.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.AppendDetails(System.Text.StringBuilder)">
            <summary>Appends the details of this event to the `text`.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.CurrentState">
            <summary>The <see cref="T:Animancer.AnimancerState"/> currently triggering an event via <see cref="M:Animancer.AnimancerEvent.Invoke(Animancer.AnimancerState)"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.CurrentEvent">
            <summary>The <see cref="T:Animancer.AnimancerEvent"/> currently being triggered via <see cref="M:Animancer.AnimancerEvent.Invoke(Animancer.AnimancerState)"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Invoke(Animancer.AnimancerState)">
            <summary>
            Sets the <see cref="P:Animancer.AnimancerEvent.CurrentState"/> and <see cref="P:Animancer.AnimancerEvent.CurrentEvent"/> then invokes the <see cref="F:Animancer.AnimancerEvent.callback"/>.
            </summary>
            <remarks>This method catches and logs any exception thrown by the <see cref="F:Animancer.AnimancerEvent.callback"/>.</remarks>
            <exception cref="T:System.NullReferenceException">The <see cref="F:Animancer.AnimancerEvent.callback"/> is null.</exception>
        </member>
        <member name="M:Animancer.AnimancerEvent.GetFadeOutDuration">
            <summary>
            Returns either the <see cref="P:Animancer.AnimancerPlayable.DefaultFadeDuration"/> or the
            <see cref="P:Animancer.AnimancerState.RemainingDuration"/> of the <see cref="P:Animancer.AnimancerEvent.CurrentState"/> (whichever is higher).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.GetFadeOutDuration(System.Single)">
            <summary>
            Returns either the `minDuration` or the <see cref="P:Animancer.AnimancerState.RemainingDuration"/> of the
            <see cref="P:Animancer.AnimancerEvent.CurrentState"/> (whichever is higher).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.GetFadeOutDuration(Animancer.AnimancerState,System.Single)">
            <summary>
            Returns either the `minDuration` or the <see cref="P:Animancer.AnimancerState.RemainingDuration"/> of the
            `state` (whichever is higher).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.op_Equality(Animancer.AnimancerEvent,Animancer.AnimancerEvent)">
            <summary>Are the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> and <see cref="F:Animancer.AnimancerEvent.callback"/> equal?</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.op_Inequality(Animancer.AnimancerEvent,Animancer.AnimancerEvent)">
            <summary>Are the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> and <see cref="F:Animancer.AnimancerEvent.callback"/> not equal?</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Equals(Animancer.AnimancerEvent)">
            <summary>[<see cref="T:System.IEquatable`1"/>]
            Are the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> and <see cref="F:Animancer.AnimancerEvent.callback"/> of this event equal to `other`?
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.AnimancerEvent.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.AnimancerEvent.Sequence">
            <summary>
            A variable-size list of <see cref="T:Animancer.AnimancerEvent"/>s which keeps itself sorted according to their
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>.
            </summary>
            <remarks>
            <em>Animancer Lite does not allow events (except for <see cref="P:Animancer.AnimancerEvent.Sequence.OnEnd"/>) in runtime builds.</em>
            <para></para>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/events/animancer">Animancer Events</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/Sequence
            
            https://kybernetik.com.au/animancer/api/Animancer/Sequence
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence._Events">
            <summary>All of the <see cref="T:Animancer.AnimancerEvent"/>s in this sequence (excluding the <see cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/>).</summary>
            <remarks>This field should never be null. It should use <see cref="M:System.Array.Empty``1"/> instead.</remarks>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Count">
            <summary>[Pro-Only] The number of events in this sequence (excluding the <see cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/>).</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.IsEmpty">
            <summary>Indicates whether the sequence has any events in it (including the <see cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/>).</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.DefaultCapacity">
            <summary>The initial <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> that will be used if another value is not specified.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Capacity">
            <summary>[Pro-Only] The size of the internal array used to hold events.</summary>
            <remarks>
            When set, the array is reallocated to the given size.
            <para></para>
            By default, the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> starts at 0 and increases to the <see cref="F:Animancer.AnimancerEvent.Sequence.DefaultCapacity"/>
            when the first event is added.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Version">
            <summary>[Pro-Only]
            The number of times the contents of this sequence have been modified. This applies to general events,
            but not the <see cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.ShouldNotModifyReason">
            <summary>[Assert-Only]
            If this property is set, any attempt to modify this sequence will trigger
            <see cref="F:Animancer.OptionalWarning.LockedEvents"/> (which will include this value in its message).
            </summary>
            <remarks>This value can be set by <see cref="M:Animancer.AnimancerEvent.Sequence.SetShouldNotModifyReason(System.String)"/>.</remarks>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.SetShouldNotModifyReason(System.String)">
            <summary>[Assert-Conditional]
            Sets the <see cref="P:Animancer.AnimancerEvent.Sequence.ShouldNotModifyReason"/> for <see cref="F:Animancer.OptionalWarning.LockedEvents"/>.
            </summary>
            <remarks>
            If the warning is triggered, the message is formatted as:
            "The <see cref="T:Animancer.AnimancerEvent.Sequence"/> being modified should not be modified because " + 
            <see cref="P:Animancer.AnimancerEvent.Sequence.ShouldNotModifyReason"/>.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.OnSequenceModified">
            <summary>[Assert-Conditional] Logs <see cref="F:Animancer.OptionalWarning.LockedEvents"/> if necessary.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.EndEvent">
             <summary>
             A <see cref="F:Animancer.AnimancerEvent.callback"/> that will be triggered every frame after the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> has
             passed. If you want it to only get triggered once, you can either have the event clear itself or just
             use a regular event instead.
             </summary>
            
             <example><code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
                 state.Events.NormalizedEndTime = 0.75f;
                 state.Events.OnEnd = OnAnimationEnd;
            
                 // Or set the time and callback at the same time:
                 state.Events.EndEvent = new AnimancerEvent(0.75f, OnAnimationEnd);
             }
            
             void OnAnimationEnd()
             {
                 Debug.Log("Animation ended");
             }
             </code></example>
            
             <remarks>
             Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/events/end">End Events</see>
             <para></para>
             Interrupting the animation does not trigger this event.
             <para></para>
             By default, the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> will be <see cref="F:System.Single.NaN"/> so that it can choose the
             correct value based on the current play direction: forwards ends at 1 and backwards ends at 0.
             <para></para>
             <em>Animancer Lite does not allow the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> to be changed in Runtime Builds.</em>
             </remarks>
             
             <seealso cref="P:Animancer.AnimancerEvent.Sequence.OnEnd"/>
             <seealso cref="P:Animancer.AnimancerEvent.Sequence.NormalizedEndTime"/>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.OnEnd">
            <summary>Shorthand for the <c>EndEvent.callback</c>.</summary>
            <seealso cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/>
            <seealso cref="P:Animancer.AnimancerEvent.Sequence.NormalizedEndTime"/>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.NormalizedEndTime">
            <summary>[Pro-Only] Shorthand for <c>EndEvent.normalizedTime</c>.</summary>
            <remarks>
            This value is <see cref="F:System.Single.NaN"/> by default so that the actual time can be determined based on the
            <see cref="P:Animancer.AnimancerNode.EffectiveSpeed"/>: positive speed ends at 1 and negative speed ends at 0.
            <para></para>
            Use <see cref="P:Animancer.AnimancerState.NormalizedEndTime"/> to access that value.
            </remarks>
            <seealso cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/>
            <seealso cref="P:Animancer.AnimancerEvent.Sequence.OnEnd"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.GetDefaultNormalizedStartTime(System.Single)">
            <summary>
            The default <see cref="P:Animancer.AnimancerState.NormalizedTime"/> for an animation to start at when playing
            forwards is 0 (the start of the animation) and when playing backwards is 1 (the end of the animation).
            <para></para>
            `speed` 0 or <see cref="F:System.Single.NaN"/> will also return 0.
            </summary>
            <remarks>
            This method has nothing to do with events, so it is only here because of
            <see cref="M:Animancer.AnimancerEvent.Sequence.GetDefaultNormalizedEndTime(System.Single)"/>.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.GetDefaultNormalizedEndTime(System.Single)">
            <summary>
            The default <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> for an <see cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/> when playing forwards is 1 (the
            end of the animation) and when playing backwards is 0 (the start of the animation).
            <para></para>
            `speed` 0 or <see cref="F:System.Single.NaN"/> will also return 1.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Names">
            <summary>[Pro-Only] The names of the events (excluding the <see cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/>).</summary>
            <remarks>This array can be <c>null</c>.</remarks>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.GetName(System.Int32)">
            <summary>[Pro-Only]
            Returns the name of the event at the specified `index` or <c>null</c> if it is outside of the
            <see cref="P:Animancer.AnimancerEvent.Sequence.Names"/> array.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.SetName(System.Int32,System.String)">
            <summary>[Pro-Only]
            Sets the name of the event at the specified `index`. If the <see cref="P:Animancer.AnimancerEvent.Sequence.Names"/> did not previously
            include that `index` it will be resized with a size equal to the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.IndexOf(System.String,System.Int32)">
            <summary>[Pro-Only]
            Returns the index of the event with the specified `name` or <c>-1</c> if there is no such event.
            </summary>
            <seealso cref="P:Animancer.AnimancerEvent.Sequence.Names"/>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.GetName(System.Int32)"/>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.SetName(System.Int32,System.String)"/>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.IndexOfRequired(System.String,System.Int32)"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.IndexOfRequired(System.String,System.Int32)">
            <summary>[Pro-Only] Returns the index of the event with the specified `name`.</summary>
            <exception cref="T:System.ArgumentException">There is no such event.</exception>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.IndexOf(System.String,System.Int32)"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.#ctor">
            <summary>
            Creates a new <see cref="T:Animancer.AnimancerEvent.Sequence"/> which starts at 0 <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/>.
            <para></para>
            Adding anything to the sequence will set the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> = <see cref="F:Animancer.AnimancerEvent.Sequence.DefaultCapacity"/>
            and then double it whenever the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> would exceed the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.#ctor(System.Int32)">
            <summary>[Pro-Only]
            Creates a new <see cref="T:Animancer.AnimancerEvent.Sequence"/> which starts with the specified <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/>. It will be
            initially empty, but will have room for the given number of elements before any reallocations are
            required.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.#ctor(Animancer.AnimancerEvent.Sequence)">
            <summary>Creates a new <see cref="T:Animancer.AnimancerEvent.Sequence"/> and copies the contents of `copyFrom` into it.</summary>
            <remarks>To copy into an existing sequence, use <see cref="M:Animancer.AnimancerEvent.Sequence.CopyFrom(Animancer.AnimancerEvent.Sequence)"/> instead.</remarks>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Item(System.Int32)">
            <summary>[Pro-Only] Returns the event at the specified `index`.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Item(System.String)">
            <summary>[Pro-Only] Returns the event with the specified `name`.</summary>
            <exception cref="T:System.ArgumentException">There is no event with the specified `name`.</exception>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AssertNormalizedTimes(Animancer.AnimancerState)">
            <summary>[Assert-Conditional]
            Throws an <see cref="T:System.ArgumentOutOfRangeException"/> if the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> of any events
            is less than 0 or greater than or equal to 1.
            <para></para>
            This does not include the <see cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/> since it works differently to other events.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AssertNormalizedTimes(Animancer.AnimancerState,System.Boolean)">
            <summary>[Assert-Conditional]
            Calls <see cref="M:Animancer.AnimancerEvent.Sequence.AssertNormalizedTimes(Animancer.AnimancerState)"/> if `isLooping` is true.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.DeepToString(System.Boolean)">
            <summary>Returns a string containing the details of all events in this sequence.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.GetEnumerator">
            <summary>[Pro-Only]
            Returns a <see cref="T:Animancer.FastEnumerator`1"/> for the events in this sequence excluding the
            <see cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.IndexOf(Animancer.AnimancerEvent)">
            <summary>[Pro-Only] Returns the index of the `animancerEvent` or <c>-1</c> if there is no such event.</summary>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.IndexOfRequired(System.Int32,Animancer.AnimancerEvent)"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.IndexOfRequired(Animancer.AnimancerEvent)">
            <summary>[Pro-Only] Returns the index of the `animancerEvent`.</summary>
            <exception cref="T:System.ArgumentException">There is no such event.</exception>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.IndexOf(Animancer.AnimancerEvent)"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.IndexOf(System.Int32,Animancer.AnimancerEvent)">
            <summary>[Pro-Only] Returns the index of the `animancerEvent` or <c>-1</c> if there is no such event.</summary>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.IndexOfRequired(System.Int32,Animancer.AnimancerEvent)"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.IndexOfRequired(System.Int32,Animancer.AnimancerEvent)">
            <summary>[Pro-Only] Returns the index of the `animancerEvent`.</summary>
            <exception cref="T:System.ArgumentException">There is no such event.</exception>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.IndexOf(System.Int32,Animancer.AnimancerEvent)"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Add(Animancer.AnimancerEvent)">
            <summary>[Pro-Only]
            Adds the given event to this sequence. The <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> is increased by one and if required, the
            <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> is doubled to fit the new event.
            </summary>
            <remarks>
            This methods returns the index at which the event is added, which is determined by its
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> to keep the sequence sorted in ascending order. If there are already any
            events with the same <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>, the new event is added immediately after them.
            </remarks>
            <exception cref="T:System.ArgumentNullException">Use the <see cref="F:Animancer.AnimancerEvent.DummyCallback"/> instead of <c>null</c>.</exception>
            <seealso cref="F:Animancer.OptionalWarning.DuplicateEvent"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Add(System.Single,System.Action)">
            <summary>[Pro-Only]
            Adds the given event to this sequence. The <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> is increased by one and if required, the
            <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> is doubled to fit the new event.
            </summary>
            <remarks>
            This methods returns the index at which the event is added, which is determined by its
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> to keep the sequence sorted in ascending order. If there are already any
            events with the same <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>, the new event is added immediately after them.
            </remarks>
            <seealso cref="F:Animancer.OptionalWarning.DuplicateEvent"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Add(System.Int32,Animancer.AnimancerEvent)">
            <summary>[Pro-Only]
            Adds the given event to this sequence. The <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> is increased by one and if required, the
            <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> is doubled to fit the new event.
            </summary>
            <remarks>
            This methods returns the index at which the event is added, which is determined by its
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> to keep the sequence sorted in ascending order. If there are already any
            events with the same <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>, the new event is added immediately after them.
            </remarks>
            <exception cref="T:System.ArgumentNullException">Use the <see cref="F:Animancer.AnimancerEvent.DummyCallback"/> instead of <c>null</c>.</exception>
            <seealso cref="F:Animancer.OptionalWarning.DuplicateEvent"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Add(System.Int32,System.Single,System.Action)">
            <summary>[Pro-Only]
            Adds the given event to this sequence. The <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> is increased by one and if required, the
            <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> is doubled to fit the new event.
            </summary>
            <remarks>
            This methods returns the index at which the event is added, which is determined by its
            <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> to keep the sequence sorted in ascending order. If there are already any
            events with the same <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>, the new event is added immediately after them.
            </remarks>
            <seealso cref="F:Animancer.OptionalWarning.DuplicateEvent"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AddRange(System.Collections.Generic.IEnumerable{Animancer.AnimancerEvent})">
            <summary>[Pro-Only]
            Adds every event in the `enumerable` to this sequence. The <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> is increased by one and if
            required, the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> is doubled to fit the new event.
            </summary>
            <seealso cref="F:Animancer.OptionalWarning.DuplicateEvent"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AddCallback(System.Int32,System.Action)">
            <summary>[Pro-Only] Adds the specified `callback` to the event at the specified `index`.</summary>
            <seealso cref="F:Animancer.OptionalWarning.DuplicateEvent"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AddCallback(System.String,System.Action)">
            <summary>[Pro-Only] Adds the specified `callback` to the event with the specified `name`.</summary>
            <exception cref="T:System.ArgumentException">There is no event with the specified `name`.</exception>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.IndexOfRequired(System.String,System.Int32)"/>
            <seealso cref="F:Animancer.OptionalWarning.DuplicateEvent"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.RemoveCallback(System.Int32,System.Action)">
            <summary>[Pro-Only] Removes the specified `callback` from the event at the specified `index`.</summary>
            <remarks>
            If the <see cref="F:Animancer.AnimancerEvent.callback"/> would become null, it is instead set to the <see cref="F:Animancer.AnimancerEvent.DummyCallback"/>
            since they are not allowed to be null.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.RemoveCallback(System.String,System.Action)">
            <summary>[Pro-Only] Removes the specified `callback` from the event with the specified `name`.</summary>
            <remarks>
            If the <see cref="F:Animancer.AnimancerEvent.callback"/> would become null, it is instead set to the <see cref="F:Animancer.AnimancerEvent.DummyCallback"/>
            since they are not allowed to be null.
            </remarks>
            <exception cref="T:System.ArgumentException">There is no event with the specified `name`.</exception>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.IndexOfRequired(System.String,System.Int32)"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.SetCallback(System.Int32,System.Action)">
            <summary>[Pro-Only] Replaces the <see cref="F:Animancer.AnimancerEvent.callback"/> of the event at the specified `index`.</summary>
            <exception cref="T:System.ArgumentNullException">Use the <see cref="F:Animancer.AnimancerEvent.DummyCallback"/> instead of <c>null</c>.</exception>
            <seealso cref="F:Animancer.OptionalWarning.DuplicateEvent"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.SetCallback(System.String,System.Action)">
            <summary>[Pro-Only] Replaces the <see cref="F:Animancer.AnimancerEvent.callback"/> of the event with the specified `name`.</summary>
            <exception cref="T:System.ArgumentException">There is no event with the specified `name`.</exception>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.IndexOfRequired(System.String,System.Int32)"/>
            <seealso cref="F:Animancer.OptionalWarning.DuplicateEvent"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AssertCallbackUniqueness(System.Action,System.Action,System.String)">
            <summary>[Assert-Conditional]
            Logs <see cref="F:Animancer.OptionalWarning.DuplicateEvent"/> if the `oldCallback` is identical to the
            `newCallback` or just has the same <see cref="P:System.Delegate.Method"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AssertEventUniqueness(System.Int32,Animancer.AnimancerEvent)">
            <summary>[Assert-Conditional]
            Logs <see cref="F:Animancer.OptionalWarning.DuplicateEvent"/> if the event at the specified `index` is identical to
            the `newEvent`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.SetNormalizedTime(System.Int32,System.Single)">
            <summary>[Pro-Only] Sets the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> of the event at the specified `index`.</summary>
            <remarks>
            If multiple events have the same <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>, this method will avoid re-arranging them
            where calling <see cref="M:Animancer.AnimancerEvent.Sequence.Remove(System.Int32)"/> then <see cref="M:Animancer.AnimancerEvent.Sequence.Add(Animancer.AnimancerEvent)"/> would always re-add the
            moved event as the last one with that time.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.SetNormalizedTime(System.String,System.Single)">
            <summary>[Pro-Only] Sets the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> of the event with the specified `name`.</summary>
            <remarks>
            If multiple events have the same <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>, this method will avoid re-arranging them
            where calling <see cref="M:Animancer.AnimancerEvent.Sequence.Remove(System.Int32)"/> then <see cref="M:Animancer.AnimancerEvent.Sequence.Add(Animancer.AnimancerEvent)"/> would always re-add the
            moved event as the last one with that time.
            </remarks>
            <exception cref="T:System.ArgumentException">There is no event with the specified `name`.</exception>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.IndexOfRequired(System.String,System.Int32)"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.SetNormalizedTime(Animancer.AnimancerEvent,System.Single)">
            <summary>[Pro-Only] Sets the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> of the matching `animancerEvent`.</summary>
            <remarks>
            If multiple events have the same <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>, this method will avoid re-arranging them
            where calling <see cref="M:Animancer.AnimancerEvent.Sequence.Remove(System.Int32)"/> then <see cref="M:Animancer.AnimancerEvent.Sequence.Add(Animancer.AnimancerEvent)"/> would always re-add the
            moved event as the last one with that time.
            </remarks>
            <exception cref="T:System.ArgumentException">There is no event matching the `animancerEvent`.</exception>
            <seealso cref="M:Animancer.AnimancerEvent.Sequence.IndexOfRequired(Animancer.AnimancerEvent)"/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Insert(System.Single)">
            <summary>[Pro-Only]
            Determines the index where a new event with the specified `normalizedTime` should be added in order to
            keep this sequence sorted, increases the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> by one, doubles the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/>
            if required, moves any existing events to open up the chosen index, and returns that index.
            <para></para>
            This overload starts searching for the desired index from the end of the sequence, using the assumption
            that elements will usually be added in order.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Insert(System.Int32,System.Single)">
            <summary>[Pro-Only]
            Determines the index where a new event with the specified `normalizedTime` should be added in order to
            keep this sequence sorted, increases the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> by one, doubles the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/>
            if required, moves any existing events to open up the chosen index, and returns that index.
            <para></para>
            This overload starts searching for the desired index from the `hint`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Insert(System.Int32)">
            <summary>[Pro-Only]
            Increases the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> by one, doubles the <see cref="P:Animancer.AnimancerEvent.Sequence.Capacity"/> if required, and moves any
            existing events to open up the `index`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Remove(System.Int32)">
            <summary>[Pro-Only]
            Removes the event at the specified `index` from this sequence by decrementing the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/>
            and copying all events after the removed one down one place.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Remove(System.String)">
            <summary>[Pro-Only]
            Removes the event with the specified `name` from this sequence by decrementing the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/>
            and copying all events after the removed one down one place. Returns true if the event was found and
            removed.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Remove(Animancer.AnimancerEvent)">
            <summary>[Pro-Only]
            Removes the `animancerEvent` from this sequence by decrementing the <see cref="P:Animancer.AnimancerEvent.Sequence.Count"/> and copying all
            events after the removed one down one place. Returns true if the event was found and removed.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Clear">
            <summary>Removes all events, including the <see cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.CopyFrom(Animancer.AnimancerEvent.Sequence)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.AddAllEvents(UnityEngine.AnimationClip)">
            <summary>[Pro-Only] Copies the <see cref="P:UnityEngine.AnimationClip.events"/> into this <see cref="T:Animancer.AnimancerEvent.Sequence"/>.</summary>
            <remarks>
            The <see cref="F:Animancer.AnimancerEvent.callback"/> of the new events will be empty and can be set by
            <see cref="M:Animancer.AnimancerEvent.Sequence.SetCallback(System.String,System.Action)"/>.
            <para></para>
            If you are going to play the `animation`, consider disabling <see cref="P:UnityEngine.Animator.fireEvents"/> so that
            the events copied by this method are not triggered as <see cref="T:UnityEngine.AnimationEvent"/>s. Otherwise they
            would still trigger in addition to the <see cref="T:Animancer.AnimancerEvent"/>s copied here.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.CopyTo(Animancer.AnimancerEvent[],System.Int32)">
            <summary>[<see cref="T:System.Collections.Generic.ICollection`1"/>] [Pro-Only]
            Copies all the events from this sequence into the `array`, starting at the `index`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.ContentsAreEqual(Animancer.AnimancerEvent.Sequence)">
            <summary>Are all events in this sequence identical to the ones in the `other` sequence?</summary>
        </member>
        <member name="T:Animancer.AnimancerEvent.Sequence.Serializable">
            <summary>
            An <see cref="T:Animancer.AnimancerEvent.Sequence"/> that can be serialized and uses <see cref="T:UnityEngine.Events.UnityEvent"/>s to define
            the <see cref="F:Animancer.AnimancerEvent.callback"/>s.
            </summary>
            <remarks>
            If you have Animancer Pro you can replace <see cref="T:UnityEngine.Events.UnityEvent"/>s with
            <see href="https://kybernetik.com.au/ultevents">UltEvents</see> using the following procedure:
            <list type="number">
            <item>Select the <c>Assets/Plugins/Animancer/Animancer.asmdef</c> and add a Reference to the
            <c>UltEvents</c> Assembly Definition.</item>
            <item>Go into the Player Settings of your project and add <c>ANIMANCER_ULT_EVENTS</c> as a Scripting
            Define Symbol. Or you can simply edit this script to change the event type (it is located at
            <c>Assets/Plugins/Animancer/Internal/Core/AnimancerEvent.Sequence.Serializable.cs</c> by default.</item>
            </list>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/events/animancer">Animancer Events</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/Serializable
            
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Serializable.NormalizedTimes">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The serialized <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>s.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Serializable.Callbacks">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The serialized <see cref="F:Animancer.AnimancerEvent.callback"/>s.</summary>
            <remarks>
            This array only needs to be large enough to hold the last event that actually contains any calls.
            Any empty or missing elements will simply use the <see cref="F:Animancer.AnimancerEvent.DummyCallback"/> at runtime.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Serializable.Names">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The serialized <see cref="P:Animancer.AnimancerEvent.Sequence.Names"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.Serializable.NormalizedTimesField">
            <summary>[Editor-Only, Internal] The name of the array field which stores the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/>s.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.Serializable.CallbacksField">
            <summary>[Editor-Only, Internal] The name of the array field which stores the serialized <see cref="F:Animancer.AnimancerEvent.callback"/>s.</summary>
        </member>
        <member name="F:Animancer.AnimancerEvent.Sequence.Serializable.NamesField">
            <summary>[Editor-Only, Internal] The name of the array field which stores the serialized <see cref="P:Animancer.AnimancerEvent.Sequence.Serializable.Names"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Serializable.Events">
            <summary>
            The runtime <see cref="T:Animancer.AnimancerEvent.Sequence"/> compiled from this <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/>.
            Each call after the first will return the same reference.
            </summary>
            <remarks>
            Unlike <see cref="M:Animancer.AnimancerEvent.Sequence.Serializable.GetEventsOptional"/>, this property will create an empty
            <see cref="T:Animancer.AnimancerEvent.Sequence"/> instead of returning null if there are no events.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.GetEventsOptional">
            <summary>
            Returns the runtime <see cref="T:Animancer.AnimancerEvent.Sequence"/> compiled from this <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/>.
            Each call after the first will return the same reference.
            </summary>
            <remarks>
            This method returns null if the sequence would be empty anyway and is used by the implicit
            conversion from <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/> to <see cref="T:Animancer.AnimancerEvent.Sequence"/>.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.op_Implicit(Animancer.AnimancerEvent.Sequence.Serializable)~Animancer.AnimancerEvent.Sequence">
            <summary>Calls <see cref="M:Animancer.AnimancerEvent.Sequence.Serializable.GetEventsOptional"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Serializable.InitializedEvents">
            <summary>Returns the <see cref="P:Animancer.AnimancerEvent.Sequence.Serializable.Events"/> or <c>null</c> if it wasn't yet initialized.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.GetInvoker(UnityEngine.Events.UnityEvent)">
            <summary>
            If the `callback` has any persistent calls, this method returns a delegate to call its
            <see cref="M:UnityEngine.Events.UnityEvent.Invoke"/> method. Otherwise it returns the
            <see cref="F:Animancer.AnimancerEvent.DummyCallback"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.GetInvoker(System.Object)">
            <summary>[Editor-Only]
            Casts the `callback` and calls <see cref="M:Animancer.AnimancerEvent.Sequence.Serializable.GetInvoker(UnityEngine.Events.UnityEvent)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.HasPersistentCalls(UnityEngine.Events.UnityEvent)">
            <summary>
            Determines if the `callback` contains any method calls that will be serialized (otherwise the
            <see cref="F:Animancer.AnimancerEvent.DummyCallback"/> can be used instead of creating a new delegate to invoke the empty
            `callback`).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.HasPersistentCalls(System.Object)">
            <summary>[Editor-Only]
            Casts the `callback` and calls <see cref="M:Animancer.AnimancerEvent.Sequence.Serializable.HasPersistentCalls(UnityEngine.Events.UnityEvent)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.GetNormalizedEndTime(System.Single)">
            <summary>Returns the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> of the <see cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/>.</summary>
            <remarks>If the value is not set, the value is determined by <see cref="M:Animancer.AnimancerEvent.Sequence.GetDefaultNormalizedEndTime(System.Single)"/>.</remarks>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.SetNormalizedEndTime(System.Single)">
            <summary>Sets the <see cref="F:Animancer.AnimancerEvent.normalizedTime"/> of the <see cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.CopyFrom(Animancer.AnimancerEvent.Sequence.Serializable)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.UnityEngine#ISerializationCallbackReceiver#OnAfterDeserialize">
            <summary>[Editor-Only] Does nothing.</summary>
            <remarks>
            Keeping the runtime <see cref="P:Animancer.AnimancerEvent.Sequence.Serializable.Events"/> in sync with the serialized data is handled by
            <see cref="T:Animancer.Editor.SerializableEventSequenceDrawer"/>.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.UnityEngine#ISerializationCallbackReceiver#OnBeforeSerialize">
            <summary>[Editor-Only] Ensures that the events are sorted by time (excluding the end event).</summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.DynamicSwap``1(``0[]@,System.Int32)">
            <summary>[Editor-Only]
            Swaps <c>array[index]</c> with <c>array[index - 1]</c> while accounting for the possibility of the
            `index` being beyond the bounds of the `array`.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerEvent.Sequence.Serializable.DisableCompactArrays">
            <summary>[Internal]
            Should the arrays be prevented from reducing their size when their last elements are unused?
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.CompactArrays">
            <summary>[Editor-Only]
            Removes empty data from the ends of the arrays to reduce the serialized data size.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerEvent.Sequence.Serializable.Trim``1(``0[]@,System.Int32,System.Func{``0,System.Boolean})">
            <summary>[Editor-Only] Removes unimportant values from the end of the `array`.</summary>
        </member>
        <member name="T:Animancer.Editor.SerializableCallbackHolder">
            <summary>[Editor-Only, Internal]
            A serializable container which holds a <see cref="T:UnityEngine.Events.UnityEvent"/> in a field named "_Callback".
            </summary>
            <remarks>
            <see cref="T:Animancer.Editor.DummySerializableCallback"/> needs to be in a file with the same name as it (otherwise it can't
            draw the callback properly) and this class needs to be in the same file as
            <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/> to use the <see cref="T:UnityEngine.Events.UnityEvent"/> alias.
            </remarks>
        </member>
        <member name="F:Animancer.Editor.SerializableCallbackHolder.CallbackField">
            <summary>The name of the field which stores the <see cref="T:UnityEngine.Events.UnityEvent"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.SoloAnimationEditor">
            <summary>[Editor-Only] A custom Inspector for <see cref="!:SoloAnimation"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/SoloAnimationEditor
            
        </member>
        <member name="F:Animancer.Editor.SoloAnimationEditor._Animators">
            <summary>The animator referenced by each target.</summary>
        </member>
        <member name="F:Animancer.Editor.SoloAnimationEditor._SerializedAnimator">
            <summary>A <see cref="T:UnityEditor.SerializedObject"/> encapsulating the <see cref="F:Animancer.Editor.SoloAnimationEditor._Animators"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.SoloAnimationEditor._KeepStateOnDisable">
            <summary>The <see cref="P:UnityEngine.Animator.keepAnimatorControllerStateOnDisable"/> property.</summary>
        </member>
        <member name="M:Animancer.Editor.SoloAnimationEditor.OnInspectorGUI">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.SoloAnimationEditor.DoSerializedFieldsGUI">
            <summary>Draws the target's serialized fields.</summary>
        </member>
        <member name="M:Animancer.Editor.SoloAnimationEditor.RefreshSerializedAnimator">
            <summary>Ensures that the cached references relating to the target's <see cref="T:UnityEngine.Animator"/> are correct.</summary>
        </member>
        <member name="M:Animancer.Editor.SoloAnimationEditor.DoStopOnDisableGUI">
            <summary>
            Draws a toggle inverted from the <see cref="P:UnityEngine.Animator.keepAnimatorControllerStateOnDisable"/> field.
            </summary>
        </member>
        <member name="M:Animancer.Editor.SoloAnimationEditor.DoRuntimeDetailsGUI">
            <summary>Draws the target's runtime details.</summary>
        </member>
        <member name="M:Animancer.Editor.SoloAnimationEditor.OnDisable">
            <summary>Cleans up cached references relating to the target's <see cref="T:UnityEngine.Animator"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.Tools.AnimancerSettingsTool">
            <summary>[Editor-Only] Displays the <see cref="T:Animancer.Editor.AnimancerSettingsInternal"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor.Tools/AnimancerSettingsTool
        </member>
        <member name="P:Animancer.Editor.Tools.AnimancerSettingsTool.DisplayOrder">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.AnimancerSettingsTool.Name">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.AnimancerSettingsTool.Instructions">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.AnimancerSettingsTool.HelpURL">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerSettingsTool.OnEnable(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerSettingsTool.OnDisable">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerSettingsTool.DoBodyGUI">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.Editor.Tools.AnimancerToolsWindow">
            <summary>[Editor-Only] [Pro-Only]
            An <see cref="T:UnityEditor.EditorWindow"/> with various utilities for managing sprites and generating animations.
            </summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/tools">Animancer Tools</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer.Editor.Tools/AnimancerToolsWindow
            
        </member>
        <member name="F:Animancer.Editor.Tools.AnimancerToolsWindow.Name">
            <summary>The display name of this window.</summary>
        </member>
        <member name="P:Animancer.Editor.Tools.AnimancerToolsWindow.Instance">
            <summary>The singleton instance of this window.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.FindSerializedPropertyForTool(Animancer.Editor.Tools.AnimancerToolsWindow.Tool)">
            <summary>Returns the <see cref="T:UnityEditor.SerializedProperty"/> which represents the specified `tool`.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.Repaint">
            <summary>Causes this window to redraw its GUI.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.RecordUndo">
            <summary>Calls <see cref="M:UnityEditor.Undo.RecordObject(UnityEngine.Object,System.String)"/> for this window.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.BeginChangeCheck">
            <summary>Calls <see cref="M:UnityEditor.EditorGUI.BeginChangeCheck"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.EndChangeCheck">
            <summary>Calls <see cref="M:UnityEditor.EditorGUI.EndChangeCheck"/> and <see cref="M:Animancer.Editor.Tools.AnimancerToolsWindow.RecordUndo"/> if it returned true.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.EndChangeCheck``1(``0@,``0)">
            <summary>Calls <see cref="M:Animancer.Editor.Tools.AnimancerToolsWindow.EndChangeCheck"/> and sets the <c>field = value</c> if it returned true.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.CreateReorderableList``1(System.Collections.Generic.List{``0},System.String,UnityEditorInternal.ReorderableList.ElementCallbackDelegate,System.Boolean)">
            <summary>Creates and initializes a new <see cref="T:UnityEditorInternal.ReorderableList"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.CreateReorderableObjectList``1(System.Collections.Generic.List{``0},System.String,System.Boolean)">
            <summary>Creates and initializes a new <see cref="T:UnityEditorInternal.ReorderableList"/> for <see cref="T:UnityEngine.Sprite"/>s.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.CreateReorderableStringList(System.Collections.Generic.List{System.String},System.String,System.Func{UnityEngine.Rect,System.Int32,System.String})">
            <summary>Creates a new <see cref="T:UnityEditorInternal.ReorderableList"/> for <see cref="T:System.String"/>s.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.CreateReorderableStringList(System.Collections.Generic.List{System.String},System.String)">
            <summary>Creates a new <see cref="T:UnityEditorInternal.ReorderableList"/> for <see cref="T:System.String"/>s.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.Open">
            <summary>Opens the <see cref="T:Animancer.Editor.Tools.AnimancerToolsWindow"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.Open(System.Type)">
            <summary>Opens the <see cref="T:Animancer.Editor.Tools.AnimancerToolsWindow"/> showing the specified `tool`.</summary>
        </member>
        <member name="T:Animancer.Editor.Tools.AnimancerToolsWindow.Tool">
            <summary>[Editor-Only] [Pro-Only] Base class for tools in the <see cref="T:Animancer.Editor.Tools.AnimancerToolsWindow"/>.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/tools">Animancer Tools</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer.Editor.Tools/Tool
            
        </member>
        <member name="P:Animancer.Editor.Tools.AnimancerToolsWindow.Tool.IsVisible">
            <summary>Is this tool currently visible?</summary>
        </member>
        <member name="P:Animancer.Editor.Tools.AnimancerToolsWindow.Tool.IsExpanded">
            <summary>Is the body of this tool currently visible?</summary>
        </member>
        <member name="P:Animancer.Editor.Tools.AnimancerToolsWindow.Tool.DisplayOrder">
            <summary>Lower numbers display first.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.Tool.CompareTo(Animancer.Editor.Tools.AnimancerToolsWindow.Tool)">
            <summary>Compares the <see cref="P:Animancer.Editor.Tools.AnimancerToolsWindow.Tool.DisplayOrder"/> to put lower numbers first.</summary>
        </member>
        <member name="P:Animancer.Editor.Tools.AnimancerToolsWindow.Tool.Name">
            <summary>The display name of this tool.</summary>
        </member>
        <member name="P:Animancer.Editor.Tools.AnimancerToolsWindow.Tool.Instructions">
            <summary>The usage instructions to display at the top of this tool.</summary>
        </member>
        <member name="P:Animancer.Editor.Tools.AnimancerToolsWindow.Tool.HelpURL">
            <summary>The URL for the help button in the header to open.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.Tool.OnSelectionChanged">
            <summary>Called whenever the <see cref="T:UnityEditor.Selection"/> changes.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.Tool.OnEnable(System.Int32)">
            <summary>Called by <see cref="M:Animancer.Editor.Tools.AnimancerToolsWindow.OnEnable"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.Tool.OnDisable">
            <summary>Called by <see cref="M:Animancer.Editor.Tools.AnimancerToolsWindow.OnDisable"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.Tool.DoGUI">
            <summary>Draws the GUI for this tool.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.Tool.DoHeaderGUI">
            <summary>
            Draws the Header GUI for this tool which is displayed regardless of whether it is expanded or not.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.Tool.DoBodyGUI">
            <summary>Draws the Body GUI for this tool which is only displayed while it is expanded.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.Tool.SaveModifiedAsset``1(System.String,System.String,``0,System.Action{``0})">
            <summary>Asks the user where they want to save a modified asset, calls `modify` on it, and saves it.</summary>
        </member>
        <member name="P:Animancer.Editor.Tools.AnimancerToolsWindow.Tool.HelpIcon">
            <summary>The help icon image used in the tool header.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimancerToolsWindow.Tool.HandleDragAndDropIntoList``1(UnityEngine.Rect,System.Collections.Generic.IList{``0},System.Boolean,System.Func{``0,System.Boolean})">
            <summary>Adds any objects dropped in the `area` to the `list`.</summary>
        </member>
        <member name="T:Animancer.Editor.Tools.AnimationModifierTool">
            <summary>[Editor-Only] [Pro-Only]
            A base <see cref="T:Animancer.Editor.Tools.AnimancerToolsWindow.Tool"/> for modifying <see cref="T:UnityEngine.AnimationClip"/>s.
            </summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/tools">Animancer Tools</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer.Editor.Tools/AnimationModifierTool
            
        </member>
        <member name="P:Animancer.Editor.Tools.AnimationModifierTool.Animation">
            <summary>The currently selected <see cref="T:UnityEngine.AnimationClip"/> asset.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimationModifierTool.OnEnable(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimationModifierTool.OnSelectionChanged">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimationModifierTool.OnAnimationChanged">
            <summary>Called whenever the selected <see cref="P:Animancer.Editor.Tools.AnimationModifierTool.Animation"/> changes.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.AnimationModifierTool.DoBodyGUI">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.Editor.Tools.GenerateSpriteAnimationsTool">
            <summary>[Editor-Only] [Pro-Only] 
            A <see cref="T:Animancer.Editor.Tools.SpriteModifierTool"/> for generating <see cref="T:UnityEngine.AnimationClip"/>s from <see cref="T:UnityEngine.Sprite"/>s.
            </summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/tools/generate-sprite-animations">Generate Sprite Animations</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer.Editor.Tools/GenerateSpriteAnimationsTool
            
        </member>
        <member name="P:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.DisplayOrder">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.Name">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.HelpURL">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.Instructions">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.OnEnable(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.OnSelectionChanged">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.DoBodyGUI">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.GenerateAnimationsBySpriteName(System.Collections.Generic.List{UnityEngine.Sprite})">
            <summary>Uses <see cref="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.GatherNameToSprites(System.Collections.Generic.List{UnityEngine.Sprite},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{UnityEngine.Sprite}})"/> and creates new animations from those groups.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.GatherNameToSprites(System.Collections.Generic.List{UnityEngine.Sprite},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{UnityEngine.Sprite}})">
            <summary>Groups the `sprites` by name into the `nameToSptires`.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.ValidateGenerateAnimationsBySpriteName">
            <summary>Should <see cref="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.GenerateAnimationsBySpriteName"/> be enabled or greyed out?</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.GenerateAnimationsBySpriteName">
            <summary>Calls <see cref="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.GenerateAnimationsBySpriteName(System.Collections.Generic.List{UnityEngine.Sprite})"/> with the selected <see cref="T:UnityEngine.Sprite"/>s.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.GetCachedSpritesToGenerateAnimations">
            <summary>
            Returns a list of <see cref="T:UnityEngine.Sprite"/>s which will be passed into
            <see cref="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.GenerateAnimationsBySpriteName(System.Collections.Generic.List{UnityEngine.Sprite})"/> by <see cref="F:UnityEditor.EditorApplication.delayCall"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.GenerateAnimationsFromSpriteByName(UnityEditor.MenuCommand)">
            <summary>
            Adds the <see cref="F:UnityEditor.MenuCommand.context"/> to the <see cref="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.GetCachedSpritesToGenerateAnimations"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.ValidateGenerateAnimationsFromTextureBySpriteName(UnityEditor.MenuCommand)">
            <summary>Should <see cref="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.GenerateAnimationsFromTextureBySpriteName(UnityEditor.MenuCommand)"/> be enabled or greyed out?</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.GenerateAnimationsFromTextureBySpriteName(UnityEditor.MenuCommand)">
            <summary>
            Adds all <see cref="T:UnityEngine.Sprite"/> sub-assets of the <see cref="F:UnityEditor.MenuCommand.context"/> to the
            <see cref="M:Animancer.Editor.Tools.GenerateSpriteAnimationsTool.GetCachedSpritesToGenerateAnimations"/>.
            </summary>
        </member>
        <member name="T:Animancer.Editor.Tools.ModifySpritesTool">
            <summary>[Editor-Only] [Pro-Only] 
            A <see cref="T:Animancer.Editor.Tools.SpriteModifierTool"/> for modifying <see cref="T:UnityEngine.Sprite"/> detauls.
            </summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/tools/modify-sprites">Modify Sprites</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer.Editor.Tools/ModifySpritesTool
            
        </member>
        <member name="P:Animancer.Editor.Tools.ModifySpritesTool.DisplayOrder">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.ModifySpritesTool.Name">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.ModifySpritesTool.HelpURL">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.ModifySpritesTool.Instructions">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.ModifySpritesTool.OnEnable(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.ModifySpritesTool.DoBodyGUI">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.Editor.Tools.PackTexturesTool">
            <summary>[Editor-Only] [Pro-Only] 
            A <see cref="T:Animancer.Editor.Tools.AnimancerToolsWindow.Tool"/> for packing multiple <see cref="T:UnityEngine.Texture2D"/>s into a single image.
            </summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/tools/pack-textures">Pack Textures</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer.Editor.Tools/PackTexturesTool
            
        </member>
        <member name="P:Animancer.Editor.Tools.PackTexturesTool.DisplayOrder">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.PackTexturesTool.Name">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.PackTexturesTool.HelpURL">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.PackTexturesTool.Instructions">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.PackTexturesTool.OnEnable(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.PackTexturesTool.DoBodyGUI">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.PackTexturesTool.RemoveDuplicates``1(System.Collections.Generic.IList{``0})">
            <summary>Removes any items from the `list` that are the same as earlier items.</summary>
        </member>
        <member name="T:Animancer.Editor.Tools.RemapAnimationBindingsTool">
            <summary>[Editor-Only] [Pro-Only] 
            A <see cref="T:Animancer.Editor.Tools.AnimancerToolsWindow.Tool"/> for changing which bones an <see cref="T:UnityEngine.AnimationClip"/>s controls.
            </summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/tools/remap-animation-bindings">Remap Animation Bindings</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer.Editor.Tools/RemapAnimationBindingsTool
            
        </member>
        <member name="P:Animancer.Editor.Tools.RemapAnimationBindingsTool.DisplayOrder">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.RemapAnimationBindingsTool.Name">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.RemapAnimationBindingsTool.HelpURL">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.RemapAnimationBindingsTool.Instructions">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.RemapAnimationBindingsTool.OnEnable(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.RemapAnimationBindingsTool.OnAnimationChanged">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.RemapAnimationBindingsTool.DoBodyGUI">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.RemapAnimationBindingsTool.GatherBindings">
            <summary>Gathers the bindings from the <see cref="P:Animancer.Editor.Tools.AnimationModifierTool.Animation"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.RemapAnimationBindingsTool.IsHumanoidBinding(System.String)">
            <summary>Is the `propertyName` one of the bindings used by Humanoid animations?</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.RemapAnimationBindingsTool.CopyAll">
            <summary>Copies all of the <see cref="F:Animancer.Editor.Tools.RemapAnimationBindingsTool._NewBindingPaths"/> to the system clipboard.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.RemapAnimationBindingsTool.PasteAll">
            <summary>Pastes the string from the system clipboard into the <see cref="F:Animancer.Editor.Tools.RemapAnimationBindingsTool._NewBindingPaths"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.Tools.RemapSpriteAnimationTool">
            <summary>[Editor-Only] [Pro-Only] 
            An <see cref="T:Animancer.Editor.Tools.AnimationModifierTool"/> for changing which <see cref="T:UnityEngine.Sprite"/>s an
            <see cref="T:UnityEngine.AnimationClip"/> uses.
            </summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/tools/remap-sprite-animation">Remap Sprite Animation</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer.Editor.Tools/RemapSpriteAnimationTool
            
        </member>
        <member name="P:Animancer.Editor.Tools.RemapSpriteAnimationTool.DisplayOrder">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.RemapSpriteAnimationTool.Name">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.RemapSpriteAnimationTool.HelpURL">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.RemapSpriteAnimationTool.Instructions">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.RemapSpriteAnimationTool.OnEnable(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.RemapSpriteAnimationTool.OnAnimationChanged">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.RemapSpriteAnimationTool.DoBodyGUI">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.RemapSpriteAnimationTool.GatherOldSprites">
            <summary>Gathers the <see cref="F:Animancer.Editor.Tools.RemapSpriteAnimationTool._OldSprites"/> from the <see cref="P:Animancer.Editor.Tools.AnimationModifierTool.Animation"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.Tools.RenameSpritesTool">
            <summary>[Editor-Only] [Pro-Only] A <see cref="T:Animancer.Editor.Tools.SpriteModifierTool"/> for bulk-renaming <see cref="T:UnityEngine.Sprite"/>s.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/tools/rename-sprites">Rename Sprites</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer.Editor.Tools/RenameSpritesTool
            
        </member>
        <member name="P:Animancer.Editor.Tools.RenameSpritesTool.DisplayOrder">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.RenameSpritesTool.Name">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.RenameSpritesTool.HelpURL">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.Editor.Tools.RenameSpritesTool.Instructions">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.RenameSpritesTool.OnEnable(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.RenameSpritesTool.OnSelectionChanged">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.RenameSpritesTool.UpdateNames">
            <summary>Refreshes the <see cref="F:Animancer.Editor.Tools.RenameSpritesTool._Names"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.RenameSpritesTool.DoBodyGUI">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.Editor.Tools.SpriteDataEditor">
            <summary>A wrapper around the '2D Sprite' package features for editing Sprite data.</summary>
        </member>
        <member name="P:Animancer.Editor.Tools.SpriteDataEditor.SpriteCount">
            <summary>The number of sprites in the target data.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteDataEditor.GetName(System.Int32)">
            <summary>Returns the name of the sprite at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteDataEditor.SetName(System.Int32,System.String)">
            <summary>Sets the name of the sprite at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteDataEditor.GetRect(System.Int32)">
            <summary>Returns the rect of the sprite at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteDataEditor.SetRect(System.Int32,UnityEngine.Rect)">
            <summary>Sets the rect of the sprite at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteDataEditor.GetPivot(System.Int32)">
            <summary>Returns the pivot of the sprite at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteDataEditor.SetPivot(System.Int32,UnityEngine.Vector2)">
            <summary>Sets the pivot of the sprite at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteDataEditor.GetAlignment(System.Int32)">
            <summary>Returns the alignment of the sprite at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteDataEditor.SetAlignment(System.Int32,UnityEngine.SpriteAlignment)">
            <summary>Sets the alignment of the sprite at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteDataEditor.GetBorder(System.Int32)">
            <summary>Returns the border of the sprite at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteDataEditor.SetBorder(System.Int32,UnityEngine.Vector4)">
            <summary>Sets the border of the sprite at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteDataEditor.#ctor(UnityEditor.TextureImporter)">
            <summary>Creates a new <see cref="T:Animancer.Editor.Tools.SpriteDataEditor"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteDataEditor.IndexOf(UnityEngine.Sprite)">
            <summary>Tries to find the index of the data matching the `sprite`.</summary>
            <remarks>
            Returns -1 if there is no data matching the <see cref="P:UnityEngine.Object.name"/>.
            <para></para>
            Returns -2 if there is more than one data matching the <see cref="P:UnityEngine.Object.name"/> but no
            <see cref="P:UnityEngine.Sprite.rect"/> match.
            </remarks>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteDataEditor.ValidateBounds(System.Int32,UnityEngine.Sprite)">
            <summary>Logs an error and returns false if the data at the specified `index` is out of the texture bounds.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteDataEditor.Apply">
            <summary>Applies any modifications to the target asset.</summary>
        </member>
        <member name="T:Animancer.Editor.Tools.SpriteModifierTool">
            <summary>[Editor-Only] [Pro-Only]
            A base <see cref="T:Animancer.Editor.Tools.AnimancerToolsWindow.Tool"/> for modifying <see cref="T:UnityEngine.Sprite"/>s.
            </summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/tools">Animancer Tools</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer.Editor.Tools/SpriteModifierTool
            
        </member>
        <member name="P:Animancer.Editor.Tools.SpriteModifierTool.Sprites">
            <summary>The currently selected <see cref="T:UnityEngine.Sprite"/>s.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteModifierTool.OnSelectionChanged">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteModifierTool.DoBodyGUI">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteModifierTool.GatherSelectedSprites(System.Collections.Generic.List{UnityEngine.Sprite})">
            <summary>
            Adds all <see cref="T:UnityEngine.Sprite"/>s in the <see cref="P:UnityEditor.Selection.objects"/> or their sub-assets to the
            list of `sprites`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteModifierTool.LoadAllSpritesInTexture(UnityEngine.Texture2D)">
            <summary>Returns all the <see cref="T:UnityEngine.Sprite"/> sub-assets of the `texture`.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteModifierTool.LoadAllSpritesAtPath(System.String)">
            <summary>Returns all the <see cref="T:UnityEngine.Sprite"/> assets at the `path`.</summary>
        </member>
        <member name="M:Animancer.Editor.Tools.SpriteModifierTool.NaturalCompare(UnityEngine.Object,UnityEngine.Object)">
            <summary>Calls <see cref="M:UnityEditor.EditorUtility.NaturalCompare(System.String,System.String)"/> on the <see cref="P:UnityEngine.Object.name"/>s.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerEditorUtilities">
            <summary>[Editor-Only] Various utilities used throughout Animancer.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/AnimancerEditorUtilities
            
            https://kybernetik.com.au/animancer/api/Animancer.Editor/AnimancerEditorUtilities
            https://kybernetik.com.au/animancer/api/Animancer.Editor/AnimancerEditorUtilities
        </member>
        <member name="F:Animancer.Editor.AnimancerEditorUtilities.AnyAccessBindings">
            <summary>Commonly used <see cref="T:System.Reflection.BindingFlags"/> combinations.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerEditorUtilities.InstanceBindings">
            <summary>Commonly used <see cref="T:System.Reflection.BindingFlags"/> combinations.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerEditorUtilities.StaticBindings">
            <summary>Commonly used <see cref="T:System.Reflection.BindingFlags"/> combinations.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.GetAttribute``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
            <summary>[Animancer Extension] [Editor-Only]
            Returns the first <typeparamref name="TAttribute"/> attribute on the `member` or <c>null</c> if there is none.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.IsNaN(UnityEngine.Vector2)">
            <summary>[Animancer Extension] [Editor-Only] Is the <see cref="F:UnityEngine.Vector2.x"/> or <see cref="F:UnityEngine.Vector2.y"/> NaN?</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.IsNaN(UnityEngine.Vector3)">
            <summary>[Animancer Extension] [Editor-Only] Is the <see cref="F:UnityEngine.Vector3.x"/>, <see cref="F:UnityEngine.Vector3.y"/>, or <see cref="F:UnityEngine.Vector3.z"/> NaN?</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.FindAssetOfType``1">
            <summary>Finds an asset of the specified type anywhere in the project.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.ToStringCached(System.Single)">
            <summary>[Animancer Extension]
            Calls <see cref="M:System.Single.ToString(System.String)"/> using <c>"g"</c> as the format and caches the result.
            </summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.PlayModeState">
            <summary>The most recent <see cref="T:UnityEditor.PlayModeStateChange"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.IsChangingPlayMode">
            <summary>Is the Unity Editor is currently changing between Play Mode and Edit Mode?</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.SetCount``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>Adds default items or removes items to make the <see cref="P:System.Collections.Generic.List`1.Count"/> equal to the `count`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.RemoveMissingAndDuplicates(System.Collections.Generic.List{UnityEngine.GameObject}@)">
            <summary>
            Removes any items from the `list` that are <c>null</c> and items that appear multiple times.
            Returns true if the `list` was modified.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.RemoveDestroyedObjects``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>Removes any items from the `dictionary` that use destroyed objects as their key.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.InitializeCleanDictionary``2(System.Collections.Generic.Dictionary{``0,``1}@)">
            <summary>
            Creates a new dictionary and returns true if it was null or calls <see cref="M:Animancer.Editor.AnimancerEditorUtilities.RemoveDestroyedObjects``2(System.Collections.Generic.Dictionary{``0,``1})"/> and
            returns false if it wasn't.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.AddFadeFunction(UnityEditor.GenericMenu,System.String,System.Boolean,Animancer.AnimancerNode,System.Action{System.Single})">
            <summary>
            Adds a menu function which passes the result of <see cref="M:Animancer.Editor.AnimancerEditorUtilities.CalculateEditorFadeDuration(Animancer.AnimancerNode,System.Single)"/> into `startFade`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.CalculateEditorFadeDuration(Animancer.AnimancerNode,System.Single)">
            <summary>[Animancer Extension] [Editor-Only]
            Returns the duration of the `node`s current fade (if any), otherwise returns the `defaultDuration`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.AddDocumentationLink(UnityEditor.GenericMenu,System.String,System.String)">
            <summary>
            Adds a menu function to open a web page. If the `linkSuffix` starts with a '/' then it will be relative to
            the <see cref="F:Animancer.Strings.DocsURLs.Documentation"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.ValidateEditable(UnityEditor.MenuCommand)">
            <summary>Is the <see cref="F:UnityEditor.MenuCommand.context"/> editable?</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.ToggleLooping(UnityEditor.MenuCommand)">
            <summary>Toggles the <see cref="P:UnityEngine.Motion.isLooping"/> flag between true and false.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.SetLooping(UnityEngine.AnimationClip,System.Boolean)">
            <summary>Sets the <see cref="P:UnityEngine.Motion.isLooping"/> flag.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.ToggleLegacy(UnityEditor.MenuCommand)">
            <summary>Swaps the <see cref="P:UnityEngine.AnimationClip.legacy"/> flag between true and false.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.RestoreBindPose(UnityEditor.MenuCommand)">
            <summary>Calls <see cref="M:UnityEngine.Animator.Rebind"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.GetNameCS(System.Type,System.Boolean)">
            <summary>Returns the name of a `type` as it would appear in C# code.</summary>
            <remarks>Returned values are stored in a dictionary to speed up repeated use.</remarks>
            <example>
            <c>typeof(List&lt;float&gt;).FullName</c> would give you:
            <c>System.Collections.Generic.List`1[[System.Single, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]</c>
            <para></para>
            This method would instead return <c>System.Collections.Generic.List&lt;float&gt;</c> if `fullName` is <c>true</c>, or
            just <c>List&lt;float&gt;</c> if it is <c>false</c>.
            </example>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.AppendNameAndGenericArguments(System.Text.StringBuilder,System.Type,System.Boolean,System.Int32)">
            <summary>Appends the generic arguments of `type` (after skipping the specified number).</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent">
            <summary>[Editor-Only]
            An <see cref="T:Animancer.IAnimancerComponent"/> which is not actually a <see cref="T:UnityEngine.Component"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.#ctor(UnityEngine.Animator,Animancer.AnimancerPlayable)">
            <summary>Creates a new <see cref="T:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.enabled">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns true.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.gameObject">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns the <see cref="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.Animator"/>'s <see cref="T:UnityEngine.GameObject"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.Animator">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] The target <see cref="T:UnityEngine.Animator"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.Playable">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] The target <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.IsPlayableInitialized">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns true.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.ResetOnDisable">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns false.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.UpdateMode">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] The <see cref="P:UnityEngine.Animator.updateMode"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.GetKey(UnityEngine.AnimationClip)">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns the `clip`.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.AnimatorFieldName">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns null.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.ActionOnDisableFieldName">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns null.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerEditorUtilities.DummyAnimancerComponent.InitialUpdateMode">
            <summary>[<see cref="T:Animancer.IAnimancerComponent"/>] Returns the <see cref="P:UnityEngine.Animator.updateMode"/> from when this object was created.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.FindRoot(UnityEngine.GameObject)">
             <summary>Takes a `gameObject` and returns the root <see cref="T:UnityEngine.Transform"/> of the character it is part of.</summary>
             
             <remarks>
             This method first searches all parents for an <see cref="T:Animancer.ICharacterRoot"/>. If it finds one, it returns the
             <see cref="P:Animancer.ICharacterRoot.transform"/>.
             <para></para>
             Otherwise, if the object is part of a prefab then it returns the root of that prefab instance.
             <para></para>
             Otherwise, it counts the number of Animators in the children of the `gameObject` then does
             the same for each parent. If it finds a parent with a different number of child Animators, it
             assumes that object is the parent of multiple characters and returns the previous parent as the root.
             </remarks>
            
             <example>
             <h2>Simple Hierarchy</h2>
             <code>
             - Character - Rigidbody, etc.
                 - Model - Animator, AnimancerComponent
                 - States - Various components which reference the AnimationClips they will play
             </code>
             Passing the <c>Model</c> into this method will return the <c>Character</c> because it has the same
             number of Animator components in its children.
            
             <h2>Shared Hierarchy</h2>
             <code>
             - Characters - Empty object used to group all characters
                 - Character - Rigidbody, etc.
                     - Model - Animator, AnimancerComponent
                     - States - Various components which reference the AnimationClips they will play
                 - Another Character
                     - Model
                     - States
             </code>
             <list type="bullet">
             <item><c>Model</c> has one Animator and no more in its children.</item>
             <item>And <c>Character</c> has one Animator in its children (the same one).</item>
             <item>But <c>Characters</c> has two Animators in its children (one on each character).</item>
             </list>
             So it picks the <c>Character</c> as the root.
            
             <h2>Complex Hierarchy</h2>
             <code>
             - Character - Rigidbody, etc.
                 - Model - Animator, AnimancerComponent
                 - States - Various components which reference the AnimationClips they will play
                 - Another Model - Animator (maybe the character is holding a gun which has a reload animation)
             </code>
             In this case, the automatic system would see that the <c>Character</c> already has more child
             <see cref="T:UnityEngine.Animator"/>s than the selected <c>Model</c> so it would only return the <c>Model</c> itself.
             This can be fixed by making any of the scripts on the <c>Character</c> implement <see cref="T:Animancer.ICharacterRoot"/>
             to tell the system which object you want it to use as the root.
             </example>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.FindRoot(UnityEngine.Object)">
            <summary>
            Calls <see cref="M:Animancer.Editor.AnimancerEditorUtilities.FindRoot(UnityEngine.GameObject)"/> if the specified `obj` is a <see cref="T:UnityEngine.GameObject"/> or
            <see cref="T:UnityEngine.Component"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.TryGetGameObject(UnityEngine.Object,UnityEngine.GameObject@)">
            <summary>Outputs the <see cref="T:UnityEngine.GameObject"/> assignated with the `obj` and returns true if it exists.</summary>
            <remarks>
            If the `obj` is a <see cref="T:UnityEngine.GameObject"/> it is used as the result.
            <para></para>
            Or if the `obj` is a <see cref="T:UnityEngine.Component"/> then its <see cref="P:UnityEngine.Component.gameObject"/> is used as the result.
            </remarks>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.AddContextMenuIK(UnityEditor.GenericMenu,Animancer.IPlayableWrapper)">
            <summary>
            Adds functions to show and set <see cref="P:Animancer.IPlayableWrapper.ApplyAnimatorIK"/> and
            <see cref="P:Animancer.IPlayableWrapper.ApplyFootIK"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerEditorUtilities.NormalizeChildWeights(Animancer.IPlayableWrapper)">
            <summary>Re-scales the <see cref="P:Animancer.AnimancerNode.Weight"/> of all children to add up to 1.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerSettingsInternal">
            <summary>[Editor-Only] Persistent settings used by Animancer.</summary>
            <remarks>
            This asset automatically creates itself when first accessed such as when opening the
            <see cref="T:Animancer.Editor.TransitionPreviewWindow"/> or viewing an <see cref="T:Animancer.Units.AnimationTimeAttribute"/>.
            <para></para>
            The default location is <em>Assets/Plugins/Animancer/Editor</em>, but you can freely move it (and the whole
            Animancer folder) anywhere in your project.
            <para></para>
            These settings can also be accessed via the Settings in the <see cref="T:Animancer.Editor.Tools.AnimancerToolsWindow"/>
            (<c>Window/Animation/Animancer Tools</c>).
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/AnimancerSettings
            
        </member>
        <member name="P:Animancer.Editor.AnimancerSettingsInternal.Instance">
            <summary>
            Loads an existing <see cref="T:Animancer.Editor.AnimancerSettingsInternal"/> if there is one anywhere in your project, but otherwise
            creates a new one and saves it in the same folder as this script.
            </summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerSettingsInternal.SerializedObject">
            <summary>The <see cref="T:UnityEditor.SerializedProperty"/> representing the <see cref="P:Animancer.Editor.AnimancerSettingsInternal.Instance"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerSettingsInternal.Group">
            <summary>Base class for groups of fields that can be serialized inside <see cref="T:Animancer.Editor.AnimancerSettingsInternal"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerSettingsInternal.Group.SetBasePropertyPath(System.String)">
            <summary>[Internal] Sets the prefix for <see cref="M:Animancer.Editor.AnimancerSettingsInternal.Group.GetSerializedProperty(System.String)"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerSettingsInternal.Group.GetSerializedProperty(System.String)">
            <summary>Returns a <see cref="T:UnityEditor.SerializedProperty"/> relative to the base of this group.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerSettingsInternal.Group.DoPropertyField(System.String)">
            <summary>
            Draws a <see cref="M:UnityEditor.EditorGUILayout.PropertyField(UnityEditor.SerializedProperty,UnityEngine.GUILayoutOption[])"/> for a
            property in this group.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerSettingsInternal.OnEnable">
            <summary>Initializes the serialized fields.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerSettingsInternal.SetDirty">
            <summary>Calls <see cref="M:UnityEditor.EditorUtility.SetDirty(UnityEngine.Object)"/> on the <see cref="P:Animancer.Editor.AnimancerSettingsInternal.Instance"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerSettingsInternal.TransitionPreviewWindow">
            <summary>Settings for the <see cref="P:Animancer.Editor.AnimancerSettingsInternal.TransitionPreviewWindow"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerSettingsInternal.AnimationTimeFields">
            <summary>Settings for the <see cref="T:Animancer.Units.AnimationTimeAttribute"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerSettingsInternal.InspectorRepaintInterval">
            <summary>
            The amount of time between repaint commands when
            <see cref="F:Animancer.Editor.AnimancerPlayableDrawer.RepaintConstantly"/> is disabled.
            </summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerSettingsInternal.FrameStep">
            <summary>The amount of time that will be added by a single frame step (in seconds).</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerSettingsInternal.NewAnimationFrameRate">
            <summary>The frame rate to use for new animations.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerSettingsInternal.HideEventCallbacks">
            <summary>Should Animancer Event Callbacks be hidden in the Inspector?</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerSettingsInternal.Editor">
            <summary>A custom Inspector for <see cref="T:Animancer.Editor.AnimancerSettingsInternal"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerSettingsInternal.Editor.OnInspectorGUI">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.Editor.AnimationType">
            <summary>[Editor-Only] The general type of object an <see cref="T:UnityEngine.AnimationClip"/> can animate.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/AnimationType
            
        </member>
        <member name="F:Animancer.Editor.AnimationType.None">
            <summary>Unable to determine a type.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationType.Humanoid">
            <summary>A Humanoid rig.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationType.Generic">
            <summary>A Generic rig.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationType.Sprite">
            <summary>A <see cref="F:Animancer.Editor.AnimationType.Generic"/> rig which only animates a <see cref="P:UnityEngine.SpriteRenderer.sprite"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimationBindings">
            <summary>[Editor-Only]
            Various utility functions relating to the properties animated by an <see cref="T:UnityEngine.AnimationClip"/>.
            </summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/AnimationBindings
            
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.GetAnimationType(UnityEngine.AnimationClip)">
            <summary>Determines the <see cref="T:Animancer.Editor.AnimationType"/> of the specified `clip`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.GetAnimationType(UnityEngine.Animator)">
            <summary>Determines the <see cref="T:Animancer.Editor.AnimationType"/> of the specified `animator`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.GetAnimationType(UnityEngine.GameObject)">
            <summary>Determines the <see cref="T:Animancer.Editor.AnimationType"/> of the specified `gameObject`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.CanGatherBindings">
            <summary>No more than one set of bindings should be gathered per frame.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.GetBindings(UnityEngine.GameObject,System.Boolean)">
            <summary>Returns a cached <see cref="T:Animancer.Editor.AnimationBindings.BindingData"/> representing the specified `gameObject`.</summary>
            <remarks>Note that the cache is cleared by <see cref="E:UnityEditor.EditorApplication.hierarchyChanged"/>.</remarks>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.GetBindings(UnityEngine.AnimationClip)">
            <summary>Returns a cached array of all properties animated by the specified `clip`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.OnPostprocessAnimation(UnityEngine.GameObject,UnityEngine.AnimationClip)">
            <summary>Called when Unity imports an animation.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.OnAnimationChanged(UnityEngine.AnimationClip)">
            <summary>Clears any cached values relating to the `clip` since they may no longer be correct.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.ClearCache">
            <summary>Clears all cached values in this class.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimationBindings.BindingData">
            <summary>
            A collection of data about the properties on a <see cref="T:UnityEngine.GameObject"/> and its children
            which can be animated and the relationships between those properties and the properties that individual
            <see cref="T:UnityEngine.AnimationClip"/>s are trying to animate.
            </summary>
        </member>
        <member name="F:Animancer.Editor.AnimationBindings.BindingData.GameObject">
            <summary>The target object that this data represents.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.BindingData.#ctor(UnityEngine.GameObject)">
            <summary>Creates a new <see cref="T:Animancer.Editor.AnimationBindings.BindingData"/> representing the specified `gameObject`.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimationBindings.BindingData.ObjectType">
            <summary>The cached <see cref="T:Animancer.Editor.AnimationType"/> of the <see cref="F:Animancer.Editor.AnimationBindings.BindingData.GameObject"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimationBindings.BindingData.ObjectBindings">
            <summary>The cached properties of the <see cref="F:Animancer.Editor.AnimationBindings.BindingData.GameObject"/> and its children which can be animated.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimationBindings.BindingData.ObjectTransformBindings">
            <summary>
            The <see cref="F:UnityEditor.EditorCurveBinding.path"/> of all <see cref="T:UnityEngine.Transform"/> bindings in
            <see cref="P:Animancer.Editor.AnimationBindings.BindingData.ObjectBindings"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.BindingData.GetMatchType(UnityEngine.Animator,Animancer.AnimancerState,System.Text.StringBuilder,System.Boolean)">
            <summary>
            Determines the <see cref="T:Animancer.Editor.AnimationBindings.MatchType"/> representing the properties animated by the `state` in
            comparison to the properties that actually exist on the target <see cref="F:Animancer.Editor.AnimationBindings.BindingData.GameObject"/> and its
            children.
            <para></para>
            Also compiles a `message` explaining the differences if that paraneter is not null.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.BindingData.GetMatchType(UnityEngine.AnimationClip,System.Text.StringBuilder,System.Collections.Generic.Dictionary{UnityEditor.EditorCurveBinding,System.Boolean},System.Int32@,System.Boolean)">
            <summary>
            Determines the <see cref="T:Animancer.Editor.AnimationBindings.MatchType"/> representing the properties animated by the `clip` in
            comparison to the properties that actually exist on the target <see cref="F:Animancer.Editor.AnimationBindings.BindingData.GameObject"/> and its
            children.
            <para></para>
            Also compiles a `message` explaining the differences if that paraneter is not null.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.BindingData.LogIssues(Animancer.AnimancerState,Animancer.Editor.AnimationBindings.MatchType)">
            <summary>
            Logs a description of the issues found when comparing the properties animated by the `state` to the
            properties that actually exist on the target <see cref="F:Animancer.Editor.AnimationBindings.BindingData.GameObject"/> and its children.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.BindingData.OnAnimationChanged(UnityEngine.AnimationClip)">
            <summary>[Internal] Removes any cached values relating to the `clip`.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimationBindings.MatchType">
            <summary>
            A summary of the compatability between the properties animated by an <see cref="T:UnityEngine.AnimationClip"/> and the
            properties that actually exist on a particular <see cref="T:UnityEngine.GameObject"/> (and its children).
            </summary>
        </member>
        <member name="F:Animancer.Editor.AnimationBindings.MatchType.Correct">
            <summary>All properties exist.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationBindings.MatchType.Unknown">
            <summary>Not yet checked.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationBindings.MatchType.Empty">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> does not animate anything.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationBindings.MatchType.Warning">
            <summary>Some of the animated properties do not exist on the object.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationBindings.MatchType.Error">
            <summary>None of the animated properties exist on the object.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.DoBindingMatchGUI(UnityEngine.Rect@,Animancer.AnimancerState)">
            <summary>
            Draws a <see cref="M:UnityEngine.GUI.Button(UnityEngine.Rect,UnityEngine.GUIContent,UnityEngine.GUIStyle)"/> indicating the <see cref="T:Animancer.Editor.AnimationBindings.MatchType"/> of the
            `state` compared to the object it is being played on.
            <para></para>
            Clicking the button calls <see cref="M:Animancer.Editor.AnimationBindings.BindingData.LogIssues(Animancer.AnimancerState,Animancer.Editor.AnimationBindings.MatchType)"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.GetIcon(Animancer.Editor.AnimationBindings.MatchType)">
            <summary>Get an icon = corresponding to the specified <see cref="T:Animancer.Editor.AnimationBindings.MatchType"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationBindings.AssertIcons">
            <summary>A unit test to make sure that the icons are properly loaded.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimationGatherer">
            <summary>[Editor-Only]
            A system that procedurally gathers animations throughout the hierarchy without needing explicit references.
            </summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/AnimationGatherer
            
        </member>
        <member name="F:Animancer.Editor.AnimationGatherer.Clips">
            <summary>All the <see cref="T:UnityEngine.AnimationClip"/>s that have been gathered.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationGatherer.Transitions">
            <summary>All the <see cref="T:Animancer.ITransition"/>s that have been gathered.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.ClearCache">
            <summary>Clears all cached gatherers.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationGatherer.logExceptions">
            <summary>Should exceptions thrown while gathering animations be logged? Default is false to ignore them.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.HandleException(System.Exception)">
            <summary>Logs the `exception` if <see cref="F:Animancer.Editor.AnimationGatherer.logExceptions"/> is true. Otherwise does nothing.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.GatherFromGameObject(UnityEngine.GameObject)">
            <summary>
            Returns a cached <see cref="T:Animancer.Editor.AnimationGatherer"/> containing any <see cref="T:UnityEngine.AnimationClip"/>s referenced by
            components in the same hierarchy as the `gameObject`. See <see cref="T:Animancer.ICharacterRoot"/> for details.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.GatherFromGameObject(UnityEngine.GameObject,System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>
            Fills the `clips` with any <see cref="T:UnityEngine.AnimationClip"/>s referenced by components in the same hierarchy as
            the `gameObject`. See <see cref="T:Animancer.ICharacterRoot"/> for details.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.GatherFromGameObject(UnityEngine.GameObject,UnityEngine.AnimationClip[]@,System.Boolean)">
            <summary>
            Fills the `clips` with any <see cref="T:UnityEngine.AnimationClip"/>s referenced by components in the same hierarchy as
            the `gameObject`. See <see cref="T:Animancer.ICharacterRoot"/> for details.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.GatherFromObject(System.Object,System.Int32)">
            <summary>Gathers all animations from the `source`s fields.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimationGatherer.TypeToGathererDelegate">
            <summary>Types mapped to a delegate that can quickly gather their clips.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.GatherFromFields(System.Object,System.Int32)">
            <summary>
            Uses reflection to gather <see cref="T:UnityEngine.AnimationClip"/>s from fields on the `source` object.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimationGatherer.BuildClipGathererDelegate(System.Type,System.Int32)">
            <summary>
            Creates a delegate to gather <see cref="T:UnityEngine.AnimationClip"/>s from all relevant fields in a given `type`.
            </summary>
        </member>
        <member name="T:Animancer.Editor.AttributeCache`1">
            <summary>[Editor-Only] A cache to optimize repeated attribute access.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/AttributeCache_1
            
        </member>
        <member name="M:Animancer.Editor.AttributeCache`1.GetAttribute(System.Reflection.MemberInfo)">
            <summary>
            Returns the <typeparamref name="TAttribute"/> attribute on the specified `member` (if there is one).
            </summary>
        </member>
        <member name="M:Animancer.Editor.AttributeCache`1.GetAttribute(System.Type)">
            <summary>
            Returns the <typeparamref name="TAttribute"/> attribute (if any) on the specified `type` or its
            <see cref="P:System.Type.BaseType"/> (recursively).
            </summary>
        </member>
        <member name="M:Animancer.Editor.AttributeCache`1.FindAttribute(System.Reflection.FieldInfo)">
            <summary>
            Returns the <typeparamref name="TAttribute"/> attribute on the specified `field` or its
            <see cref="P:System.Reflection.FieldInfo.FieldType"/> or <see cref="P:System.Reflection.MemberInfo.DeclaringType"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AttributeCache`1.FindAttribute(UnityEditor.SerializedProperty)">
            <summary>[Editor-Only]
            Returns the <typeparamref name="TAttribute"/> attribute on the underlying field of the `property` or its
            <see cref="P:System.Reflection.FieldInfo.FieldType"/> or <see cref="P:System.Reflection.MemberInfo.DeclaringType"/> or any of the parent properties
            or the type of the <see cref="P:UnityEditor.SerializedObject.targetObject"/>.
            </summary>
        </member>
        <member name="T:Animancer.Editor.SelfDrawerDrawer">
            <summary>[Editor-Only] Draws the GUI for a <see cref="T:Animancer.SelfDrawerAttribute"/> field.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/SelfDrawerDrawer
            
        </member>
        <member name="P:Animancer.Editor.SelfDrawerDrawer.Attribute">
            <summary>Casts the <see cref="P:UnityEditor.PropertyDrawer.attribute"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.SelfDrawerDrawer.CanCacheInspectorGUI(UnityEditor.SerializedProperty)">
            <summary>Calls <see cref="M:Animancer.SelfDrawerAttribute.CanCacheInspectorGUI(UnityEditor.SerializedProperty)"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.SelfDrawerDrawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>Calls <see cref="M:Animancer.SelfDrawerAttribute.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.SelfDrawerDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>Calls <see cref="M:Animancer.SelfDrawerAttribute.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.CompactUnitConversionCache">
            <summary>[Editor-Only]
            A system for formatting floats as strings that fit into a limited area and storing the results so they can be
            reused to minimise the need for garbage collection, particularly for string construction.
            </summary>
            <example>
            With <c>"x"</c> as the suffix:
            <list type="bullet">
            <item><c>1.111111</c> could instead show <c>1.111~x</c>.</item>
            <item><c>0.00001234567</c> would normally show <c>1.234567e-05</c>, but with this it instead shows <c>0~x</c>
            because very small values generally aren't useful.</item>
            <item><c>99999999</c> shows <c>1e+08x</c> because very large values are already approximations and trying to
            format them correctly would be very difficult.</item>
            </list>
            This system only affects the display value. Once you select a field, it shows its actual value.
            </example>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/CompactUnitConversionCache
            
        </member>
        <member name="F:Animancer.Editor.CompactUnitConversionCache.Suffix">
            <summary>The suffix added to the end of each value.</summary>
        </member>
        <member name="F:Animancer.Editor.CompactUnitConversionCache.ApproximateSuffix">
            <summary>The <see cref="F:Animancer.Editor.CompactUnitConversionCache.Suffix"/> with a <c>~</c> before it to indicate an approximation.</summary>
        </member>
        <member name="F:Animancer.Editor.CompactUnitConversionCache.ConvertedZero">
            <summary>The value <c>0</c> with the <see cref="F:Animancer.Editor.CompactUnitConversionCache.Suffix"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.CompactUnitConversionCache.ConvertedSmallPositive">
            <summary>The value <c>0</c> with the <see cref="F:Animancer.Editor.CompactUnitConversionCache.ApproximateSuffix"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.CompactUnitConversionCache.ConvertedSmallNegative">
            <summary>The value <c>-0</c> with the <see cref="F:Animancer.Editor.CompactUnitConversionCache.ApproximateSuffix"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.CompactUnitConversionCache._SuffixWidth">
            <summary>The pixel width of the <see cref="F:Animancer.Editor.CompactUnitConversionCache.Suffix"/> when drawn by <see cref="P:UnityEditor.EditorStyles.numberField"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.CompactUnitConversionCache.Caches">
            <summary>The caches for each character count.</summary>
            <remarks><c>this[x]</c> is a cache that outputs strings with <c>x</c> characters.</remarks>
        </member>
        <member name="F:Animancer.Editor.CompactUnitConversionCache._WidthCache">
            <summary>Strings mapped to the width they would require for a <see cref="P:UnityEditor.EditorStyles.numberField"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.CompactUnitConversionCache._FieldPadding">
            <summary>Padding around the text in a <see cref="P:UnityEditor.EditorStyles.numberField"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.CompactUnitConversionCache._ApproximateSymbolWidth">
            <summary>The pixel width of the <c>~</c> character when drawn by <see cref="P:UnityEditor.EditorStyles.numberField"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.CompactUnitConversionCache._DecimalSeparator">
            <summary>The character(s) used to separate decimal values in the current OS language.</summary>
        </member>
        <member name="F:Animancer.Editor.CompactUnitConversionCache.SmallExponentialThreshold">
            <summary>Values smaller than this become <c>0~</c> or <c>-0~</c>.</summary>
        </member>
        <member name="F:Animancer.Editor.CompactUnitConversionCache.LargeExponentialThreshold">
            <summary>Values larger than this can't be approximated.</summary>
        </member>
        <member name="M:Animancer.Editor.CompactUnitConversionCache.#ctor(System.String)">
            <summary>Creates a new <see cref="T:Animancer.Editor.CompactUnitConversionCache"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.CompactUnitConversionCache.Convert(System.Single,System.Single)">
            <summary>
            Returns a cached string representing the `value` trimmed to fit within the `width` (if necessary) and with
            the <see cref="F:Animancer.Editor.CompactUnitConversionCache.Suffix"/> added on the end.
            </summary>
        </member>
        <member name="M:Animancer.Editor.CompactUnitConversionCache.CalculateCacheIndex(System.Single,System.Single)">
            <summary>Calculate the index of the cache to use for the given parameters.</summary>
        </member>
        <member name="M:Animancer.Editor.CompactUnitConversionCache.GetCache(System.Int32)">
            <summary>Creates and returns a cache for the specified `characterCount`.</summary>
        </member>
        <member name="M:Animancer.Editor.CompactUnitConversionCache.GetExponentialFormat(System.Int32)">
            <summary>Returns a format string to include the specified number of `digits` in an exponential number.</summary>
        </member>
        <member name="T:Animancer.Editor.ConversionCache`2">
            <summary>[Editor-Only]
            A simple system for converting objects and storing the results so they can be reused to minimise the need for
            garbage collection, particularly for string construction.
            </summary>
            <remarks>This class doesn't use any Editor-Only functionality, but it's unlikely to be useful at runtime.</remarks>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/ConversionCache_2
            
        </member>
        <member name="M:Animancer.Editor.ConversionCache`2.#ctor(System.Func{`0,`1})">
            <summary>
            Creates a new <see cref="T:Animancer.Editor.ConversionCache`2"/> which uses the specified delegate to convert values.
            </summary>
        </member>
        <member name="M:Animancer.Editor.ConversionCache`2.Convert(`0)">
            <summary>
            If a value has already been cached for the specified `key`, return it. Otherwise create a new one using
            the delegate provided in the constructor and cache it.
            <para></para>
            If the `key` is <c>null</c>, this method returns the default <typeparamref name="TValue"/>.
            </summary>
            <remarks>This method also periodically removes values that have not been used recently.</remarks>
        </member>
        <member name="T:Animancer.Editor.AnimancerGraphControls">
            <summary>[Editor-Only] Draws manual controls for the <see cref="P:Animancer.AnimancerPlayable.Graph"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/AnimancerGraphControls
            
        </member>
        <member name="M:Animancer.Editor.AnimancerGraphControls.DoGraphGUI(Animancer.AnimancerPlayable,UnityEngine.Rect@)">
            <summary>Draws manual controls for the <see cref="P:Animancer.AnimancerPlayable.Graph"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGraphControls._ShowAddAnimation">
            <summary>Are the Add Animation controls active?</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGraphControls.AddAddAnimationFunction(UnityEditor.GenericMenu)">
            <summary>Adds a function to show or hide the "Add Animation" field.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerGUI">
            <summary>[Editor-Only] Various GUI utilities used throughout Animancer.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/AnimancerGUI
            
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI.WarningFieldColor">
            <summary>The highlight color used for fields showing a warning.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI.ErrorFieldColor">
            <summary>The highlight color used for fields showing an error.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI.DontExpandWidth">
            <summary><see cref="M:UnityEngine.GUILayout.ExpandWidth(System.Boolean)"/> set to false.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.LineHeight">
            <summary>Returns <see cref="P:UnityEditor.EditorGUIUtility.singleLineHeight"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.StandardSpacing">
            <summary>Returns <see cref="P:UnityEditor.EditorGUIUtility.standardVerticalSpacing"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.IndentSize">
            <summary>
            The number of pixels of indentation for each <see cref="P:UnityEditor.EditorGUI.indentLevel"/> increment.
            </summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.ToggleWidth">
            <summary>The width of a standard <see cref="P:UnityEngine.GUISkin.toggle"/> with no label.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.TextColor">
            <summary>The color of the standard label text.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.MiniButton">
            <summary>A more compact <see cref="P:UnityEditor.EditorStyles.miniButton"/> with a fixed size as a tiny box.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.RepaintEverything">
            <summary>Calls <see cref="M:UnityEditorInternal.InternalEditorUtility.RepaintAllViews"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerGUI.SpacingMode">
            <summary>Indicates where <see cref="M:Animancer.Editor.AnimancerGUI.LayoutSingleLineRect(Animancer.Editor.AnimancerGUI.SpacingMode)"/> should add the <see cref="P:Animancer.Editor.AnimancerGUI.StandardSpacing"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI.SpacingMode.None">
            <summary>No extra space.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI.SpacingMode.Before">
            <summary>Add extra space before the new area.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI.SpacingMode.After">
            <summary>Add extra space after the new area.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI.SpacingMode.BeforeAndAfter">
            <summary>Add extra space before and after the new area.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.LayoutSingleLineRect(Animancer.Editor.AnimancerGUI.SpacingMode)">
            <summary>
            Uses <see cref="M:UnityEngine.GUILayoutUtility.GetRect(System.Single,System.Single)"/> to get a <see cref="T:UnityEngine.Rect"/> occupying a single
            standard line with the <see cref="P:Animancer.Editor.AnimancerGUI.StandardSpacing"/> added according to the specified `spacing`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.NextVerticalArea(UnityEngine.Rect@)">
            <summary>
            If the <see cref="P:UnityEngine.Rect.height"/> is positive, this method moves the <see cref="P:UnityEngine.Rect.y"/> by that amount and
            adds the <see cref="P:UnityEditor.EditorGUIUtility.standardVerticalSpacing"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.StealFromLeft(UnityEngine.Rect@,System.Single,System.Single)">
            <summary>
            Subtracts the `width` from the left side of the `area` and returns a new <see cref="T:UnityEngine.Rect"/> occupying the
            removed section.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.StealFromRight(UnityEngine.Rect@,System.Single,System.Single)">
            <summary>
            Subtracts the `width` from the right side of the `area` and returns a new <see cref="T:UnityEngine.Rect"/> occupying the
            removed section.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.SplitHorizontally(UnityEngine.Rect,System.String,System.String,System.Single@,System.Single@,UnityEngine.Rect@,UnityEngine.Rect@)">
            <summary>
            Divides the given `area` such that the fields associated with both labels will have equal space
            remaining after the labels themselves.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.CalculateWidth(UnityEngine.GUIStyle,UnityEngine.GUIContent)">
            <summary>[Animancer Extension] Calls <see cref="M:UnityEngine.GUIStyle.CalcMinMaxWidth(UnityEngine.GUIContent,System.Single@,System.Single@)"/> and returns the max width.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.CalculateWidth(UnityEngine.GUIStyle,System.String)">
            <summary>[Animancer Extension] Calls <see cref="M:UnityEngine.GUIStyle.CalcMinMaxWidth(UnityEngine.GUIContent,System.Single@,System.Single@)"/> and returns the max width.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.CreateWidthCache(UnityEngine.GUIStyle)">
            <summary>
            Creates a <see cref="T:Animancer.Editor.ConversionCache`2"/> for calculating the GUI width occupied by text using the
            specified `style`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.CalculateLabelWidth(System.String)">
            <summary>
            Calls <see cref="M:UnityEngine.GUIStyle.CalcMinMaxWidth(UnityEngine.GUIContent,System.Single@,System.Single@)"/> using <see cref="P:UnityEngine.GUISkin.label"/> and returns the max
            width. The result is cached for efficient reuse.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.BeginVerticalBox(UnityEngine.GUIStyle)">
            <summary>
            Begins a vertical layout group using the given style and decreases the
            <see cref="P:UnityEditor.EditorGUIUtility.labelWidth"/> to compensate for the indentation.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.EndVerticalBox(UnityEngine.GUIStyle)">
            <summary>
            Ends a layout group started by <see cref="M:Animancer.Editor.AnimancerGUI.BeginVerticalBox(UnityEngine.GUIStyle)"/> and restores the
            <see cref="P:UnityEditor.EditorGUIUtility.labelWidth"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.ReSelectCurrentObjects">
            <summary>Clears the <see cref="P:UnityEditor.Selection.objects"/> then returns it to its current state.</summary>
            <remarks>
            This forces the <see cref="T:UnityEditorInternal.ReorderableList"/> drawer to adjust to height changes which
            it unfortunately doesn't do on its own..
            </remarks>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.DoWeightLabel(UnityEngine.Rect@,System.Single)">
            <summary>
            Draws a label showing the `weight` aligned to the right side of the `area` and reduces its
            <see cref="P:UnityEngine.Rect.width"/> to remove that label from its area.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.WeightToShortString(System.Single,System.Boolean@)">
            <summary>Returns a string which approximates the `weight` into no more than 3 digits.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerGUI._TightLabelWidth">
            <summary>The <see cref="P:UnityEditor.EditorGUIUtility.labelWidth"/> from before <see cref="M:Animancer.Editor.AnimancerGUI.BeginTightLabel(System.String)"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.BeginTightLabel(System.String)">
            <summary>Stores the <see cref="P:UnityEditor.EditorGUIUtility.labelWidth"/> and changes it to the exact width of the `label`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.EndTightLabel">
            <summary>Reverts <see cref="P:UnityEditor.EditorGUIUtility.labelWidth"/> to its previous value.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.GetNarrowText(System.String)">
            <summary>
            Returns the `text` without any spaces if <see cref="P:UnityEditor.EditorGUIUtility.wideMode"/> is false.
            Otherwise simply returns the `text` without any changes.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.LoadIcon(System.String)">
            <summary>Loads an icon texture and sets it to use <see cref="F:UnityEngine.FilterMode.Bilinear"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.IconContent(UnityEngine.GUIContent@,System.String)">
            <summary>Calls <see cref="M:UnityEditor.EditorGUIUtility.IconContent(System.String)"/> if the `content` was null.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.CompactMiniButton(UnityEngine.GUIContent)">
            <summary>Draws a button using <see cref="P:UnityEditor.EditorStyles.miniButton"/> and <see cref="F:Animancer.Editor.AnimancerGUI.DontExpandWidth"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.CompactMiniButton(UnityEngine.Rect,UnityEngine.GUIContent)">
            <summary>Draws a button using <see cref="P:UnityEditor.EditorStyles.miniButton"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.PlayButtonContent">
            <summary><see cref="M:Animancer.Editor.AnimancerGUI.IconContent(UnityEngine.GUIContent@,System.String)"/> for a play button.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.PauseButtonContent">
            <summary><see cref="M:Animancer.Editor.AnimancerGUI.IconContent(UnityEngine.GUIContent@,System.String)"/> for a pause button.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.StepBackwardButtonContent">
            <summary><see cref="M:Animancer.Editor.AnimancerGUI.IconContent(UnityEngine.GUIContent@,System.String)"/> for a step backward button.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.StepForwardButtonContent">
            <summary><see cref="M:Animancer.Editor.AnimancerGUI.IconContent(UnityEngine.GUIContent@,System.String)"/> for a step forward button.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerGUI.PlayButtonWidth">
            <summary>The default width of <see cref="P:Animancer.Editor.AnimancerGUI.PlayButtonContent"/> using <see cref="P:UnityEditor.EditorStyles.miniButton"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.TryUseClickEvent(UnityEngine.Rect,System.Int32)">
            <summary>
            Returns true and uses the current event if it is <see cref="F:UnityEngine.EventType.MouseUp"/> inside the specified
            `area`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.TryUseClickEventInLastRect(System.Int32)">
            <summary>
            Returns true and uses the current event if it is <see cref="F:UnityEngine.EventType.MouseUp"/> inside the last GUI Layout
            <see cref="T:UnityEngine.Rect"/> that was drawn.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.HandleDragAndDrop``1(UnityEngine.Rect,System.Func{``0,System.Boolean},System.Action{``0},UnityEditor.DragAndDropVisualMode)">
            <summary>
            Invokes `onDrop` if the <see cref="P:UnityEngine.Event.current"/> is a drag and drop event inside the `dropArea`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.TryDrop``1(System.Collections.IEnumerable,System.Func{``0,System.Boolean},System.Action{``0},System.Boolean,UnityEditor.DragAndDropVisualMode)">
            <summary>
            Updates the <see cref="P:UnityEditor.DragAndDrop.visualMode"/> or calls `onDrop` for each of the `objects`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.HandleDragAndDropAnimations(UnityEngine.Rect,System.Action{UnityEngine.AnimationClip},UnityEditor.DragAndDropVisualMode)">
            <summary>
            Uses <see cref="M:Animancer.Editor.AnimancerGUI.HandleDragAndDrop``1(UnityEngine.Rect,System.Func{``0,System.Boolean},System.Action{``0},UnityEditor.DragAndDropVisualMode)"/> to deal with drag and drop operations involving
            <see cref="T:UnityEngine.AnimationClip"/>s of <see cref="T:UnityEngine.IAnimationClipSource"/>s.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerGUI.Deselect">
            <summary>Deselects any selected IMGUI control.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerLayerDrawer">
            <summary>[Editor-Only]
            A custom Inspector for an <see cref="T:Animancer.AnimancerLayer"/> which sorts and exposes some of its internal values.
            </summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/AnimancerLayerDrawer
            
        </member>
        <member name="F:Animancer.Editor.AnimancerLayerDrawer.ActiveStates">
            <summary>The states in the target layer which have non-zero <see cref="P:Animancer.AnimancerNode.Weight"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerLayerDrawer.InactiveStates">
            <summary>The states in the target layer which have zero <see cref="P:Animancer.AnimancerNode.Weight"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerLayerDrawer.RegionStyle">
            <summary>The <see cref="T:UnityEngine.GUIStyle"/> used for the area encompassing this drawer is <see cref="P:UnityEngine.GUISkin.box"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.GatherLayerEditors(Animancer.AnimancerPlayable,System.Collections.Generic.List{Animancer.Editor.AnimancerLayerDrawer},System.Int32@)">
            <summary>
            Initializes an editor in the list for each layer in the `animancer`.
            <para></para>
            The `count` indicates the number of elements actually being used. Spare elements are kept in the list in
            case they need to be used again later.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.GatherStates(Animancer.AnimancerLayer)">
            <summary>
            Sets the target `layer` and sorts its states and their keys into the active/inactive lists.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.SortAndGatherKeys(System.Collections.Generic.List{Animancer.AnimancerState})">
            <summary>
            Sorts any entries that use another state as their key to come right after that state.
            See <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoLabelGUI(UnityEngine.Rect)">
            <summary>Draws the layer's name and weight.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerLayerDrawer.FoldoutIndent">
            <summary>The number of pixels of indentation required to fit the foldout arrow.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoFoldoutGUI(UnityEngine.Rect)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoDetailsGUI">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoLayerDetailsGUI">
            <summary>
            Draws controls for <see cref="P:Animancer.AnimancerLayer.IsAdditive"/> and <see cref="F:Animancer.AnimancerLayer._Mask"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoStatesGUI(System.String,System.Collections.Generic.List{Animancer.AnimancerState})">
            <summary>Draws all `states` in the given list.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerLayerDrawer.StateInspectors">
            <summary>Cached Inspectors that have already been created for states.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoStateGUI(Animancer.AnimancerState)">
            <summary>Draws the Inspector for the given `state`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoChildStatesGUI(Animancer.AnimancerState)">
            <summary>Draws all child states of the `state`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoHeaderGUI">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.DoGUI">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.HandleDragAndDropAnimations(UnityEngine.Rect,Animancer.IAnimancerComponent,System.Int32)">
            <summary>
            If <see cref="T:UnityEngine.AnimationClip"/>s or <see cref="T:UnityEngine.IAnimationClipSource"/>s are dropped inside the `dropArea`,
            this method creates a new state in the `target` for each animation.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerLayerDrawer.PopulateContextMenu(UnityEditor.GenericMenu)">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.Editor.IAnimancerNodeDrawer">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="T:Animancer.AnimancerNode"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/IAnimancerNodeDrawer
            
        </member>
        <member name="M:Animancer.Editor.IAnimancerNodeDrawer.DoGUI">
            <summary>Draws the details and controls for the target node in the Inspector.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerNodeDrawer`1">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="T:Animancer.AnimancerNode"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/AnimancerNodeDrawer_1
            
        </member>
        <member name="P:Animancer.Editor.AnimancerNodeDrawer`1.Target">
            <summary>The node being managed.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerNodeDrawer`1.IsExpanded">
            <summary>If true, the details of the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/> will be expanded in the Inspector.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerNodeDrawer`1.RegionStyle">
            <summary>The <see cref="T:UnityEngine.GUIStyle"/> used for the area encompassing this drawer.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoGUI">
            <summary>Draws the details and controls for the target <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/> in the Inspector.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoHeaderGUI">
            <summary>
            Draws the name and other details of the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/> in the GUI.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoLabelGUI(UnityEngine.Rect)">
            <summary>
            Draws a field for the <see cref="P:Animancer.AnimancerState.MainObject"/> if it has one, otherwise just a simple text
            label.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoFoldoutGUI(UnityEngine.Rect)">
            <summary>Draws a foldout arrow to expand/collapse the node details.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoDetailsGUI">
            <summary>Draws the details of the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/> in the GUI.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoNodeDetailsGUI">
            <summary>
            Draws controls for <see cref="P:Animancer.AnimancerState.IsPlaying"/>, <see cref="P:Animancer.AnimancerNode.Speed"/>, and
            <see cref="P:Animancer.AnimancerNode.Weight"/>.
            </summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerNodeDrawer`1.AutoNormalizeSiblingWeights">
            <summary>Indicates whether changing the <see cref="P:Animancer.AnimancerNode.Weight"/> should normalize its siblings.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.DoFadeDetailsGUI">
            <summary>Draws the <see cref="P:Animancer.AnimancerNode.FadeSpeed"/> and <see cref="P:Animancer.AnimancerNode.TargetWeight"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerNodeDrawer`1.DetailsPrefix">
            <summary>
            The menu label prefix used for details about the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.CheckContextMenu(UnityEngine.Rect)">
            <summary>
            Checks if the current event is a context menu click within the `clickArea` and opens a context menu with various
            functions for the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerNodeDrawer`1.PopulateContextMenu(UnityEditor.GenericMenu)">
            <summary>Adds functions relevant to the <see cref="P:Animancer.Editor.AnimancerNodeDrawer`1.Target"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerPlayableDrawer">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="P:Animancer.IAnimancerComponent.Playable"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/AnimancerPlayableDrawer
            
        </member>
        <member name="F:Animancer.Editor.AnimancerPlayableDrawer.LayerInfos">
            <summary>A lazy list of information about the layers currently being displayed.</summary>
        </member>
        <member name="F:Animancer.Editor.AnimancerPlayableDrawer._LayerCount">
            <summary>The number of elements in <see cref="F:Animancer.Editor.AnimancerPlayableDrawer.LayerInfos"/> that are currently being used.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.DoGUI(Animancer.IAnimancerComponent[])">
            <summary>Draws the GUI of the <see cref="P:Animancer.IAnimancerComponent.Playable"/> if there is only one target.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.DoGUI(Animancer.IAnimancerComponent)">
            <summary>Draws the GUI of the <see cref="P:Animancer.IAnimancerComponent.Playable"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.DoNativeAnimatorControllerGUI(Animancer.IAnimancerComponent)">
            <summary>Draws a GUI for the <see cref="P:UnityEngine.Animator.runtimeAnimatorController"/> if there is one.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.GetState(UnityEditor.Animations.ChildAnimatorState[],System.Int32)">
            <summary>Returns the state with the specified <see cref="P:UnityEditor.Animations.AnimatorState.nameHash"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.DoInternalDetailsGUI(Animancer.AnimancerPlayable)">
            <summary>Draws a box describing the internal details of the `playable`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.CheckContextMenu(UnityEngine.Rect,Animancer.AnimancerPlayable)">
            <summary>
            Checks if the current event is a context menu click within the `clickArea` and opens a context menu with various
            functions for the `playable`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.AddRootFunctions(UnityEditor.GenericMenu,Animancer.AnimancerPlayable)">
            <summary>Adds functions for controlling the `playable`.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.AddUpdateModeFunctions(UnityEditor.GenericMenu,Animancer.AnimancerPlayable)">
            <summary>Adds menu functions to set the <see cref="T:UnityEngine.Playables.DirectorUpdateMode"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.AddDisposablesFunctions(UnityEditor.GenericMenu,System.Collections.Generic.List{System.IDisposable})">
            <summary>Adds disabled items for each disposable.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.AddPlayableGraphVisualizerFunction(UnityEditor.GenericMenu,System.String,UnityEngine.Playables.PlayableGraph)">
            <summary>Adds a menu function to open the Playable Graph Visualiser if it exists in the project.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerPlayableDrawer.AddDisplayOptions(UnityEditor.GenericMenu)">
            <summary>Adds functions to the menu for each of the Display Options.</summary>
        </member>
        <member name="T:Animancer.Editor.AnimancerStateDrawer`1">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="T:Animancer.AnimancerState"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/AnimancerStateDrawer_1
            
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.#ctor(`0)">
            <summary>
            Creates a new <see cref="T:Animancer.Editor.AnimancerStateDrawer`1"/> to manage the Inspector GUI for the `target`.
            </summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerStateDrawer`1.RegionStyle">
            <summary>The <see cref="T:UnityEngine.GUIStyle"/> used for the area encompassing this drawer is <c>null</c>.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerStateDrawer`1.IsAssetUsedAsKey">
            <summary>Determines whether the <see cref="P:Animancer.AnimancerState.MainObject"/> field can occupy the whole line.</summary>
        </member>
        <member name="P:Animancer.Editor.AnimancerStateDrawer`1.AutoNormalizeSiblingWeights">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.DoLabelGUI(UnityEngine.Rect)">
            <summary>
            Draws the state's main label: an <see cref="T:UnityEngine.Object"/> field if it has a
            <see cref="P:Animancer.AnimancerState.MainObject"/>, otherwise just a simple text label.
            <para></para>
            Also shows a bar to indicate its progress.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.DoTimeHighlightBarGUI(UnityEngine.Rect,System.Boolean,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>Draws a progress bar to show the animation time.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.HandleLabelClick(UnityEngine.Rect)">
            <summary>Handles Ctrl + Click on the label to CrossFade the animation.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.DoFoldoutGUI(UnityEngine.Rect)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.GetWrappedTime(System.Single@)">
            <summary>
            Gets the current <see cref="P:Animancer.AnimancerState.Time"/>.
            If the state is looping, the value is modulo by the <see cref="P:Animancer.AnimancerState.Length"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.GetWrappedTime(System.Single,System.Single,System.Boolean)">
            <summary>
            Gets the current <see cref="P:Animancer.AnimancerState.Time"/>.
            If the state is looping, the value is modulo by the <see cref="P:Animancer.AnimancerState.Length"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.DoDetailsGUI">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.DoTimeSliderGUI">
            <summary>Draws a slider for controlling the current <see cref="P:Animancer.AnimancerState.Time"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.PopulateContextMenu(UnityEditor.GenericMenu)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.AnimancerStateDrawer`1.AddContextMenuFunctions(UnityEditor.GenericMenu)">
            <summary>Adds the details of this state to the `menu`.</summary>
        </member>
        <member name="T:Animancer.Editor.BaseAnimancerComponentEditor">
            <summary>[Editor-Only] A custom Inspector for <see cref="T:Animancer.IAnimancerComponent"/>s.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/BaseAnimancerComponentEditor
            
        </member>
        <member name="P:Animancer.Editor.BaseAnimancerComponentEditor.Targets">
            <summary><see cref="P:UnityEditor.Editor.targets"/> casted to <see cref="T:Animancer.IAnimancerComponent"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.BaseAnimancerComponentEditor.PlayableDrawer">
            <summary>The drawer for the <see cref="P:Animancer.IAnimancerComponent.Playable"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.OnEnable">
            <summary>Initializes this <see cref="T:UnityEditor.Editor"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.GatherTargets">
            <summary>
            Copies the <see cref="P:UnityEditor.Editor.targets"/> into the <see cref="F:Animancer.Editor.BaseAnimancerComponentEditor._Targets"/> array.
            </summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.OnInspectorGUI">
            <summary>Called by the Unity editor to draw the custom Inspector GUI elements.</summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.RequiresConstantRepaint">
            <summary>
            If we have only one object selected and are in Play Mode, we need to constantly repaint to keep the
            Inspector up to date with the latest details.
            </summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.DoOtherFieldsGUI">
            <summary>Draws the rest of the Inspector fields after the Animator field.</summary>
        </member>
        <member name="M:Animancer.Editor.BaseAnimancerComponentEditor.DoOverridePropertyGUI(System.String,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>[Editor-Only]
            Draws any custom GUI for the `property`.
            The return value indicates whether the GUI should replace the regular call to
            <see cref="M:UnityEditor.EditorGUILayout.PropertyField(UnityEditor.SerializedProperty,UnityEngine.GUIContent,System.Boolean,UnityEngine.GUILayoutOption[])"/> or
            not. True = GUI was drawn, so don't draw the regular GUI. False = Draw the regular GUI.
            </summary>
        </member>
        <member name="T:Animancer.Editor.DummySerializableCallback">
            <summary>
            An object that holds a serialized callback (a <see cref="T:UnityEngine.Events.UnityEvent"/> by default) so that empty ones can be
            drawn in the GUI without allocating array space for them until they actually contain something.
            </summary>
        </member>
        <member name="T:Animancer.Editor.EventSequenceDrawer">
             <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.AnimancerEvent.Sequence"/>.</summary>
             https://kybernetik.com.au/animancer/api/Animancer.Editor/EventSequenceDrawer
            
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.Get(Animancer.AnimancerEvent.Sequence)">
            <summary>Returns a cached <see cref="T:Animancer.Editor.EventSequenceDrawer"/> for the `events`.</summary>
            <remarks>
            The cache uses a <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2"/> so it doesn't prevent the `events`
            from being garbage collected.
            </remarks>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.CalculateHeight(System.Int32)">
            <summary>
            Calculates the number of vertical pixels required to draw the specified `lineCount` using the
            <see cref="P:Animancer.Editor.AnimancerGUI.LineHeight"/> and <see cref="P:Animancer.Editor.AnimancerGUI.StandardSpacing"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.CalculateHeight(Animancer.AnimancerEvent.Sequence)">
            <summary>Calculates the number of vertical pixels required to draw the contents of the `events`.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.CalculateLineCount(Animancer.AnimancerEvent.Sequence)">
            <summary>Calculates the number of lines required to draw the contents of the `events`.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.Draw(UnityEngine.Rect@,Animancer.AnimancerEvent.Sequence,UnityEngine.GUIContent)">
            <summary>Draws the GUI for the `events`.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.GetSummary(Animancer.AnimancerEvent.Sequence)">
            <summary>Returns a summary of the `events`.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.Draw(UnityEngine.Rect@,System.String,Animancer.AnimancerEvent)">
            <summary>Draws the GUI for the `animancerEvent`.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.CalculateHeight(System.MulticastDelegate)">
            <summary>Calculates the number of vertical pixels required to draw the specified <see cref="T:System.Delegate"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.CalculateLineCount(System.MulticastDelegate)">
            <summary>Calculates the number of lines required to draw the specified <see cref="T:System.Delegate"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.DrawInvocationList(UnityEngine.Rect@,System.MulticastDelegate)">
            <summary>Draws the target and name of the specified <see cref="T:System.Delegate"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.EventSequenceDrawer.Draw(UnityEngine.Rect@,System.Delegate)">
            <summary>Draws the target and name of the specified <see cref="T:System.Delegate"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.ParametizedAnimancerStateDrawer`1">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="T:Animancer.AnimancerState"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/ParametizedAnimancerStateDrawer_1
            
        </member>
        <member name="P:Animancer.Editor.ParametizedAnimancerStateDrawer`1.ParameterCount">
            <summary>The number of parameters being managed by the target state.</summary>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">The target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">The target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">The target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by the target state.</summary>
            <exception cref="T:System.NotSupportedException">The target state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.#ctor(`0)">
            <summary>
            Creates a new <see cref="T:Animancer.Editor.ParametizedAnimancerStateDrawer`1"/> to manage the Inspector GUI for the `state`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.ParametizedAnimancerStateDrawer`1.DoDetailsGUI">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.Editor.SerializableEventSequenceDrawer">
            <summary>[Editor-Only] Draws the Inspector GUI for a <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/SerializableEventSequenceDrawer
            
        </member>
        <member name="F:Animancer.Editor.SerializableEventSequenceDrawer.Repaint">
            <summary><see cref="M:Animancer.Editor.AnimancerGUI.RepaintEverything"/></summary>
        </member>
        <member name="M:Animancer.Editor.SerializableEventSequenceDrawer.CanCacheInspectorGUI(UnityEditor.SerializedProperty)">
            <summary>Can't cache because it breaks the <see cref="T:Animancer.Editor.TimelineGUI"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.SerializableEventSequenceDrawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            Calculates the number of vertical pixels the `property` will occupy when it is drawn.
            </summary>
        </member>
        <member name="M:Animancer.Editor.SerializableEventSequenceDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>Draws the GUI for the `property`.</summary>
        </member>
        <member name="M:Animancer.Editor.SerializableEventSequenceDrawer.DoEventGUI(UnityEngine.Rect@,Animancer.Editor.SerializableEventSequenceDrawer.Context,System.Int32,System.Boolean)">
            <summary>Draws the GUI fields for the event at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.SerializableEventSequenceDrawer.DoNameGUI(UnityEngine.Rect@,Animancer.Editor.SerializableEventSequenceDrawer.Context,System.Int32,System.String)">
            <summary>Draws the time field for the event at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.SerializableEventSequenceDrawer.DoTimeGUI(UnityEngine.Rect@,Animancer.Editor.SerializableEventSequenceDrawer.Context,System.Int32,System.Boolean,System.String,System.Single,System.Boolean)">
            <summary>Draws the time field for the event at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.SerializableEventSequenceDrawer.DoTimeGUI(UnityEngine.Rect@,Animancer.Editor.SerializableEventSequenceDrawer.Context,System.Int32,System.Boolean)">
            <summary>Draws the time field for the event at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.SerializableEventSequenceDrawer.SyncEventTimeChange(Animancer.Editor.SerializableEventSequenceDrawer.Context,System.Int32,System.Single)">
            <summary>Updates the <see cref="P:Animancer.AnimancerEvent.Sequence.Serializable.Events"/> to accomodate a changed event time.</summary>
        </member>
        <member name="M:Animancer.Editor.SerializableEventSequenceDrawer.DoCallbackGUI(UnityEngine.Rect@,Animancer.Editor.SerializableEventSequenceDrawer.Context,System.Int32,System.Boolean,System.String)">
            <summary>Draws the GUI fields for the event at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.SerializableEventSequenceDrawer.DoAddRemoveEventButtonGUI(UnityEngine.Rect,Animancer.Editor.SerializableEventSequenceDrawer.Context)">
            <summary>Draws a button to add a new event or remove the selected one.</summary>
        </member>
        <member name="M:Animancer.Editor.SerializableEventSequenceDrawer.AddEvent(Animancer.Editor.SerializableEventSequenceDrawer.Context,System.Single)">
            <summary>Adds an event to the sequence represented by the given `context`.</summary>
        </member>
        <member name="M:Animancer.Editor.SerializableEventSequenceDrawer.RemoveEvent(Animancer.Editor.SerializableEventSequenceDrawer.Context,System.Int32)">
            <summary>Removes the event at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.Editor.SerializableEventSequenceDrawer.SortEvents(Animancer.Editor.SerializableEventSequenceDrawer.Context)">
            <summary>Sorts the events in the `context` according to their times.</summary>
        </member>
        <member name="T:Animancer.Editor.SerializableEventSequenceDrawer.Context">
            <summary>Details of an <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.SerializableEventSequenceDrawer.Context.Property">
            <summary>The main property representing the <see cref="P:Animancer.Editor.SerializableEventSequenceDrawer.Context.Sequence"/> field.</summary>
        </member>
        <member name="P:Animancer.Editor.SerializableEventSequenceDrawer.Context.Sequence">
            <summary>Underlying value of the <see cref="P:Animancer.Editor.SerializableEventSequenceDrawer.Context.Property"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.SerializableEventSequenceDrawer.Context.Times">
            <summary>The property representing the <see cref="F:Animancer.AnimancerEvent.Sequence.Serializable._NormalizedTimes"/> field.</summary>
        </member>
        <member name="F:Animancer.Editor.SerializableEventSequenceDrawer.Context.Names">
            <summary>The property representing the <see cref="F:Animancer.AnimancerEvent.Sequence.Serializable._Names"/> field.</summary>
        </member>
        <member name="F:Animancer.Editor.SerializableEventSequenceDrawer.Context.Callbacks">
            <summary>The property representing the <see cref="F:Animancer.AnimancerEvent.Sequence.Serializable._Callbacks"/> field.</summary>
        </member>
        <member name="P:Animancer.Editor.SerializableEventSequenceDrawer.Context.SelectedEvent">
            <summary>The index of the currently selected event.</summary>
        </member>
        <member name="F:Animancer.Editor.SerializableEventSequenceDrawer.Context.Stack">
            <summary>The stack of active contexts.</summary>
        </member>
        <member name="P:Animancer.Editor.SerializableEventSequenceDrawer.Context.Current">
            <summary>The currently active instance.</summary>
        </member>
        <member name="M:Animancer.Editor.SerializableEventSequenceDrawer.Context.Get(UnityEditor.SerializedProperty)">
            <summary>Adds a new <see cref="T:Animancer.Editor.SerializableEventSequenceDrawer.Context"/> representing the `property` to the stack and returns it.</summary>
        </member>
        <member name="M:Animancer.Editor.SerializableEventSequenceDrawer.Context.SetAsCurrent">
            <summary>Sets this <see cref="T:Animancer.Editor.SerializableEventSequenceDrawer.Context"/> as the <see cref="P:Animancer.Editor.SerializableEventSequenceDrawer.Context.Current"/> and returns it.</summary>
        </member>
        <member name="M:Animancer.Editor.SerializableEventSequenceDrawer.Context.Dispose">
            <summary>[<see cref="T:System.IDisposable"/>] Calls <see cref="M:UnityEditor.SerializedObject.ApplyModifiedProperties"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.SerializableEventSequenceDrawer.Context.TransitionContext">
            <summary>Shorthand for <see cref="P:Animancer.Editor.TransitionDrawer.Context"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.SerializableEventSequenceDrawer.Context.Copy">
            <summary>Creates a copy of this <see cref="T:Animancer.Editor.SerializableEventSequenceDrawer.Context"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.SpriteEditor">
            <summary>[Editor-Only]
            A custom Inspector for <see cref="T:UnityEngine.Sprite"/>s which allows you to directly edit them instead of just showing
            their details like the default one does.
            </summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/SpriteEditor
            
        </member>
        <member name="M:Animancer.Editor.SpriteEditor.OnEnable">
            <summary>Initializes this editor.</summary>
        </member>
        <member name="M:Animancer.Editor.SpriteEditor.OnDisable">
            <summary>Cleans up this editor.</summary>
        </member>
        <member name="P:Animancer.Editor.SpriteEditor.AllSpriteModeMultiple">
            <summary>Are all targets set to <see cref="F:UnityEditor.SpriteImportMode.Multiple"/>?</summary>
        </member>
        <member name="M:Animancer.Editor.SpriteEditor.OnInspectorGUI">
            <summary>Called by the Unity editor to draw the custom Inspector GUI elements.</summary>
        </member>
        <member name="T:Animancer.Editor.SpriteEditor.NormalizedPixelField">
            <summary>
            A wrapper around a <see cref="T:UnityEditor.SerializedProperty"/> to display it using two float fields where one is
            normalized and the other is not.
            </summary>
        </member>
        <member name="F:Animancer.Editor.SpriteEditor.NormalizedPixelField.Property">
            <summary>The target property.</summary>
        </member>
        <member name="F:Animancer.Editor.SpriteEditor.NormalizedPixelField.Label">
            <summary>The label to display next to the property.</summary>
        </member>
        <member name="F:Animancer.Editor.SpriteEditor.NormalizedPixelField.IsNormalized">
            <summary>Is the serialized property value normalized?</summary>
        </member>
        <member name="F:Animancer.Editor.SpriteEditor.NormalizedPixelField.normalizeMultiplier">
            <summary>The multiplier to turn a non-normalized value into a normalized one.</summary>
        </member>
        <member name="M:Animancer.Editor.SpriteEditor.NormalizedPixelField.#ctor(UnityEditor.SerializedProperty,UnityEngine.GUIContent,System.Boolean)">
            <summary>Creates a new <see cref="T:Animancer.Editor.SpriteEditor.NormalizedPixelField"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.SpriteEditor.NormalizedPixelField.DoGroupGUI(UnityEditor.SerializedProperty,UnityEngine.GUIContent,Animancer.Editor.SpriteEditor.NormalizedPixelField[])">
            <summary>Draws a group of <see cref="T:Animancer.Editor.SpriteEditor.NormalizedPixelField"/>s.</summary>
        </member>
        <member name="M:Animancer.Editor.SpriteEditor.NormalizedPixelField.DoTwinFloatFieldGUI(UnityEngine.Rect)">
            <summary>Draws this <see cref="T:Animancer.Editor.SpriteEditor.NormalizedPixelField"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.SpriteEditor.NormalizedPixelFieldAttribute.GetLineCount(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.SpriteEditor.GetInfoString">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.SpriteEditor.RenderStaticPreview(System.String,UnityEngine.Object[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.SpriteEditor.HasPreviewGUI">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.SpriteEditor.OnPreviewGUI(UnityEngine.Rect,UnityEngine.GUIStyle)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.SpriteEditor.InverseLerpUnclamped(System.Single,System.Single,System.Single)">
            <summary>The opposite of <see cref="M:UnityEngine.Mathf.LerpUnclamped(System.Single,System.Single,System.Single)"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.TimelineGUI">
            <summary>[Editor-Only] Draws a GUI box denoting a period of time.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/TimelineGUI
            
        </member>
        <member name="P:Animancer.Editor.TimelineGUI.EventIcon">
            <summary>The icon used for events.</summary>
        </member>
        <member name="P:Animancer.Editor.TimelineGUI.Area">
            <summary>The pixel area in which this <see cref="T:Animancer.Editor.TimelineGUI"/> is drawing.</summary>
        </member>
        <member name="P:Animancer.Editor.TimelineGUI.TickHeight">
            <summary>The height of the time ticks.</summary>
        </member>
        <member name="M:Animancer.Editor.TimelineGUI.SecondsToPixels(System.Single)">
            <summary>Converts a number of seconds to a horizontal pixel position along the ruler.</summary>
            <remarks>The value is rounded to the nearest integer.</remarks>
        </member>
        <member name="M:Animancer.Editor.TimelineGUI.PixelsToSeconds(System.Single)">
            <summary>Converts a horizontal pixel position along the ruler to a number of seconds.</summary>
        </member>
        <member name="M:Animancer.Editor.TimelineGUI.SecondsToNormalized(System.Single)">
            <summary>Converts a number of seconds to a normalized time value.</summary>
        </member>
        <member name="M:Animancer.Editor.TimelineGUI.NormalizedToSeconds(System.Single)">
            <summary>Converts a normalized time value to a number of seconds.</summary>
        </member>
        <member name="P:Animancer.Editor.TimelineGUI.Current">
            <summary>The currently drawing <see cref="T:Animancer.Editor.TimelineGUI"/> (or null if none is drawing).</summary>
        </member>
        <member name="M:Animancer.Editor.TimelineGUI.System#IDisposable#Dispose">
            <summary>Ends the area started by <see cref="M:Animancer.Editor.TimelineGUI.BeginGUI(UnityEngine.Rect)"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TimelineGUI.BeginGUI(UnityEngine.Rect)">
            <summary>
            Sets the `area` in which the ruler will be drawn and draws a <see cref="M:UnityEngine.GUI.Box(UnityEngine.Rect,System.String)"/> there.
            The returned object must have <see cref="M:System.IDisposable.Dispose"/> called on it afterwards.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TimelineGUI.DoGUI(UnityEngine.Rect,Animancer.Editor.SerializableEventSequenceDrawer.Context,System.Single@)">
            <summary>Draws the ruler GUI and handles input events for the specified `context`.</summary>
        </member>
        <member name="M:Animancer.Editor.TimelineGUI.DoGUI(Animancer.Editor.SerializableEventSequenceDrawer.Context,System.Single@)">
            <summary>Draws the ruler GUI and handles input events for the specified `context`.</summary>
        </member>
        <member name="M:Animancer.Editor.TimelineGUI.GetStartTime(System.Single,System.Single,System.Single)">
            <summary>Calculates the start time of the transition (in seconds).</summary>
        </member>
        <member name="M:Animancer.Editor.TimelineGUI.GetFadeOutEnd(System.Single,System.Single,System.Single)">
            <summary>Calculates the end time of the fade out (in seconds).</summary>
        </member>
        <member name="M:Animancer.Editor.TimelineGUI.DoFadeHighlightGUI">
            <summary>Draws a polygon describing the start, end, and fade details.</summary>
        </member>
        <member name="M:Animancer.Editor.TimelineGUI.DoEventsGUI(Animancer.Editor.SerializableEventSequenceDrawer.Context,System.Single@)">
            <summary>Draws the details of the <see cref="F:Animancer.Editor.SerializableEventSequenceDrawer.Context.Callbacks"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TimelineGUI.SnapToFrameRate(Animancer.Editor.SerializableEventSequenceDrawer.Context,System.Single@)">
            <summary>Snaps the `seconds` value to the nearest multiple of the <see cref="P:UnityEngine.AnimationClip.frameRate"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TimelineGUI.DoRulerGUI">
            <summary>Draws ticks and labels for important times throughout the area.</summary>
        </member>
        <member name="T:Animancer.Editor.TransitionDrawer">
            <summary>[Editor-Only] Draws the Inspector GUI for an <see cref="T:Animancer.ITransitionDetailed"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/TransitionDrawer
            
        </member>
        <member name="T:Animancer.Editor.TransitionDrawer.Mode">
            <summary>The visual state of a drawer.</summary>
        </member>
        <member name="F:Animancer.Editor.TransitionDrawer._Mode">
            <summary>The current state of this drawer.</summary>
        </member>
        <member name="F:Animancer.Editor.TransitionDrawer.MainPropertyName">
            <summary>
            If set, the field with this name will be drawn on the header line with the foldout arrow instead of in its
            regular place.
            </summary>
        </member>
        <member name="F:Animancer.Editor.TransitionDrawer.MainPropertyPathSuffix">
            <summary>"." + <see cref="F:Animancer.Editor.TransitionDrawer.MainPropertyName"/> (to avoid creating garbage repeatedly).</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.#ctor">
            <summary>Creates a new <see cref="T:Animancer.Editor.TransitionDrawer"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.#ctor(System.String)">
            <summary>Creates a new <see cref="T:Animancer.Editor.TransitionDrawer"/> and sets the <see cref="F:Animancer.Editor.TransitionDrawer.MainPropertyName"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.GetMainProperty(UnityEditor.SerializedProperty)">
            <summary>Returns the property specified by the <see cref="F:Animancer.Editor.TransitionDrawer.MainPropertyName"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.CanCacheInspectorGUI(UnityEditor.SerializedProperty)">
            <summary>Can't cache because it breaks the <see cref="T:Animancer.Editor.TimelineGUI"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>Returns the number of vertical pixels the `property` will occupy when it is drawn.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>Draws the root `property` GUI and calls <see cref="M:Animancer.Editor.TransitionDrawer.DoChildPropertyGUI(UnityEngine.Rect@,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/> for each of its children.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.InitializeMode(UnityEditor.SerializedProperty)">
            <summary>
            If the <see cref="F:Animancer.Editor.TransitionDrawer._Mode"/> is <see cref="F:Animancer.Editor.TransitionDrawer.Mode.Uninitialized"/>, this method determines how it should start
            based on the number of properties in the `serializedObject`. If the only serialized field is an
            <see cref="T:Animancer.ITransition"/> then it should start expanded.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.DoHeaderGUI(UnityEngine.Rect@,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty,UnityEngine.GUIContent,System.Boolean)">
            <summary>Draws the root property of a transition with an optional main property on the same line.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.DoMainPropertyGUI(UnityEngine.Rect,UnityEngine.Rect@,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty)">
            <summary>Draws the GUI the the target transition's main property.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.DoPreviewButtonGUI(UnityEngine.Rect@,UnityEditor.SerializedProperty,System.Boolean)">
            <summary>Draws a small button using the <see cref="P:Animancer.Editor.TransitionPreviewWindow.Icon"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.DoPreviewButtonGUI(UnityEngine.Rect@,System.Boolean,System.String)">
            <summary>Draws a small button using the <see cref="P:Animancer.Editor.TransitionPreviewWindow.Icon"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionDrawer.PreviewButtonStyle">
            <summary>The style used for the button that opens the <see cref="T:Animancer.Editor.TransitionPreviewWindow"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.DoChildPropertyGUI(UnityEngine.Rect@,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            Draws the `property` GUI in relation to the `rootProperty` which was passed into <see cref="M:Animancer.Editor.TransitionDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)"/>.
            </summary>
        </member>
        <member name="F:Animancer.Editor.TransitionDrawer.NormalizedStartTimeFieldName">
            <summary>The name of the backing field of <c>ClipTransition.NormalizedStartTime</c>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.TryDoStartTimeField(UnityEngine.Rect@,UnityEditor.SerializedProperty,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>
            If the `property` is a "Start Time" field, this method draws it as well as the "End Time" below it and
            returns true.
            </summary>
        </member>
        <member name="P:Animancer.Editor.TransitionDrawer.Context">
            <summary>The current <see cref="T:Animancer.Editor.TransitionDrawer.DrawerContext"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.TransitionDrawer.DrawerContext">
            <summary>Details of an <see cref="T:Animancer.ITransition"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/DrawerContext
            
        </member>
        <member name="P:Animancer.Editor.TransitionDrawer.DrawerContext.Property">
            <summary>The main property representing the <see cref="T:Animancer.ITransition"/> field.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionDrawer.DrawerContext.Transition">
            <summary>The actual transition object rerieved from the <see cref="P:Animancer.Editor.TransitionDrawer.DrawerContext.Property"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionDrawer.DrawerContext.MaximumDuration">
            <summary>The cached value of <see cref="P:Animancer.ITransitionDetailed.MaximumDuration"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.TransitionDrawer.DrawerContext.Stack">
            <summary>The stack of active contexts.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.DrawerContext.Get(UnityEditor.SerializedProperty)">
            <summary>Returns a disposable <see cref="T:Animancer.Editor.TransitionDrawer.DrawerContext"/> representing the specified parameters.</summary>
            <remarks>
            Instances are stored in a <see cref="T:Animancer.LazyStack`1"/> and the current one can be accessed via
            <see cref="P:Animancer.Editor.TransitionDrawer.Context"/>.
            </remarks>
        </member>
        <member name="M:Animancer.Editor.TransitionDrawer.DrawerContext.Dispose">
            <summary>Decrements the <see cref="F:Animancer.Editor.TransitionDrawer.DrawerContext.Stack"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.BoolPref">
            <summary>[Editor-Only]
            A simple wrapper around <see cref="T:UnityEditor.EditorPrefs"/> to get and set a bool.
            <para></para>
            If you are interested in a more comprehensive pref wrapper that supports more types, you should check out
            <see href="https://kybernetik.com.au/inspector-gadgets/docs/other/auto-prefs">Inspector Gadgets - Auto Prefs</see>.
            </summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/BoolPref
            
        </member>
        <member name="F:Animancer.Editor.BoolPref.KeyPrefix">
            <summary>The prefix which is automatically added before the <see cref="F:Animancer.Editor.BoolPref.Key"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.BoolPref.Key">
            <summary>The identifier with which this pref will be saved.</summary>
        </member>
        <member name="F:Animancer.Editor.BoolPref.MenuItem">
            <summary>The label to use when adding a function to toggle this pref to a menu.</summary>
        </member>
        <member name="F:Animancer.Editor.BoolPref.DefaultValue">
            <summary>The starting value to use for this pref if none was previously saved.</summary>
        </member>
        <member name="P:Animancer.Editor.BoolPref.Value">
            <summary>The current value of this pref.</summary>
        </member>
        <member name="M:Animancer.Editor.BoolPref.op_Implicit(Animancer.Editor.BoolPref)~System.Boolean">
            <summary>Returns the current value of the `pref`.</summary>
        </member>
        <member name="M:Animancer.Editor.BoolPref.#ctor(System.String,System.Boolean)">
            <summary>Creates a new <see cref="T:Animancer.Editor.BoolPref"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.BoolPref.#ctor(System.String,System.String,System.Boolean)">
            <summary>Creates a new <see cref="T:Animancer.Editor.BoolPref"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.BoolPref.AddToggleFunction(UnityEditor.GenericMenu)">
            <summary>Adds a menu function to toggle the <see cref="P:Animancer.Editor.BoolPref.Value"/> of this pref.</summary>
        </member>
        <member name="M:Animancer.Editor.BoolPref.ToString">
            <summary>Returns a string containing the <see cref="F:Animancer.Editor.BoolPref.Key"/> and <see cref="P:Animancer.Editor.BoolPref.Value"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.PolymorphicDrawer">
            <summary>[Editor-Only]
            A <see cref="T:UnityEditor.PropertyDrawer"/> for <see cref="T:Animancer.IPolymorphic"/> and <see cref="T:Animancer.PolymorphicAttribute"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.PolymorphicDrawer.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.PolymorphicDrawer.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.Editor.MenuFunctionState">
            <summary>The possible states for a function in a <see cref="T:UnityEditor.GenericMenu"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.MenuFunctionState.Normal">
            <summary>Displayed normally.</summary>
        </member>
        <member name="F:Animancer.Editor.MenuFunctionState.Selected">
            <summary>Has a check mark next to it to show that it is selected.</summary>
        </member>
        <member name="F:Animancer.Editor.MenuFunctionState.Disabled">
            <summary>Greyed out and unusable.</summary>
        </member>
        <member name="T:Animancer.Editor.Serialization">
            <summary>[Editor-Only] Various serialization utilities.</summary>
            <summary>[Editor-Only] Various serialization utilities.</summary>
            <summary>[Editor-Only] Various serialization utilities.</summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.ArrayDataPrefix">
            <summary>The text used in a <see cref="P:UnityEditor.SerializedProperty.propertyPath"/> to denote array elements.</summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.ArrayDataSuffix">
            <summary>The text used in a <see cref="P:UnityEditor.SerializedProperty.propertyPath"/> to denote array elements.</summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.InstanceBindings">
            <summary>Bindings for Public and Non-Public Instance members.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetFriendlyPath(UnityEditor.SerializedProperty)">
            <summary>Returns a user friendly version of the <see cref="P:UnityEditor.SerializedProperty.propertyPath"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetValue(UnityEditor.SerializedProperty,System.Object)">
            <summary>Gets the value of the specified <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetValue(UnityEditor.SerializedProperty)">
            <summary>Gets the value of the <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetValue``1(UnityEditor.SerializedProperty)">
            <summary>Gets the value of the <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetValue``1(UnityEditor.SerializedProperty,``0@)">
            <summary>Gets the value of the <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetValues``1(UnityEditor.SerializedProperty)">
            <summary>Gets the value of the <see cref="T:UnityEditor.SerializedProperty"/> for each of its target objects.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.IsDefaultValueByType(UnityEditor.SerializedProperty)">
            <summary>Is the value of the `property` the same as the default serialized value for its type?</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.SetValue(UnityEditor.SerializedProperty,System.Object,System.Object)">
            <summary>Sets the value of the specified <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.SetValue(UnityEditor.SerializedProperty,System.Object)">
            <summary>Sets the value of the <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ResetValue(UnityEditor.SerializedProperty,System.String)">
            <summary>
            Resets the value of the <see cref="T:UnityEditor.SerializedProperty"/> to the default value of its type and all its field
            types, ignoring values set by constructors or field initializers.
            </summary>
            <remarks>
            If you want to run constructors and field initializers, you can call
            <see cref="M:Animancer.Editor.Serialization.PropertyAccessor.ResetValue(UnityEditor.SerializedProperty,System.String)"/> instead.
            </remarks>
        </member>
        <member name="M:Animancer.Editor.Serialization.CopyValueFrom(UnityEditor.SerializedProperty,UnityEditor.SerializedProperty)">
            <summary>Copies the value of `from` into `to` (including all nested properties).</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.GradientValue">
            <summary><c>SerializedProperty.gradientValue</c> is internal.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetGradientValue(UnityEditor.SerializedProperty)">
            <summary>Gets the <see cref="T:UnityEngine.Gradient"/> value from a <see cref="F:UnityEditor.SerializedPropertyType.Gradient"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.SetGradientValue(UnityEditor.SerializedProperty,UnityEngine.Gradient)">
            <summary>Sets the <see cref="T:UnityEngine.Gradient"/> value on a <see cref="F:UnityEditor.SerializedPropertyType.Gradient"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.AreSameProperty(UnityEditor.SerializedProperty,UnityEditor.SerializedProperty)">
            <summary>Indicates whether both properties refer to the same underlying field.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ForEachTarget(UnityEditor.SerializedProperty,System.Action{UnityEditor.SerializedProperty},System.String)">
            <summary>
            Executes the `action` once with a new <see cref="T:UnityEditor.SerializedProperty"/> for each of the
            <see cref="P:UnityEditor.SerializedObject.targetObjects"/>. Or if there is only one target, it uses the `property`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.AddFunction(UnityEditor.GenericMenu,System.String,Animancer.Editor.MenuFunctionState,UnityEditor.GenericMenu.MenuFunction)">
            <summary>
            Adds a menu item to execute the specified `function` for each of the `property`s target objects.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.AddFunction(UnityEditor.GenericMenu,System.String,System.Boolean,UnityEditor.GenericMenu.MenuFunction)">
            <summary>
            Adds a menu item to execute the specified `function` for each of the `property`s target objects.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.AddPropertyModifierFunction(UnityEditor.GenericMenu,UnityEditor.SerializedProperty,System.String,Animancer.Editor.MenuFunctionState,System.Action{UnityEditor.SerializedProperty})">
            <summary>Adds a menu item to execute the specified `function` for each of the `property`s target objects.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.AddPropertyModifierFunction(UnityEditor.GenericMenu,UnityEditor.SerializedProperty,System.String,System.Boolean,System.Action{UnityEditor.SerializedProperty})">
            <summary>Adds a menu item to execute the specified `function` for each of the `property`s target objects.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.AddPropertyModifierFunction(UnityEditor.GenericMenu,UnityEditor.SerializedProperty,System.String,System.Action{UnityEditor.SerializedProperty})">
            <summary>Adds a menu item to execute the specified `function` for each of the `property`s target objects.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ModifyValues``1(UnityEditor.SerializedProperty,System.Action{``0},System.String)">
            <summary>
            Calls the specified `method` for each of the underlying values of the `property` (in case it represents
            multiple selected objects) and records an undo step for any modifications made.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.RecordUndo(UnityEditor.SerializedProperty,System.String)">
            <summary>
            Records the state of the specified `property` so it can be undone.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.OnPropertyChanged(UnityEditor.SerializedProperty)">
            <summary>
            Updates the specified `property` and marks its target objects as dirty so any changes to a prefab will be saved.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetPropertyType(System.Type)">
            <summary>
            Returns the <see cref="T:UnityEditor.SerializedPropertyType"/> that represents fields of the specified `type`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.RemoveArrayElement(UnityEditor.SerializedProperty,System.Int32)">
            <summary>Removes the specified array element from the `property`.</summary>
            <remarks>
            If the element is not at its default value, the first call to
            <see cref="M:UnityEditor.SerializedProperty.DeleteArrayElementAtIndex(System.Int32)"/> will only reset it, so this method will
            call it again if necessary to ensure that it actually gets removed.
            </remarks>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetAccessor(UnityEditor.SerializedProperty)">
            <summary>
            Returns an <see cref="T:Animancer.Editor.Serialization.PropertyAccessor"/> that can be used to access the details of the specified `property`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetAccessor(UnityEditor.SerializedProperty,System.String,System.Type@)">
            <summary>
            Returns an <see cref="T:Animancer.Editor.Serialization.PropertyAccessor"/> for a <see cref="T:UnityEditor.SerializedProperty"/> with the specified `propertyPath`
            on the specified `type` of object.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetField(Animancer.Editor.Serialization.PropertyAccessor,UnityEditor.SerializedProperty,System.Type,System.String)">
            <summary>Returns a field with the specified `name` in the `declaringType` or any of its base types.</summary>
            <remarks>Uses the <see cref="F:Animancer.Editor.Serialization.InstanceBindings"/>.</remarks>
        </member>
        <member name="M:Animancer.Editor.Serialization.GetField(System.Type,System.String)">
            <summary>Returns a field with the specified `name` in the `declaringType` or any of its base types.</summary>
            <remarks>Uses the <see cref="F:Animancer.Editor.Serialization.InstanceBindings"/>.</remarks>
        </member>
        <member name="T:Animancer.Editor.Serialization.PropertyAccessor">
            <summary>[Editor-Only]
            A wrapper for accessing the underlying values and fields of a <see cref="T:UnityEditor.SerializedProperty"/>.
            </summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.PropertyAccessor.Parent">
            <summary>The accessor for the field which this accessor is nested inside.</summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.PropertyAccessor.Name">
            <summary>The name of the field wrapped by this accessor.</summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.PropertyAccessor.Field">
            <summary>The field wrapped by this accessor.</summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.PropertyAccessor.FieldElementType">
            <summary>
            The type of the wrapped <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            Or if it's a collection, this is the type of items in the collection.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.#ctor(Animancer.Editor.Serialization.PropertyAccessor,System.String,System.Reflection.FieldInfo)">
            <summary>[Internal] Creates a new <see cref="T:Animancer.Editor.Serialization.PropertyAccessor"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.#ctor(Animancer.Editor.Serialization.PropertyAccessor,System.String,System.Reflection.FieldInfo,System.Type)">
            <summary>Creates a new <see cref="T:Animancer.Editor.Serialization.PropertyAccessor"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetField(System.Object@)">
            <summary>Returns the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/> if there is one or tries to get it from the object's type.</summary>
            
            <remarks>
            If this accessor has a <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/>, the `obj` must be associated with the root
            <see cref="T:UnityEditor.SerializedProperty"/> and this method will change it to reference the parent field's value.
            </remarks>
            
            <example><code>
            [Serializable]
            public class InnerClass
            {
                public float value;
            }
            
            [Serializable]
            public class RootClass
            {
                public InnerClass inner;
            }
            
            public class MyBehaviour : MonoBehaviour
            {
                public RootClass root;
            }
            
            [UnityEditor.CustomEditor(typeof(MyBehaviour))]
            public class MyEditor : UnityEditor.Editor
            {
                private void OnEnable()
                {
                    var serializedObject = new SerializedObject(target);
                    var rootProperty = serializedObject.FindProperty("root");
                    var innerProperty = rootProperty.FindPropertyRelative("inner");
                    var valueProperty = innerProperty.FindPropertyRelative("value");
            
                    var accessor = valueProperty.GetAccessor();
            
                    object obj = target;
                    var valueField = accessor.GetField(ref obj);
                    // valueField is a FieldInfo referring to InnerClass.value.
                    // obj now holds the ((MyBehaviour)target).root.inner.
                }
            }
            </code></example>
            
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetField(System.Object)">
            <summary>
            Returns the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/> if there is one, otherwise calls <see cref="M:Animancer.Editor.Serialization.PropertyAccessor.GetField(System.Object@)"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetField(UnityEditor.SerializedObject)">
            <summary>
            Calls <see cref="M:Animancer.Editor.Serialization.PropertyAccessor.GetField(System.Object)"/> with the <see cref="P:UnityEditor.SerializedObject.targetObject"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetField(UnityEditor.SerializedProperty)">
            <summary>
            Calls <see cref="M:Animancer.Editor.Serialization.PropertyAccessor.GetField(UnityEditor.SerializedObject)"/> with the
            <see cref="P:UnityEditor.SerializedProperty.serializedObject"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetFieldElementType(System.Object)">
            <summary>
            Returns the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.FieldElementType"/> if there is one, otherwise calls <see cref="M:Animancer.Editor.Serialization.PropertyAccessor.GetField(System.Object@)"/>
            and returns its <see cref="P:System.Reflection.FieldInfo.FieldType"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetFieldElementType(UnityEditor.SerializedObject)">
            <summary>
            Calls <see cref="M:Animancer.Editor.Serialization.PropertyAccessor.GetFieldElementType(System.Object)"/> with the
            <see cref="P:UnityEditor.SerializedObject.targetObject"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetFieldElementType(UnityEditor.SerializedProperty)">
            <summary>
            Calls <see cref="M:Animancer.Editor.Serialization.PropertyAccessor.GetFieldElementType(UnityEditor.SerializedObject)"/> with the
            <see cref="P:UnityEditor.SerializedProperty.serializedObject"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetValue(System.Object)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to get and return
            the value of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetValue(UnityEditor.SerializedObject)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to get and return
            the value of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetValue(UnityEditor.SerializedProperty)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to get and return
            the value of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.SetValue(System.Object,System.Object)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to set the value
            of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.SetValue(UnityEditor.SerializedObject,System.Object)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to set the value
            of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.SetValue(UnityEditor.SerializedProperty,System.Object)">
            <summary>
            Gets the value of the from the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Parent"/> (if there is one), then uses it to set the value
            of the <see cref="F:Animancer.Editor.Serialization.PropertyAccessor.Field"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.ResetValue(UnityEditor.SerializedProperty,System.String)">
            <summary>
            Resets the value of the <see cref="T:UnityEditor.SerializedProperty"/> to the default value of its type by executing
            its constructor and field initializers.
            </summary>
            <remarks>
            If you don't want to run constructors and field initializers, you can call
            <see cref="M:Animancer.Editor.Serialization.ResetValue(UnityEditor.SerializedProperty,System.String)"/> instead.
            </remarks>
            <example><code>
            SerializedProperty property;
            property.GetAccessor().ResetValue(property);
            </code></example>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.ToString">
            <summary>Returns a description of this accessor's path.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyAccessor.GetPath">
            <summary>Returns a this accessor's <see cref="P:UnityEditor.SerializedProperty.propertyPath"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.Serialization.CollectionPropertyAccessor">
            <summary>[Editor-Only] A <see cref="T:Animancer.Editor.Serialization.PropertyAccessor"/> for a specific element index in a collection.</summary>
        </member>
        <member name="F:Animancer.Editor.Serialization.CollectionPropertyAccessor.ElementIndex">
            <summary>The index of the array element this accessor targets.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.CollectionPropertyAccessor.#ctor(Animancer.Editor.Serialization.PropertyAccessor,System.String,System.Reflection.FieldInfo,System.Int32)">
            <summary>[Internal] Creates a new <see cref="T:Animancer.Editor.Serialization.CollectionPropertyAccessor"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.CollectionPropertyAccessor.GetFieldElementType(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Serialization.CollectionPropertyAccessor.GetElementType(System.Type)">
            <summary>Returns the type of elements in the array.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.CollectionPropertyAccessor.GetCollection(System.Object)">
            <summary>Returns the collection object targeted by this accessor.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.CollectionPropertyAccessor.GetValue(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Serialization.CollectionPropertyAccessor.SetCollection(System.Object,System.Object)">
            <summary>Sets the collection object targeted by this accessor.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.CollectionPropertyAccessor.SetValue(System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.Serialization.CollectionPropertyAccessor.ToString">
            <summary>Returns a description of this accessor's path.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.CollectionPropertyAccessor.GetCollectionPath">
            <summary>Returns the <see cref="P:UnityEditor.SerializedProperty.propertyPath"/> of the array containing the target.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.CollectionPropertyAccessor.GetPath">
            <summary>Returns this accessor's <see cref="P:UnityEditor.SerializedProperty.propertyPath"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.Serialization.ObjectReference">
            <summary>[Editor-Only]
            Directly serializing an <see cref="T:UnityEngine.Object"/> reference doesn't always work (such as with scene
            objects when entering Play Mode), so this class also serializes their instance ID and uses that if the direct
            reference fails.
            </summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.ObjectReference.Object">
            <summary>The referenced <see cref="T:UnityEditor.SerializedObject"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.ObjectReference.InstanceID">
            <summary>The <see cref="M:UnityEngine.Object.GetInstanceID"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.#ctor(UnityEngine.Object)">
            <summary>
            Creates a new <see cref="T:Animancer.Editor.Serialization.ObjectReference"/> which wraps the specified
            <see cref="T:UnityEngine.Object"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.op_Implicit(UnityEngine.Object)~Animancer.Editor.Serialization.ObjectReference">
            <summary>
            Creates a new <see cref="T:Animancer.Editor.Serialization.ObjectReference"/> which wraps the specified
            <see cref="T:UnityEngine.Object"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.op_Implicit(Animancer.Editor.Serialization.ObjectReference)~UnityEngine.Object">
            <summary>Returns the target <see cref="P:Animancer.Editor.Serialization.ObjectReference.Object"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.Convert(UnityEngine.Object[])">
            <summary>Creates a new array of <see cref="T:Animancer.Editor.Serialization.ObjectReference"/>s representing the `objects`.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.Convert(Animancer.Editor.Serialization.ObjectReference[])">
            <summary>
            Creates a new array of <see cref="T:UnityEngine.Object"/>s containing the target <see cref="P:Animancer.Editor.Serialization.ObjectReference.Object"/> of each
            of the `references`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.AreSameObjects(Animancer.Editor.Serialization.ObjectReference[],UnityEngine.Object[])">
            <summary>Indicates whether both arrays refer to the same set of objects.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.ObjectReference.ToString">
            <summary>Returns a string describing this object.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.IsValid(Animancer.Editor.Serialization.ObjectReference)">
            <summary>Returns true if the `reference` and <see cref="P:Animancer.Editor.Serialization.ObjectReference.Object"/> are not null.</summary>
        </member>
        <member name="T:Animancer.Editor.Serialization.PropertyReference">
            <summary>[Editor-Only] A serializable reference to a <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.TargetObject">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The <see cref="P:UnityEditor.SerializedObject.targetObject"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.TargetObjects">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The <see cref="P:UnityEditor.SerializedObject.targetObjects"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.Context">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The <see cref="P:UnityEditor.SerializedObject.context"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.PropertyPath">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The <see cref="P:UnityEditor.SerializedProperty.propertyPath"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.IsInitialized">
            <summary>Indicates whether the <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/> has been accessed.</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.Property">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The referenced <see cref="T:UnityEditor.SerializedProperty"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.#ctor(UnityEditor.SerializedProperty)">
            <summary>
            Creates a new <see cref="T:Animancer.Editor.Serialization.PropertyReference"/> which wraps the specified `property`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.op_Implicit(UnityEditor.SerializedProperty)~Animancer.Editor.Serialization.PropertyReference">
            <summary>
            Creates a new <see cref="T:Animancer.Editor.Serialization.PropertyReference"/> which wraps the specified `property`.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.op_Implicit(Animancer.Editor.Serialization.PropertyReference)~UnityEditor.SerializedProperty">
            <summary>
            Returns the target <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.IsTarget(UnityEditor.SerializedProperty,UnityEngine.Object[])">
            <summary>Do the specified `property` and `targetObjects` match the targets of this reference?</summary>
        </member>
        <member name="P:Animancer.Editor.Serialization.PropertyReference.TargetsExist">
            <summary>Is there is at least one target and none of them are <c>null</c>?</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.Update">
            <summary>
            Calls <see cref="M:UnityEditor.SerializedObject.Update"/> if the <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/> has been initialized.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.ApplyModifiedProperties">
            <summary>
            Calls <see cref="M:UnityEditor.SerializedObject.ApplyModifiedProperties"/> if the <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/> has been initialized.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.Dispose">
            <summary>
            Calls <see cref="M:UnityEditor.SerializedObject.Dispose"/> if the <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/> has been initialized.
            </summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.GetPropertyHeight">
            <summary>Gets the height needed to draw the target property.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.DoTargetGUI(UnityEngine.Rect)">
            <summary>Draws the target object within the specified `area`.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.PropertyReference.DoPropertyGUI(UnityEngine.Rect)">
            <summary>Draws the target property within the specified `area`.</summary>
        </member>
        <member name="M:Animancer.Editor.Serialization.IsValid(Animancer.Editor.Serialization.PropertyReference)">
            <summary>Returns true if the `reference` and <see cref="P:Animancer.Editor.Serialization.PropertyReference.Property"/> are not null.</summary>
        </member>
        <member name="T:Animancer.Editor.SerializedArrayProperty">
            <summary>[Editor-Only] A wrapper around a <see cref="T:UnityEditor.SerializedProperty"/> representing an array field.</summary>
        </member>
        <member name="P:Animancer.Editor.SerializedArrayProperty.Property">
            <summary>The target property.</summary>
        </member>
        <member name="P:Animancer.Editor.SerializedArrayProperty.Path">
            <summary>The cached <see cref="P:UnityEditor.SerializedProperty.propertyPath"/> of the <see cref="P:Animancer.Editor.SerializedArrayProperty.Property"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.SerializedArrayProperty.Count">
            <summary>The cached <see cref="P:UnityEditor.SerializedProperty.arraySize"/> of the <see cref="P:Animancer.Editor.SerializedArrayProperty.Property"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.SerializedArrayProperty.HasMultipleDifferentValues">
            <summary>The cached <see cref="P:UnityEditor.SerializedProperty.hasMultipleDifferentValues"/> of the <see cref="P:Animancer.Editor.SerializedArrayProperty.Property"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.SerializedArrayProperty.Refresh">
            <summary>Updates the cached <see cref="P:Animancer.Editor.SerializedArrayProperty.Count"/> and <see cref="P:Animancer.Editor.SerializedArrayProperty.HasMultipleDifferentValues"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.SerializedArrayProperty.GetElement(System.Int32)">
            <summary>Calls <see cref="M:UnityEditor.SerializedProperty.GetArrayElementAtIndex(System.Int32)"/> on the <see cref="P:Animancer.Editor.SerializedArrayProperty.Property"/>.</summary>
            <remarks>
            Returns <c>null</c> if the element is not actually a child of the <see cref="P:Animancer.Editor.SerializedArrayProperty.Property"/>, which can happen
            if multiple objects are selected with different array sizes.
            </remarks>
        </member>
        <member name="T:Animancer.Editor.TemporarySettings">
            <summary>[Editor-Only]
            Stores data which needs to survive assembly reloading (such as from script compilation), but can be discarded
            when the Unity Editor is closed.
            </summary>
        </member>
        <member name="P:Animancer.Editor.TemporarySettings.Instance">
            <summary>Finds an existing instance of this class or creates a new one.</summary>
        </member>
        <member name="T:Animancer.Editor.TypeSelectionButton">
            <summary>[Editor-Only]
            A button that allows the user to select an object type for a [<see cref="T:UnityEngine.SerializeReference"/>] field.</summary>
            <example><code>
            public override void OnGUI(Rect area, SerializedProperty property, GUIContent label)
            {
                using (new TypeSelectionButton(area, property, label, true))
                {
                    EditorGUI.PropertyField(area, property, label, true);
                }
            }
            </code></example>
        </member>
        <member name="F:Animancer.Editor.TypeSelectionButton.Area">
            <summary>The pixel area occupied by the button.</summary>
        </member>
        <member name="F:Animancer.Editor.TypeSelectionButton.Property">
            <summary>The <see cref="T:UnityEditor.SerializedProperty"/> representing the attributed field.</summary>
        </member>
        <member name="F:Animancer.Editor.TypeSelectionButton.EventType">
            <summary>The original <see cref="P:UnityEngine.Event.type"/> from when this button was initialized.</summary>
        </member>
        <member name="M:Animancer.Editor.TypeSelectionButton.#ctor(UnityEngine.Rect,UnityEditor.SerializedProperty,System.Boolean)">
            <summary>Creates a new <see cref="T:Animancer.Editor.TypeSelectionButton"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TypeSelectionButton.DoGUI">
            <summary>Draws this button's GUI.</summary>
            <remarks>Run this method after drawing the target property so the button draws on top of its label.</remarks>
        </member>
        <member name="M:Animancer.Editor.TypeSelectionButton.ShowTypeSelectorMenu(UnityEditor.SerializedProperty)">
            <summary>Shows a menu to select which type of object to assign to the `property`.</summary>
        </member>
        <member name="M:Animancer.Editor.TypeSelectionButton.AddTypeSelector(UnityEditor.GenericMenu,UnityEditor.SerializedProperty,System.Type,System.Type,System.Type)">
            <summary>Adds a menu function to assign a new instance of the `newType` to the `property`.</summary>
        </member>
        <member name="M:Animancer.Editor.TypeSelectionButton.GetDerivedTypes(System.Type)">
            <summary>Returns a list of all types that inherit from the `baseType`.</summary>
        </member>
        <member name="M:Animancer.Editor.TypeSelectionButton.IsViableType(System.Type)">
            <summary>Is the `type` supported by <see cref="T:UnityEngine.SerializeReference"/> fields?</summary>
        </member>
        <member name="M:Animancer.Editor.TypeSelectionButton.CreateDefaultInstance(System.Type)">
            <summary>
            Creates a new instance of the `type` using its parameterless constructor if it has one or a fully
            uninitialized object if it doesn't. Or returns <c>null</c> if the <see cref="P:System.Type.IsAbstract"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TypeSelectionButton.CreateDefaultInstance``1">
            <summary>
            Creates a <typeparamref name="T"/> using its parameterless constructor if it has one or a fully
            uninitialized object if it doesn't. Or returns <c>null</c> if the <see cref="P:System.Type.IsAbstract"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TypeSelectionButton.CopyCommonFields(System.Object,System.Object)">
            <summary>
            Copies the values of all fields in `from` into corresponding fields in `to` as long as they have the same
            name and compatible types.
            </summary>
        </member>
        <member name="T:Animancer.Editor.AnimationClipPreview">
            <summary>[Editor-Only] A minimal <see cref="T:Animancer.ITransitionDetailed"/> to preview an <see cref="T:UnityEngine.AnimationClip"/>.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions#previews">Previews</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/AnimationClipPreview
            
        </member>
        <member name="T:Animancer.Editor.TransitionPreviewWindow">
            https://kybernetik.com.au/animancer/api/Animancer.Editor/TransitionPreviewWindow
            <summary>[Editor-Only]
            An <see cref="T:UnityEditor.EditorWindow"/> which allows the user to preview animation transitions separately from the rest
            of the scene in Edit Mode or Play Mode.
            </summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions#previews">Previews</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/TransitionPreviewWindow
            
            https://kybernetik.com.au/animancer/api/Animancer.Editor/TransitionPreviewWindow
            https://kybernetik.com.au/animancer/api/Animancer.Editor/TransitionPreviewWindow
            https://kybernetik.com.au/animancer/api/Animancer.Editor/TransitionPreviewWindow
        </member>
        <member name="T:Animancer.Editor.TransitionPreviewWindow.Animations">
            <summary>Animation details for the <see cref="T:Animancer.Editor.TransitionPreviewWindow"/>.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions#previews">Previews</see>
            </remarks>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewWindow.Icon">
            <summary>The icon image used by this window.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.OpenOrClose(UnityEditor.SerializedProperty)">
            <summary>
            Focusses the <see cref="T:Animancer.Editor.TransitionPreviewWindow"/> or creates one if none exists.
            Or closes the existing window if it was already previewing the `transitionProperty`.
            </summary>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewWindow.PreviewNormalizedTime">
            <summary>
            The <see cref="P:Animancer.AnimancerState.NormalizedTime"/> of the current transition. Can only be set if the property
            being previewed matches the current <see cref="P:Animancer.Editor.TransitionDrawer.Context"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.GetCurrentState">
            <summary>
            Returns the <see cref="T:Animancer.AnimancerState"/> of the current transition if the property being previewed matches
            the <see cref="P:Animancer.Editor.TransitionDrawer.Context"/>. Otherwise returns null.
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.IsPreviewingCurrentProperty">
            <summary>
            Is the current <see cref="P:Animancer.Editor.TransitionDrawer.DrawerContext.Property"/> being previewed at the moment?
            </summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.IsPreviewing(UnityEditor.SerializedProperty)">
            <summary>Is the `property` being previewed at the moment?</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.OnEnable">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.OnDisable">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.OnDestroy">
            <summary>Cleans up this window.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.OnSceneGUI">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.Update">
            <summary>Called multiple times per second while this window is visible.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.SupportsStageHandling">
            <summary>Returns false.</summary>
            <remarks>Returning true makes it draw the main scene instead of the custom scene in Unity 2020.</remarks>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewWindow.TransitionProperty">
            <summary>The <see cref="T:UnityEditor.SerializedProperty"/> currently being previewed.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewWindow.Transition">
            <summary>The <see cref="T:Animancer.ITransitionDetailed"/> currently being previewed.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.CanBePreviewed(UnityEditor.SerializedProperty)">
            <summary>Indicates whether the `property` is able to be previewed by this system.</summary>
        </member>
        <member name="T:Animancer.Editor.TransitionPreviewWindow.Inspector">
            <summary>[Internal] Custom Inspector for the <see cref="T:Animancer.Editor.TransitionPreviewWindow"/>.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions#previews">Previews</see>
            </remarks>
        </member>
        <member name="F:Animancer.Editor.TransitionPreviewWindow.Inspector.CloseTooltip">
            <summary>The tooltip used for the Close button.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.Inspector.DoTransitionPropertyGUI">
            <summary>Draws the target object and path of the <see cref="P:Animancer.Editor.TransitionPreviewWindow.TransitionProperty"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewWindow.InstanceScene">
            <summary>The <see cref="T:Animancer.Editor.TransitionPreviewWindow.Scene"/> of the current <see cref="T:Animancer.Editor.TransitionPreviewWindow"/> instance.</summary>
        </member>
        <member name="T:Animancer.Editor.TransitionPreviewWindow.Scene">
            <summary>Temporary scene management for the <see cref="T:Animancer.Editor.TransitionPreviewWindow"/>.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions#previews">Previews</see>
            </remarks>
        </member>
        <member name="F:Animancer.Editor.TransitionPreviewWindow.Scene.HideAndDontSave">
            <summary><see cref="F:UnityEngine.HideFlags.HideAndDontSave"/> without <see cref="F:UnityEngine.HideFlags.NotEditable"/>.</summary>
        </member>
        <member name="F:Animancer.Editor.TransitionPreviewWindow.Scene._Scene">
            <summary>The scene displayed by the <see cref="T:Animancer.Editor.TransitionPreviewWindow"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewWindow.Scene.PreviewSceneRoot">
            <summary>The root object in the preview scene.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewWindow.Scene.InstanceRoot">
            <summary>The root of the model in the preview scene. A child of the <see cref="P:Animancer.Editor.TransitionPreviewWindow.Scene.PreviewSceneRoot"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewWindow.Scene.EnvironmentInstance">
            <summary>
            An instance of the <see cref="P:Animancer.Editor.TransitionPreviewWindow.Settings.SceneEnvironment"/>.
            A child of the <see cref="P:Animancer.Editor.TransitionPreviewWindow.Scene.PreviewSceneRoot"/>.
            </summary>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewWindow.Scene.OriginalRoot">
            <summary>The original model which was instantiated to create the <see cref="P:Animancer.Editor.TransitionPreviewWindow.Scene.InstanceRoot"/>.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewWindow.Scene.InstanceAnimators">
            <summary>The <see cref="T:UnityEngine.Animator"/> components attached to the <see cref="P:Animancer.Editor.TransitionPreviewWindow.Scene.InstanceRoot"/> and its children.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewWindow.Scene.SelectedInstanceAnimator">
            <summary>The <see cref="T:UnityEngine.Animator"/> component currently being used for the preview.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewWindow.Scene.Animancer">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> being used for the preview.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.Scene.OnEnable">
            <summary>Initializes this <see cref="T:Animancer.Editor.TransitionPreviewWindow.Scene"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.Scene.DisableUnnecessaryComponents(UnityEngine.GameObject)">
            <summary>Disables all unnecessary components on the `root` or its children.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.Scene.SetSelectedAnimator(System.Int32)">
            <summary>Sets the <see cref="P:Animancer.Editor.TransitionPreviewWindow.Scene.SelectedInstanceAnimator"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.Scene.OnTargetPropertyChanged">
            <summary>Called when the target transition property is changed.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.Scene.OnGUI">
            <summary>Called when the window GUI is drawn.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.Scene.IsSceneObject(UnityEngine.Object)">
            <summary>Is the `obj` a <see cref="T:UnityEngine.GameObject"/> in the preview scene?</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewWindow.Scene.ExpandedHierarchy">
            <summary>A list of all objects with their child hierarchy expanded.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.Scene.OnDisable">
            <summary>Called by <see cref="M:Animancer.Editor.TransitionPreviewWindow.OnDisable"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.Scene.OnDestroy">
            <summary>Called by <see cref="M:Animancer.Editor.TransitionPreviewWindow.OnDestroy"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.Scene.DestroyModelInstance">
            <summary>Destroys the <see cref="P:Animancer.Editor.TransitionPreviewWindow.Scene.InstanceRoot"/>.</summary>
        </member>
        <member name="T:Animancer.Editor.TransitionPreviewWindow.Settings">
            <summary>Persistent settings for the <see cref="T:Animancer.Editor.TransitionPreviewWindow"/>.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions#previews">Previews</see>
            </remarks>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewWindow.Settings.Models">
            <summary>The models previously used in the <see cref="T:Animancer.Editor.TransitionPreviewWindow"/>.</summary>
            <remarks>Accessing this property removes missing and duplicate models from the list.</remarks>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewWindow.Settings.TrySelectBestModel">
            <summary>
            Tries to choose the most appropriate model to use based on the properties animated by the target
            <see cref="P:Animancer.Editor.TransitionPreviewWindow.Transition"/>.
            </summary>
        </member>
        <member name="T:Animancer.Editor.ITransitionGUI">
            <summary>[Editor-Only] An object that can draw custom GUI elements relating to transitions.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/ITransitionGUI
            
        </member>
        <member name="M:Animancer.Editor.ITransitionGUI.OnPreviewSceneGUI(Animancer.Editor.TransitionPreviewDetails)">
            <summary>Called while drawing the GUI for the <see cref="T:Animancer.Editor.TransitionPreviewWindow"/> scene.</summary>
        </member>
        <member name="M:Animancer.Editor.ITransitionGUI.OnTimelineBackgroundGUI">
            <summary>
            Called while drawing the background GUI for the <see cref="T:Animancer.Editor.TimelineGUI"/> for the
            <see cref="P:Animancer.IHasEvents.Events"/>.
            </summary>
        </member>
        <member name="M:Animancer.Editor.ITransitionGUI.OnTimelineForegroundGUI">
            <summary>
            Called while drawing the foreground GUI for the <see cref="T:Animancer.Editor.TimelineGUI"/> for the
            <see cref="P:Animancer.IHasEvents.Events"/>.
            </summary>
        </member>
        <member name="T:Animancer.Editor.TransitionPreviewDetails">
            <summary>[Editor-Only] Details about the current preview used by <see cref="M:Animancer.Editor.ITransitionGUI.OnPreviewSceneGUI(Animancer.Editor.TransitionPreviewDetails)"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Editor/TransitionPreviewDetails
            
        </member>
        <member name="F:Animancer.Editor.TransitionPreviewDetails.Animancer">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> used to play the preview.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewDetails.Transform">
            <summary>The <see cref="T:UnityEngine.Transform"/> of the <see cref="T:UnityEngine.Animator"/> used to play the preview.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewDetails.Property">
            <summary>The <see cref="T:UnityEditor.SerializedProperty"/> representing the target transition.</summary>
        </member>
        <member name="P:Animancer.Editor.TransitionPreviewDetails.Transition">
            <summary>The current <see cref="T:Animancer.ITransitionDetailed"/>.</summary>
        </member>
        <member name="M:Animancer.Editor.TransitionPreviewDetails.#ctor(Animancer.AnimancerPlayable)">
            <summary>Creates a new <see cref="T:Animancer.Editor.TransitionPreviewDetails"/>.</summary>
        </member>
        <member name="T:Animancer.AnimancerLayer">
             <summary>
             A layer on which animations can play with their states managed independantly of other layers while blending the
             output with those layers.
             </summary>
            
             <remarks>
             This class can be used as a custom yield instruction to wait until all animations finish playing.
             <para></para>
             Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/blending/layers">Layers</see>
             </remarks>
             https://kybernetik.com.au/animancer/api/Animancer/AnimancerLayer
             
        </member>
        <member name="M:Animancer.AnimancerLayer.#ctor(Animancer.AnimancerPlayable,System.Int32)">
            <summary>[Internal] Creates a new <see cref="T:Animancer.AnimancerLayer"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreatePlayable(UnityEngine.Playables.Playable@)">
            <summary>Creates and assigns the <see cref="T:UnityEngine.Animations.AnimationMixerPlayable"/> managed by this layer.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.Layer">
            <summary>A layer is its own root.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.Parent">
            <summary>The <see cref="P:Animancer.AnimancerNode.Root"/> receives the output of the <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.KeepChildrenConnected">
            <summary>Indicates whether child playables should stay connected to this layer at all times.</summary>
        </member>
        <member name="F:Animancer.AnimancerLayer.States">
            <summary>All of the animation states connected to this layer.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.CurrentState">
            <summary>The state of the animation currently being played.</summary>
            <remarks>
            Specifically, this is the state that was most recently started using any of the Play or CrossFade methods
            on this layer. States controlled individually via methods in the <see cref="T:Animancer.AnimancerState"/> itself will
            not register in this property.
            <para></para>
            Each time this property changes, the <see cref="P:Animancer.AnimancerLayer.CommandCount"/> is incremented.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerLayer.CommandCount">
            <summary>
            The number of times the <see cref="P:Animancer.AnimancerLayer.CurrentState"/> has changed. By storing this value and later comparing
            the stored value to the current value, you can determine whether the state has been changed since then,
            even it has changed back to the same state.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.IncrementCommandCount">
            <summary>[Editor-Only] [Internal] Increases the <see cref="P:Animancer.AnimancerLayer.CommandCount"/> by 1.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.IsAdditive">
            <summary>[Pro-Only]
            Determines whether this layer is set to additive blending. Otherwise it will override any earlier layers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.SetMask(UnityEngine.AvatarMask)">
            <summary>[Pro-Only]
            Sets an <see cref="T:UnityEngine.AvatarMask"/> to determine which bones this layer will affect.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerLayer._Mask">
            <summary>[Assert-Only] The <see cref="T:UnityEngine.AvatarMask"/> that determines which bones this layer will affect.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.AverageVelocity">
            <summary>
            The average velocity of the root motion of all currently playing animations, taking their current
            <see cref="P:Animancer.AnimancerNode.Weight"/> into account.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.ChildCount">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetChild(System.Int32)">
            <summary>Returns the state connected to the specified `index` as a child of this layer.</summary>
            <remarks>This method is identical to <see cref="P:Animancer.AnimancerLayer.Item(System.Int32)"/>.</remarks>
        </member>
        <member name="P:Animancer.AnimancerLayer.Item(System.Int32)">
            <summary>Returns the state connected to the specified `index` as a child of this layer.</summary>
            <remarks>This indexer is identical to <see cref="M:Animancer.AnimancerLayer.GetChild(System.Int32)"/>.</remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.AddChild(Animancer.AnimancerState)">
            <summary>Adds a new port and uses <see cref="M:Animancer.AnimancerState.SetParent(Animancer.AnimancerNode,System.Int32)"/> to connect the `state` to it.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.OnAddChild(Animancer.AnimancerState)">
            <summary>Connects the `state` to this layer at its <see cref="P:Animancer.AnimancerNode.Index"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.OnRemoveChild(Animancer.AnimancerState)">
            <summary>Disconnects the `state` from this layer at its <see cref="P:Animancer.AnimancerNode.Index"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip)">
            <summary>Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the `clip`.</summary>
            <remarks>
            <see cref="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)"/> is used to determine the <see cref="P:Animancer.AnimancerState.Key"/>.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateState(System.Object,UnityEngine.AnimationClip)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the `clip` and registers it with the `key`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetState(System.Object@)">
            <summary>Returns a state registered with the `key` and attached to this layer or null if none exist.</summary>
            <exception cref="T:System.ArgumentNullException">The `key` is null.</exception>
            <remarks>
            If a state is registered with the `key` but on a different layer, this method will use that state as the
            key and try to look up another state with it. This allows it to associate multiple states with the same
            original key.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateIfNew(UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerLayer.GetOrCreateState(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            <para></para>
            If you only want to create a single state, use <see cref="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateIfNew(UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerLayer.GetOrCreateState(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            <para></para>
            If you only want to create a single state, use <see cref="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateIfNew(UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerLayer.GetOrCreateState(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            <para></para>
            If you only want to create a single state, use <see cref="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.CreateIfNew(UnityEngine.AnimationClip[])">
            <summary>
            Calls <see cref="M:Animancer.AnimancerLayer.GetOrCreateState(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.
            <para></para>
            If you only want to create a single state, use <see cref="M:Animancer.AnimancerLayer.CreateState(UnityEngine.AnimationClip)"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetOrCreateState(UnityEngine.AnimationClip,System.Boolean)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)"/> and returns the state registered with that key or
            creates one if it doesn't exist.
            <para></para>
            If the state already exists but has the wrong <see cref="P:Animancer.AnimancerState.Clip"/>, the `allowSetClip`
            parameter determines what will happen. False causes it to throw an <see cref="T:System.ArgumentException"/> while
            true allows it to change the <see cref="P:Animancer.AnimancerState.Clip"/>. Note that the change is somewhat costly to
            performance to use with caution.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetOrCreateState(Animancer.ITransition)">
            <summary>
            Returns the state registered with the <see cref="P:Animancer.IHasKey.Key"/> if there is one. Otherwise
            this method uses <see cref="M:Animancer.ITransition.CreateState"/> to create a new one and registers it with
            that key before returning it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetOrCreateState(System.Object,UnityEngine.AnimationClip,System.Boolean)">
            <summary>Returns the state registered with the `key` or creates one if it doesn't exist.</summary>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:System.ArgumentNullException">The `key` is null.</exception>
            <remarks>
            If the state already exists but has the wrong <see cref="P:Animancer.AnimancerState.Clip"/>, the `allowSetClip`
            parameter determines what will happen. False causes it to throw an <see cref="T:System.ArgumentException"/> while
            true allows it to change the <see cref="P:Animancer.AnimancerState.Clip"/>. Note that the change is somewhat costly to
            performance to use with caution.
            <para></para>
            See also: <see cref="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(System.Object,UnityEngine.AnimationClip,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetOrCreateState(Animancer.AnimancerState)">
            <summary>Returns the `state` if it's a child of this layer. Otherwise makes a clone of it.</summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.WeightlessThreshold">
            <summary>
            The maximum <see cref="P:Animancer.AnimancerNode.Weight"/> that <see cref="M:Animancer.AnimancerLayer.GetOrCreateWeightlessState(Animancer.AnimancerState)"/> will treat as
            being weightless. Default = 0.1.
            </summary>
            <remarks>This allows states with very small weights to be reused instead of needing to create new ones.</remarks>
        </member>
        <member name="P:Animancer.AnimancerLayer.MaxCloneCount">
            <summary>
            The maximum number of duplicate states that can be created for a single clip when trying to get a
            weightless state. Exceeding this limit will cause it to just use the state with the lowest weight.
            Default = 3.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetOrCreateWeightlessState(Animancer.AnimancerState)">
            <summary>
            If the `state`'s <see cref="P:Animancer.AnimancerNode.Weight"/> is not currently low, this method finds or creates a
            copy of it which is low. he returned <see cref="P:Animancer.AnimancerState.Time"/> is also set to 0.
            </summary>
            <remarks>
            If this method would exceed the <see cref="P:Animancer.AnimancerLayer.MaxCloneCount"/>, it returns the clone with the lowest weight.
            <para></para>
            "Low" weight is defined as less than or equal to the <see cref="P:Animancer.AnimancerLayer.WeightlessThreshold"/>.
            <para></para>
            The <see href="https://kybernetik.com.au/animancer/docs/manual/blending/fading/modes">Fade Modes</see> page
            explains why clones are created.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.DestroyStates">
            <summary>Destroys all states connected to this layer.</summary>
            <remarks>This operation cannot be undone.</remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.OnStartFade">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(UnityEngine.AnimationClip)">
            <summary>Stops all other animations on this layer, plays the `clip`, and returns its state.</summary>
            <remarks>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            To restart it from the beginning you can use <c>...Play(clip).Time = 0;</c>.
            <para></para>
            This method is safe to call repeatedly without checking whether the `clip` was already playing.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState)">
            <summary>Stops all other animations on the same layer, plays the `state`, and returns it.</summary>
            <remarks>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            To restart it from the beginning you can use <c>...Play(state).Time = 0;</c>.
            <para></para>
            This method is safe to call repeatedly without checking whether the `state` was already playing.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="P:Animancer.AnimancerState.Parent"/> is another state (likely a <see cref="T:Animancer.ManualMixerState"/>).
            It must be either null or a layer.
            </exception>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(UnityEngine.AnimationClip,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the `clip` over the course of the `fadeDuration` while fading out all others in the same
            layer. Returns its state.
            </summary>
            <remarks>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            This method is safe to call repeatedly without checking whether the `state` was already playing.
            <para></para>
            <em>Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in runtime builds.</em>
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the `state` over the course of the `fadeDuration` while fading out all others in this
            layer. Returns the `state`.
            </summary>
            <remarks>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            This method is safe to call repeatedly without checking whether the `state` was already playing.
            <para></para>
            <em>Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in runtime builds.</em>
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(Animancer.ITransition)">
            <summary>
            Creates a state for the `transition` if it didn't already exist, then calls
            <see cref="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState)"/> or <see cref="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/>
            depending on the <see cref="P:Animancer.ITransition.FadeDuration"/>.
            </summary>
            <remarks>
            This method is safe to call repeatedly without checking whether the `transition` was already playing.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.Play(Animancer.ITransition,System.Single,Animancer.FadeMode)">
            <summary>
            Creates a state for the `transition` if it didn't already exist, then calls
            <see cref="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState)"/> or <see cref="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/>
            depending on the <see cref="P:Animancer.ITransition.FadeDuration"/>.
            </summary>
            <remarks>
            This method is safe to call repeatedly without checking whether the `transition` was already playing.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.TryPlay(System.Object)">
            <summary>
            Stops all other animations on the same layer, plays the animation registered with the `key`, and returns
            that state. Or if no state is registered with that `key`, this method does nothing and returns null.
            </summary>
            <remarks>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            To restart it from the beginning you can simply set the returned state's time to 0.
            <para></para>
            This method is safe to call repeatedly without checking whether the animation was already playing.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.TryPlay(System.Object,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the animation registered with the `key` while fading out all others in the same layer
            over the course of the `fadeDuration`. Or if no state is registered with that `key`, this method does
            nothing and returns null.
            </summary>
            <remarks>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            This method is safe to call repeatedly without checking whether the animation was already playing.
            <para></para>
            <em>Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in runtime builds.</em>
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerLayer.EvaluateFadeMode(Animancer.FadeMode,Animancer.AnimancerState@,System.Single@,System.Single@)">
            <summary>Manipulates the other parameters according to the `mode`.</summary>
            <exception cref="T:System.ArgumentException">
            The <see cref="P:Animancer.AnimancerState.Clip"/> is null when using <see cref="F:Animancer.FadeMode.FromStart"/> or
            <see cref="F:Animancer.FadeMode.NormalizedFromStart"/>.
            </exception>
        </member>
        <member name="M:Animancer.AnimancerLayer.Stop">
            <summary>
            Sets <see cref="P:Animancer.AnimancerNode.Weight"/> = 0 and calls <see cref="M:Animancer.AnimancerState.Stop"/> on all animations
            to stop them from playing and rewind them to the start.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.IsPlayingClip(UnityEngine.AnimationClip)">
            <summary>
            Returns true if the `clip` is currently being played by at least one state.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.IsAnyStatePlaying">
            <summary>
            Returns true if at least one animation is being played.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.IsPlayingAndNotEnding">
            <summary>
            Returns true if the <see cref="P:Animancer.AnimancerLayer.CurrentState"/> is playing and hasn't yet reached its end.
            <para></para>
            This method is called by <see cref="M:System.Collections.IEnumerator.MoveNext"/> so this object can be used as a custom yield
            instruction to wait until it finishes.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.GetTotalWeight">
            <summary>
            Calculates the total <see cref="P:Animancer.AnimancerNode.Weight"/> of all states in this layer.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerLayer.ApplyAnimatorIK">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.AnimancerLayer.ApplyFootIK">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.AnimancerLayer.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>]
            Gathers all the animations in this layer.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.ToString">
            <summary>The Inspector display name of this layer.</summary>
        </member>
        <member name="M:Animancer.AnimancerLayer.AppendDetails(System.Text.StringBuilder,System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.AnimancerNode">
            <summary>Base class for <see cref="T:UnityEngine.Playables.Playable"/> wrapper objects in an <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer/AnimancerNode
            
        </member>
        <member name="F:Animancer.AnimancerNode._Playable">
            <summary>
            The internal object this node manages in the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            <para></para>
            Must be set by <see cref="M:Animancer.AnimancerNode.CreatePlayable"/>. Failure to do so will throw the following exception
            throughout the system when using this node: "<see cref="T:System.ArgumentException"/>: The playable passed as an
            argument is invalid. To create a valid playable, please use the appropriate Create method".
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Animancer#IPlayableWrapper#Playable">
            <summary>The internal <see cref="T:UnityEngine.Playables.Playable"/> managed by this node.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.IsValid">
            <summary>Is the <see cref="T:UnityEngine.Playables.Playable"/> usable (properly initialized and not destroyed)?</summary>
        </member>
        <member name="F:Animancer.AnimancerNode._IsInspectorExpanded">
            <summary>[Editor-Only, Internal] Indicates whether the Inspector details for this node are expanded.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.CreatePlayable">
            <summary>Creates and assigns the <see cref="T:UnityEngine.Playables.Playable"/> managed by this node.</summary>
            <remarks>This method also applies the <see cref="P:Animancer.AnimancerNode.Speed"/> if it was set beforehand.</remarks>
        </member>
        <member name="M:Animancer.AnimancerNode.CreatePlayable(UnityEngine.Playables.Playable@)">
            <summary>Creates and assigns the <see cref="T:UnityEngine.Playables.Playable"/> managed by this node.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.DestroyPlayable">
            <summary>Destroys the <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.RecreatePlayable">
            <summary>Calls <see cref="M:Animancer.AnimancerNode.DestroyPlayable"/> and <see cref="M:Animancer.AnimancerNode.CreatePlayable"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.RecreatePlayableRecursive">
            <summary>Calls <see cref="M:Animancer.AnimancerNode.RecreatePlayable"/> on this node and all its children recursively.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.Animancer#ICopyable{Animancer#AnimancerNode}#CopyFrom(Animancer.AnimancerNode)">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.AnimancerNode.Root">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> at the root of the graph.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Layer">
            <summary>The root <see cref="T:Animancer.AnimancerLayer"/> which this node is connected to.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Parent">
            <summary>The object which receives the output of this node.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Index">
            <summary>The index of the port this node is connected to on the parent's <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
            <remarks>
            A negative value indicates that it is not assigned to a port.
            <para></para>
            Indices are generally assigned starting from 0, ascending in the order they are connected to their layer.
            They will not usually change unless the <see cref="P:Animancer.AnimancerNode.Parent"/> changes or another state on the same layer is
            destroyed so the last state is swapped into its place to avoid shuffling everything down to cover the gap.
            <para></para>
            The setter is internal so user defined states cannot set it incorrectly. Ideally,
            <see cref="T:Animancer.AnimancerLayer"/> should be able to set the port in its constructor and
            <see cref="M:Animancer.AnimancerState.SetParent(Animancer.AnimancerNode,System.Int32)"/> should also be able to set it, but classes that further inherit from
            there should not be able to change it without properly calling that method.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerNode.#ctor">
            <summary>Creates a new <see cref="T:Animancer.AnimancerNode"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.TraceConstructor">
            <summary>[Assert-Only]
            Should a <see cref="T:System.Diagnostics.StackTrace"/> be captured in the constructor of all new nodes so
            <see cref="F:Animancer.OptionalWarning.UnusedNode"/> can include it in the warning if that node ends up being unused?
            </summary>
            <remarks>This has a notable performance cost so it should only be used when trying to identify a problem.</remarks>
        </member>
        <member name="F:Animancer.AnimancerNode._ConstructorStackTrace">
            <summary>[Assert-Only]
            The stack trace of the constructor (or null if <see cref="P:Animancer.AnimancerNode.TraceConstructor"/> was false).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.GetConstructorStackTrace(Animancer.AnimancerNode)">
            <summary>[Assert-Only]
            Returns the stack trace of the constructor (or null if <see cref="P:Animancer.AnimancerNode.TraceConstructor"/> was false).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.Finalize">
            <summary>[Assert-Only] Checks <see cref="F:Animancer.OptionalWarning.UnusedNode"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.ConnectToGraph">
            <summary>[Internal] Connects the <see cref="T:UnityEngine.Playables.Playable"/> to the <see cref="P:Animancer.AnimancerNode.Parent"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.DisconnectFromGraph">
            <summary>[Internal] Disconnects the <see cref="T:UnityEngine.Playables.Playable"/> from the <see cref="P:Animancer.AnimancerNode.Parent"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.RequireUpdate">
            <summary>Calls <see cref="M:Animancer.AnimancerPlayable.RequirePreUpdate(Animancer.IUpdatable)"/> if the <see cref="P:Animancer.AnimancerNode.Root"/> is not null.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.Animancer#IUpdatable#Update">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.AnimancerNode.Update(System.Boolean@)">
            <summary>
            Updates the <see cref="P:Animancer.AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent mixer, and plays
            or pauses the <see cref="T:UnityEngine.Playables.Playable"/> if its state is dirty.
            <para></para>
            If the <see cref="P:Animancer.AnimancerNode.Parent"/>'s <see cref="P:Animancer.AnimancerNode.KeepChildrenConnected"/> is set to false, this method will
            also connect/disconnect this node from the <see cref="P:Animancer.AnimancerNode.Parent"/> in the playable graph.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.IsPlayingAndNotEnding">
            <summary>Is this node playing and not yet at its end?</summary>
            <remarks>
            This method is called by <see cref="M:System.Collections.IEnumerator.MoveNext"/> so this object can be used as a custom yield
            instruction to wait until it finishes.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerNode.ChildCount">
            <summary>[<see cref="T:Animancer.IPlayableWrapper"/>]
            The number of states using this node as their <see cref="P:Animancer.AnimancerState.Parent"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.Animancer#IPlayableWrapper#GetChild(System.Int32)">
            <summary>Returns the state connected to the specified `index` as a child of this node.</summary>
            <exception cref="T:System.NotSupportedException">This node can't have children.</exception>
        </member>
        <member name="M:Animancer.AnimancerNode.GetChild(System.Int32)">
            <summary>[<see cref="T:Animancer.IPlayableWrapper"/>]
            Returns the state connected to the specified `index` as a child of this node.
            </summary>
            <exception cref="T:System.NotSupportedException">This node can't have children.</exception>
        </member>
        <member name="M:Animancer.AnimancerNode.OnAddChild(Animancer.AnimancerState)">
            <summary>Called when a child is connected with this node as its <see cref="P:Animancer.AnimancerState.Parent"/>.</summary>
            <exception cref="T:System.NotSupportedException">This node can't have children.</exception>
        </member>
        <member name="M:Animancer.AnimancerNode.OnRemoveChild(Animancer.AnimancerState)">
            <summary>Called when a child's <see cref="P:Animancer.AnimancerState.Parent"/> is changed from this node.</summary>
            <exception cref="T:System.NotSupportedException">This node can't have children.</exception>
        </member>
        <member name="M:Animancer.AnimancerNode.OnAddChild(System.Collections.Generic.IList{Animancer.AnimancerState},Animancer.AnimancerState)">
            <summary>Connects the `state` to this node at its <see cref="P:Animancer.AnimancerNode.Index"/>.</summary>
            <exception cref="T:System.InvalidOperationException">The <see cref="P:Animancer.AnimancerNode.Index"/> was already occupied.</exception>
        </member>
        <member name="P:Animancer.AnimancerNode.KeepChildrenConnected">
            <summary>
            Indicates whether child playables should stay connected to this mixer at all times (default false).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.ConnectAllChildrenToGraph">
            <summary>
            Ensures that all children of this node are connected to the <see cref="F:Animancer.AnimancerNode._Playable"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.DisconnectWeightlessChildrenFromGraph">
            <summary>
            Ensures that all children of this node which have zero weight are disconnected from the
            <see cref="F:Animancer.AnimancerNode._Playable"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.GetEnumerator">
            <summary>Gets an enumerator for all of this node's child states.</summary>
        </member>
        <member name="F:Animancer.AnimancerNode._Weight">
            <summary>The current blend weight of this node. Accessed via <see cref="P:Animancer.AnimancerNode.Weight"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerNode._IsWeightDirty">
            <summary>Indicates whether the weight has changed and should be applied to the parent mixer.</summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Weight">
             <summary>The current blend weight of this node which determines how much it affects the final output.</summary>
             <remarks>
             0 has no effect while 1 applies the full effect and values inbetween apply a proportional effect.
             <para></para>
             Setting this property cancels any fade currently in progress. If you don't wish to do that, you can use
             <see cref="M:Animancer.AnimancerNode.SetWeight(System.Single)"/> instead.
             <para></para>
             <em>Animancer Lite only allows this value to be set to 0 or 1 in runtime builds.</em>
             </remarks>
            
             <example>
             Calling <see cref="M:Animancer.AnimancerPlayable.Play(UnityEngine.AnimationClip)"/> immediately sets the weight of all states to 0
             and the new state to 1. Note that this is separate from other values like
             <see cref="P:Animancer.AnimancerState.IsPlaying"/> so a state can be paused at any point and still show its pose on the
             character or it could be still playing at 0 weight if you want it to still trigger events (though states
             are normally stopped when they reach 0 weight so you would need to explicitly set it to playing again).
             <para></para>
             Calling <see cref="M:Animancer.AnimancerPlayable.Play(UnityEngine.AnimationClip,System.Single,Animancer.FadeMode)"/> does not immediately change
             the weights, but instead calls <see cref="M:Animancer.AnimancerNode.StartFade(System.Single,System.Single)"/> on every state to set their
             <see cref="P:Animancer.AnimancerNode.TargetWeight"/> and <see cref="P:Animancer.AnimancerNode.FadeSpeed"/>. Then every update each state's weight will move
             towards that target value at that speed.
             </example>
        </member>
        <member name="M:Animancer.AnimancerNode.SetWeight(System.Single)">
            <summary>
            Sets the current blend weight of this node which determines how much it affects the final output.
            0 has no effect while 1 applies the full effect of this node.
            <para></para>
            This method allows any fade currently in progress to continue. If you don't wish to do that, you can set
            the <see cref="P:Animancer.AnimancerNode.Weight"/> property instead.
            <para></para>
            <em>Animancer Lite only allows this value to be set to 0 or 1 in runtime builds.</em>
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.SetWeightDirty">
            <summary>Flags this node as having a changed <see cref="P:Animancer.AnimancerNode.Weight"/> that needs to be applied next update.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.ApplyWeight">
            <summary>
            Applies the <see cref="P:Animancer.AnimancerNode.Weight"/> to the connection between this node and its <see cref="P:Animancer.AnimancerNode.Parent"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.EffectiveWeight">
            <summary>
            The <see cref="P:Animancer.AnimancerNode.Weight"/> of this state multiplied by the <see cref="P:Animancer.AnimancerNode.Weight"/> of each of its parents down
            the hierarchy to determine how much this state affects the final output.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.TargetWeight">
            <summary>
            The desired <see cref="P:Animancer.AnimancerNode.Weight"/> which this node is fading towards according to the
            <see cref="P:Animancer.AnimancerNode.FadeSpeed"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.FadeSpeed">
            <summary>The speed at which this node is fading towards the <see cref="P:Animancer.AnimancerNode.TargetWeight"/>.</summary>
            <remarks>This value isn't affected by this node's <see cref="P:Animancer.AnimancerNode.Speed"/>, but is affected by its parents.</remarks>
        </member>
        <member name="M:Animancer.AnimancerNode.StartFade(System.Single)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerNode.OnStartFade"/> and starts fading the <see cref="P:Animancer.AnimancerNode.Weight"/> over the course
            of the <see cref="P:Animancer.AnimancerPlayable.DefaultFadeDuration"/> (in seconds).
            </summary>
            <remarks>
            If the `targetWeight` is 0 then <see cref="M:Animancer.AnimancerNode.Stop"/> will be called when the fade is complete.
            <para></para>
            If the <see cref="P:Animancer.AnimancerNode.Weight"/> is already equal to the `targetWeight` then the fade will end
            immediately.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerNode.StartFade(System.Single,System.Single)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerNode.OnStartFade"/> and starts fading the <see cref="P:Animancer.AnimancerNode.Weight"/> over the course
            of the `fadeDuration` (in seconds).
            </summary>
            <remarks>
            If the `targetWeight` is 0 then <see cref="M:Animancer.AnimancerNode.Stop"/> will be called when the fade is complete.
            <para></para>
            If the <see cref="P:Animancer.AnimancerNode.Weight"/> is already equal to the `targetWeight` then the fade will end
            immediately.
            <para></para>
            <em>Animancer Lite only allows a `targetWeight` of 0 or 1 and the default `fadeDuration` (0.25 seconds) in
            runtime builds.</em>
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerNode.OnStartFade">
            <summary>Called by <see cref="M:Animancer.AnimancerNode.StartFade(System.Single,System.Single)"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.Stop">
            <summary>
            Stops the animation and makes it inactive immediately so it no longer affects the output.
            Sets <see cref="P:Animancer.AnimancerNode.Weight"/> = 0 by default.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.UpdateFade(System.Boolean@)">
            <summary>
            Moves the <see cref="P:Animancer.AnimancerNode.Weight"/> towards the <see cref="P:Animancer.AnimancerNode.TargetWeight"/> according to the
            <see cref="P:Animancer.AnimancerNode.FadeSpeed"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.Speed">
             <summary>[Pro-Only] How fast the <see cref="P:Animancer.AnimancerState.Time"/> is advancing every frame (default 1).</summary>
             
             <remarks>
             A negative value will play the animation backwards.
             <para></para>
             To pause an animation, consider setting <see cref="P:Animancer.AnimancerState.IsPlaying"/> to false instead of setting
             this value to 0.
             <para></para>
             <em>Animancer Lite does not allow this value to be changed in runtime builds.</em>
             </remarks>
            
             <example><code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 state.Speed = 1;// Normal speed.
                 state.Speed = 2;// Double speed.
                 state.Speed = 0.5f;// Half speed.
                 state.Speed = -1;// Normal speed playing backwards.
             }
             </code></example>
             
             <exception cref="T:System.ArgumentOutOfRangeException">The value is not finite.</exception>
        </member>
        <member name="P:Animancer.AnimancerNode.UnsupportedSpeedMessage">
            <summary>[Assert-Only]
            Returns null if the <see cref="P:Animancer.AnimancerNode.Speed"/> property will work properly on this type of node, or a message
            explaining why it won't work.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.ParentEffectiveSpeed">
            <summary>
            The multiplied <see cref="P:Animancer.AnimancerNode.Speed"/> of each of this node's parents down the hierarchy, excluding the root
            <see cref="P:Animancer.AnimancerPlayable.Speed"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.EffectiveSpeed">
            <summary>
            The <see cref="P:Animancer.AnimancerNode.Speed"/> of this node multiplied by the <see cref="P:Animancer.AnimancerNode.Speed"/> of each of its parents to
            determine the actual speed it's playing at.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.ApplyParentAnimatorIK">
            <summary>
            Should setting the <see cref="P:Animancer.AnimancerNode.Parent"/> also set this node's <see cref="P:Animancer.AnimancerNode.ApplyAnimatorIK"/> to match it?
            Default is true.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.ApplyParentFootIK">
            <summary>
            Should setting the <see cref="P:Animancer.AnimancerNode.Parent"/> also set this node's <see cref="P:Animancer.AnimancerNode.ApplyFootIK"/> to match it?
            Default is true.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.CopyIKFlags(Animancer.AnimancerNode)">
            <summary>
            Copies the IK settings from the <see cref="P:Animancer.AnimancerNode.Parent"/>:
            <list type="bullet">
            <item>If <see cref="P:Animancer.AnimancerNode.ApplyParentAnimatorIK"/> is true, copy <see cref="P:Animancer.AnimancerNode.ApplyAnimatorIK"/>.</item>
            <item>If <see cref="P:Animancer.AnimancerNode.ApplyParentFootIK"/> is true, copy <see cref="P:Animancer.AnimancerNode.ApplyFootIK"/>.</item>
            </list>
            </summary>
        </member>
        <member name="P:Animancer.AnimancerNode.ApplyAnimatorIK">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.AnimancerNode.ApplyFootIK">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.AnimancerNode.DebugName">
            <summary>[Assert-Only] The Inspector display name of this node.</summary>
            <remarks>Set using <see cref="M:Animancer.AnimancerNode.SetDebugName(System.String)"/>.</remarks>
        </member>
        <member name="M:Animancer.AnimancerNode.ToString">
            <summary>The Inspector display name of this node.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.SetDebugName(System.String)">
            <summary>[Assert-Conditional]
            Sets the Inspector display name of this node. <see cref="M:Animancer.AnimancerNode.ToString"/> returns the name.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerNode.GetDescription(System.String)">
            <summary>Returns a detailed descrption of the current details of this node.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.AppendDescription(System.Text.StringBuilder,System.String)">
            <summary>Appends a detailed descrption of the current details of this node.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.AppendDetails(System.Text.StringBuilder,System.String)">
            <summary>Called by <see cref="M:Animancer.AnimancerNode.AppendDescription(System.Text.StringBuilder,System.String)"/> to append the details of this node.</summary>
        </member>
        <member name="M:Animancer.AnimancerNode.AppendIKDetails(System.Text.StringBuilder,System.String,Animancer.IPlayableWrapper)">
            <summary>
            Appends the details of <see cref="P:Animancer.IPlayableWrapper.ApplyAnimatorIK"/> and
            <see cref="P:Animancer.IPlayableWrapper.ApplyFootIK"/>.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerPlayable">
            <summary>
            A <see cref="T:UnityEngine.Playables.PlayableBehaviour"/> which can be used as a substitute for the
            <see cref="T:UnityEngine.RuntimeAnimatorController"/> normally used to control an <see cref="T:UnityEngine.Animator"/>.
            </summary>
            
            <remarks>
            This class can be used as a custom yield instruction to wait until all animations finish playing.
            <para></para>
            The most common way to access this class is via <see cref="!:AnimancerComponent.Playable"/>.
            <para></para>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/playing">Playing Animations</see>
            </remarks>
            
            https://kybernetik.com.au/animancer/api/Animancer/AnimancerPlayable
            
            https://kybernetik.com.au/animancer/api/Animancer/AnimancerPlayable
            
            https://kybernetik.com.au/animancer/api/Animancer/AnimancerPlayable
            
        </member>
        <member name="F:Animancer.AnimancerPlayable.DefaultFadeDurationNamespace">
            <summary>[Editor-Only]
            The namespace that should be used for a class which sets the <see cref="P:Animancer.AnimancerPlayable.DefaultFadeDuration"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.DefaultFadeDurationClass">
            <summary>[Editor-Only]
            The name that should be used for a class which sets the <see cref="P:Animancer.AnimancerPlayable.DefaultFadeDuration"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.#cctor">
            <summary>[Editor-Only]
            Initializes the <see cref="P:Animancer.AnimancerPlayable.DefaultFadeDuration"/> (see its example for more information).
            </summary>
            <remarks>
            This method takes about 2 milliseconds if a <see cref="P:Animancer.AnimancerPlayable.DefaultFadeDuration"/> class exists, or 0 if it
            doesn't (less than 0.5 rounded off according to a <see cref="T:System.Diagnostics.Stopwatch"/>).
            <para></para>
            The <see cref="P:Animancer.AnimancerPlayable.DefaultFadeDuration"/> can't simply be stored in the
            <see cref="!:Editor.AnimancerSettings"/> because it needs to be initialized before Unity is able to load
            <see cref="T:UnityEngine.ScriptableObject"/>s.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerPlayable.DefaultFadeDuration">
            <summary>The fade duration to use if not specified. Default is 0.25.</summary>
            <exception cref="T:UnityEngine.Assertions.AssertionException">The value is negative or infinity.</exception>
            <remarks><em>Animancer Lite doesn't allow this value to be changed in runtime builds (except to 0).</em></remarks>
            <example>
            <see cref="T:UnityEngine.Sprite"/> based games often have no use for fading so you could set this value to 0 using the
            following script so that you don't need to manually set the <see cref="P:Animancer.ITransition.FadeDuration"/> of all
            your transitions.
            <para></para>
            To set this value automatically on startup, put the following class into any script:
            <para></para><code>
            namespace Animancer
            {
                internal static class DefaultFadeDuration
                {
                    [UnityEngine.RuntimeInitializeOnLoadMethod(UnityEngine.RuntimeInitializeLoadType.BeforeSceneLoad)]
                    private static void Initialize() => AnimancerPlayable.DefaultFadeDuration = 0;
                }
            }
            </code>
            Using that specific namespace (<see cref="F:Animancer.AnimancerPlayable.DefaultFadeDurationNamespace"/>) and class name
            (<see cref="F:Animancer.AnimancerPlayable.DefaultFadeDurationClass"/>) allows Animancer to find and run it immediately in the Unity
            Editor so that newly created transition fields can start with the correct value (using a
            <c>[UnityEditor.InitializeOnLoadMethod]</c> attribute would run it too late).
            </example>
        </member>
        <member name="F:Animancer.AnimancerPlayable._Graph">
            <summary>[Internal] The <see cref="T:UnityEngine.Playables.PlayableGraph"/> containing this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Graph">
            <summary>[Pro-Only] The <see cref="T:UnityEngine.Playables.PlayableGraph"/> containing this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._RootPlayable">
            <summary>[Internal] The <see cref="T:UnityEngine.Playables.Playable"/> containing this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._LayerMixer">
            <summary>[Internal] The <see cref="T:UnityEngine.Playables.Playable"/> which layers connect to.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Animancer#IPlayableWrapper#Playable">
            <summary>[Internal] The <see cref="T:UnityEngine.Playables.Playable"/> which layers connect to.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Animancer#IPlayableWrapper#Parent">
            <summary>[Internal] An <see cref="T:Animancer.AnimancerPlayable"/> is the root of the graph so it has no parent.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Animancer#IPlayableWrapper#Weight">
            <summary>[Internal] The current blend weight of this node which determines how much it affects the final output.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Animancer#IPlayableWrapper#ChildCount">
            <summary>[Internal] The <see cref="P:Animancer.AnimancerPlayable.LayerList.Count"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Animancer#IPlayableWrapper#GetChild(System.Int32)">
            <summary>[Internal] Returns the layer at the specified `index`.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Layers">
            <summary>The <see cref="T:Animancer.AnimancerLayer"/>s which each manage their own set of animations.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/blending/layers">Layers</see>
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerPlayable.States">
            <summary>The <see cref="T:Animancer.AnimancerState"/>s managed by this playable.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/playing/states">States</see>
            </remarks>
        </member>
        <member name="F:Animancer.AnimancerPlayable._PreUpdatables">
            <summary>All of the nodes that need to be updated.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._PostUpdatables">
            <summary>All of the objects that need to be updated early.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._PostUpdate">
            <summary>A <see cref="T:UnityEngine.Playables.PlayableBehaviour"/> that updates the <see cref="F:Animancer.AnimancerPlayable._PostUpdatables"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Component">
            <summary>The component that is playing this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.CommandCount">
            <summary>
            The number of times the <see cref="P:Animancer.AnimancerLayer.CurrentState"/> has changed on layer 0. By storing this
            value and later comparing the stored value to the current value, you can determine whether the state has
            been changed since then, even it has changed back to the same state.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.UpdateMode">
            <summary>Determines what time source is used to update the <see cref="T:UnityEngine.Playables.PlayableGraph"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Speed">
             <summary>How fast the <see cref="P:Animancer.AnimancerState.Time"/> of all animations is advancing every frame.</summary>
             
             <remarks>
             1 is the normal speed.
             <para></para>
             A negative value will play the animations backwards.
             <para></para>
             Setting this value to 0 would pause all animations, but calling <see cref="M:Animancer.AnimancerPlayable.PauseGraph"/> is more efficient.
             <para></para>
             <em>Animancer Lite does not allow this value to be changed in runtime builds.</em>
             </remarks>
            
             <example><code>
             void SetSpeed(AnimancerComponent animancer)
             {
                 animancer.Playable.Speed = 1;// Normal speed.
                 animancer.Playable.Speed = 2;// Double speed.
                 animancer.Playable.Speed = 0.5f;// Half speed.
                 animancer.Playable.Speed = -1;// Normal speed playing backwards.
             }
             </code></example>
        </member>
        <member name="P:Animancer.AnimancerPlayable.KeepChildrenConnected">
            <summary>
            Should playables stay connected to the graph at all times?
            Otherwise they will be disconnected when their  <see cref="P:Animancer.AnimancerNode.Weight"/> is 0.
            </summary>
            
            <remarks>
            Humanoid Rigs default this value to <c>false</c> so that playables will be disconnected from the graph
            while they are at 0 weight which stops it from evaluating them every frame.
            <para></para>
            Generic Rigs default this value to <c>true</c> because they do not always animate the same standard set of
            values so every connection change has a higher performance cost than with Humanoid Rigs which is generally
            more significant than the gains for having fewer playables connected at a time.
            <para></para>
            The default is set by <see cref="M:Animancer.AnimancerPlayable.CreateOutput(UnityEngine.Animator,Animancer.IAnimancerComponent)"/>.
            </remarks>
            
            <example><code>
            [SerializeField]
            private AnimancerComponent _Animancer;
            
            public void Initialize()
            {
                _Animancer.Playable.KeepChildrenConnected = true;
            }
            </code></example>
        </member>
        <member name="P:Animancer.AnimancerPlayable.SkipFirstFade">
            <summary>
            Normally the first animation on the Base Layer should not fade in because there is nothing fading out. But
            sometimes that is undesirable, such as if the <see cref="P:UnityEngine.Animator.runtimeAnimatorController"/> is assigned
            since Animancer can blend with that.
            </summary>
            <remarks>
            Setting this value to false ensures that the <see cref="T:UnityEngine.Animations.AnimationLayerMixerPlayable"/> has at least two
            inputs because it ignores the <see cref="P:Animancer.AnimancerNode.Weight"/> of the layer when there is only one.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Create">
            <summary>
            Creates a new <see cref="T:UnityEngine.Playables.PlayableGraph"/> containing an <see cref="T:Animancer.AnimancerPlayable"/>.
            <para></para>
            The caller is responsible for calling <see cref="M:Animancer.AnimancerPlayable.DestroyGraph"/> on the returned object, except in Edit Mode
            where it will be called automatically.
            <para></para>
            Consider calling <see cref="M:Animancer.AnimancerPlayable.SetNextGraphName(System.String)"/> before this method to give it a name.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.Template">
            <summary>
            Since <see cref="M:UnityEngine.Playables.ScriptPlayable`1.Create(UnityEngine.Playables.PlayableGraph,System.Int32)"/> needs to clone an existing instance, we
            keep a static template to avoid allocating an extra garbage one every time. This is why the fields are
            assigned in <see cref="M:Animancer.AnimancerPlayable.OnPlayableCreate(UnityEngine.Playables.Playable)"/> rather than being readonly with field initializers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Create(UnityEngine.Playables.PlayableGraph)">
            <summary>Creates an <see cref="T:Animancer.AnimancerPlayable"/> in an existing <see cref="T:UnityEngine.Playables.PlayableGraph"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Create``1(UnityEngine.Playables.PlayableGraph,``0)">
            <summary>Creates an <see cref="T:Animancer.AnimancerPlayable"/> in an existing <see cref="T:UnityEngine.Playables.PlayableGraph"/>.</summary>
            <example>
            When inheriting from <see cref="T:Animancer.AnimancerPlayable"/>, it is recommended to give your class a field like the
            following to use as the `template` for this method:
            <code>
            private static readonly MyAnimancerPlayable Template = new MyAnimancerPlayable();
            </code></example>
        </member>
        <member name="M:Animancer.AnimancerPlayable.OnPlayableCreate(UnityEngine.Playables.Playable)">
            <summary>[Internal] Called by Unity when it creates this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.SetNextGraphName(System.String)">
            <summary>[Editor-Conditional]
            Sets the display name for the next <see cref="M:Animancer.AnimancerPlayable.Create"/> call to give its <see cref="T:UnityEngine.Playables.PlayableGraph"/>.
            </summary>
            <remarks>
            Having this method separate from <see cref="M:Animancer.AnimancerPlayable.Create"/> allows the
            <see cref="T:System.Diagnostics.ConditionalAttribute"/> to compile it out of runtime builds which would
            otherwise require #ifs on the caller side.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.ToString">
            <summary>[Editor-Only] Returns "AnimancerPlayable (Graph Name)".</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.TryGetOutput(UnityEngine.Playables.PlayableOutput@)">
            <summary>
            Outputs the <see cref="T:UnityEngine.Playables.PlayableOutput"/> connected to the <see cref="T:Animancer.AnimancerPlayable"/> and returns true
            if it was found. Otherwise returns false.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.CreateOutput(Animancer.IAnimancerComponent)">
            <summary>
            Plays this playable on the <see cref="P:Animancer.IAnimancerComponent.Animator"/> and sets the
            <see cref="P:Animancer.AnimancerPlayable.Component"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.CreateOutput(UnityEngine.Animator,Animancer.IAnimancerComponent)">
            <summary>Plays this playable on the specified `animator` and sets the <see cref="P:Animancer.AnimancerPlayable.Component"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.InsertOutputPlayable(UnityEngine.Playables.Playable)">
            <summary>[Pro-Only]
            Inserts a `playable` after the root of the <see cref="P:Animancer.AnimancerPlayable.Graph"/> so that it can modify the final output.
            </summary>
            <remarks>It can be removed using <see cref="M:Animancer.AnimancerUtilities.RemovePlayable(UnityEngine.Playables.Playable,System.Boolean)"/>.</remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.InsertOutputJob``1(``0)">
            <summary>[Pro-Only]
            Inserts an animation job after the root of the <see cref="P:Animancer.AnimancerPlayable.Graph"/> so that it can modify the final output.
            </summary>
            <remarks>
            It can can be removed by passing the returned value into <see cref="M:Animancer.AnimancerUtilities.RemovePlayable(UnityEngine.Playables.Playable,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerPlayable.IsValid">
            <summary>Is this <see cref="T:Animancer.AnimancerPlayable"/> currently usable (not destroyed)?</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.DestroyGraph">
            <summary>Destroys the <see cref="P:Animancer.AnimancerPlayable.Graph"/>. This operation cannot be undone.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.DestroyOutput">
            <summary>
            Destroys the <see cref="T:UnityEngine.Playables.PlayableOutput"/> connected to this <see cref="T:Animancer.AnimancerPlayable"/> and returns
            true if it was found. Otherwise returns false.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.OnPlayableDestroy(UnityEngine.Playables.Playable)">
            <summary>Cleans up the resources managed by this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Disposables">
            <summary>A list of objects that need to be disposed when this <see cref="T:Animancer.AnimancerPlayable"/> is destroyed.</summary>
            <remarks>This list is primarily used to dispose native arrays used in Animation Jobs.</remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Finalize">
            <summary>Calls <see cref="M:System.IDisposable.Dispose"/> on all the <see cref="P:Animancer.AnimancerPlayable.Disposables"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.DisposeAll">
            <summary>Calls <see cref="M:System.IDisposable.Dispose"/> on all the <see cref="P:Animancer.AnimancerPlayable.Disposables"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.ApplyAnimatorIK">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.AnimancerPlayable.ApplyFootIK">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)">
            <summary>Calls <see cref="M:Animancer.IAnimancerComponent.GetKey(UnityEngine.AnimationClip)"/> on the <see cref="P:Animancer.AnimancerPlayable.Component"/>.</summary>
            <remarks>If the <see cref="P:Animancer.AnimancerPlayable.Component"/> is null, this method returns the `clip` itself.</remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(UnityEngine.AnimationClip)">
            <summary>Stops all other animations on the same layer, plays the `clip`, and returns its state.</summary>
            <remarks>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            To restart it from the beginning you can use <c>...Play(clip).Time = 0;</c>.
            <para></para>
            This method is safe to call repeatedly without checking whether the `clip` was already playing.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState)">
            <summary>Stops all other animations on the same layer, plays the `state`, and returns it.</summary>
            <remarks>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            To restart it from the beginning you can use <c>...Play(state).Time = 0;</c>.
            <para></para>
            This method is safe to call repeatedly without checking whether the `state` was already playing.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(UnityEngine.AnimationClip,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the `clip` while fading out all other states in the same layer over the course of the
            `fadeDuration`. Returns its state.
            </summary>
            <remarks>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            This method is safe to call repeatedly without checking whether the `state` was already playing.
            <para></para>
            <em>Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in runtime builds.</em>
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the `state` while fading out all others in the same layer over the course of the
            `fadeDuration`. Returns the `state`.
            </summary>
            <remarks>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            This method is safe to call repeatedly without checking whether the `state` was already playing.
            <para></para>
            <em>Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in runtime builds.</em>
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)">
            <summary>
            Creates a state for the `transition` if it didn't already exist, then calls
            <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState)"/> or <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/>
            depending on the <see cref="P:Animancer.ITransition.FadeDuration"/>.
            </summary>
            <remarks>
            This method is safe to call repeatedly without checking whether the `transition` was already playing.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition,System.Single,Animancer.FadeMode)">
            <summary>
            Creates a state for the `transition` if it didn't already exist, then calls
            <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState)"/> or <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/>
            depending on the <see cref="P:Animancer.ITransition.FadeDuration"/>.
            </summary>
            <remarks>
            This method is safe to call repeatedly without checking whether the `transition` was already playing.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.TryPlay(System.Object)">
            <summary>
            Stops all other animations on the same layer, plays the animation registered with the `key`, and returns
            that state. Or if no state is registered with that `key`, this method does nothing and returns null.
            </summary>
            <remarks>
            The animation will continue playing from its current <see cref="P:Animancer.AnimancerState.Time"/>.
            If you wish to force it back to the start, you can simply set the returned state's time to 0.
            <para></para>
            This method is safe to call repeatedly without checking whether the animation was already playing.
            </remarks>
            <exception cref="T:System.ArgumentNullException">The `key` is null.</exception>
        </member>
        <member name="M:Animancer.AnimancerPlayable.TryPlay(System.Object,System.Single,Animancer.FadeMode)">
            <summary>
            Starts fading in the animation registered with the `key` while fading out all others in the same layer
            over the course of the `fadeDuration`. Or if no state is registered with that `key`, this method does
            nothing and returns null.
            </summary>
            <remarks>
            If the `state` was already playing and fading in with less time remaining than the `fadeDuration`, this
            method will allow it to complete the existing fade rather than starting a slower one.
            <para></para>
            If the layer currently has 0 <see cref="P:Animancer.AnimancerNode.Weight"/>, this method will fade in the layer itself
            and simply <see cref="M:Animancer.AnimancerState.Play"/> the `state`.
            <para></para>
            This method is safe to call repeatedly without checking whether the animation was already playing.
            <para></para>
            <em>Animancer Lite only allows the default `fadeDuration` (0.25 seconds) in runtime builds.</em>
            </remarks>
            <exception cref="T:System.ArgumentNullException">The `key` is null.</exception>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetLocalLayer(Animancer.AnimancerState)">
            <summary>
            Returns the <see cref="P:Animancer.AnimancerNode.Layer"/> if the <see cref="P:Animancer.AnimancerNode.Root"/> is this.
            Otherwise returns the first layer in this graph.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Stop(Animancer.IHasKey)">
            <summary>
            Gets the state registered with the <see cref="P:Animancer.IHasKey.Key"/>, stops and rewinds it to the start, then
            returns it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Stop(System.Object)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerState.Stop"/> on the state registered with the `key` to stop it from playing and
            rewind it to the start.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Stop">
            <summary>
            Calls <see cref="M:Animancer.AnimancerState.Stop"/> on all animations to stop them from playing and rewind them to the
            start.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlaying(Animancer.IHasKey)">
            <summary>Is a state registered with the <see cref="P:Animancer.IHasKey.Key"/> and currently playing?</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlaying(System.Object)">
            <summary>Is a state registered with the `key` and currently playing?</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlaying">
            <summary>Is least one animation being played?</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlayingClip(UnityEngine.AnimationClip)">
            <summary>
            Returns true if the `clip` is currently being played by at least one state in the specified layer.
            <para></para>
            This method is inefficient because it searches through every state to find any that are playing the `clip`,
            unlike <see cref="M:Animancer.AnimancerPlayable.IsPlaying(System.Object)"/> which only checks the state registered using the specified key.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetTotalWeight">
            <summary>Calculates the total <see cref="P:Animancer.AnimancerNode.Weight"/> of all states in all layers.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>] Gathers all the animations in all layers.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.System#Collections#IEnumerator#MoveNext">
            <summary>Are any animations playing?</summary>
            <remarks>This allows this object to be used as a custom yield instruction.</remarks>
        </member>
        <member name="P:Animancer.AnimancerPlayable.System#Collections#IEnumerator#Current">
            <summary>Returns null.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.System#Collections#IEnumerator#Reset">
            <summary>Does nothing.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Stop(Animancer.AnimancerState)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            Just call <see cref="M:Animancer.AnimancerState.Stop"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsPlaying(Animancer.AnimancerState)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            Just check <see cref="P:Animancer.AnimancerState.IsPlaying"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.IsGraphPlaying">
            <summary>Indicates whether the <see cref="T:UnityEngine.Playables.PlayableGraph"/> is currently playing.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.UnpauseGraph">
            <summary>
            Resumes playing the <see cref="T:UnityEngine.Playables.PlayableGraph"/> if <see cref="M:Animancer.AnimancerPlayable.PauseGraph"/> was called previously.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.PauseGraph">
            <summary>
            Freezes the <see cref="T:UnityEngine.Playables.PlayableGraph"/> at its current state.
            <para></para>
            If you call this method, you are responsible for calling <see cref="M:Animancer.AnimancerPlayable.UnpauseGraph"/> to resume playing.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Evaluate">
            <summary>
            Evaluates all of the currently playing animations to apply their states to the animated objects.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.Evaluate(System.Single)">
            <summary>
            Advances all currently playing animations by the specified amount of time (in seconds) and evaluates the
            graph to apply their states to the animated objects.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetDescription">
            <summary>Returns a detailed descrption of all currently playing states and other registered states.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.AppendDescription(System.Text.StringBuilder)">
            <summary>Appends a detailed descrption of all currently playing states and other registered states.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.AppendInternalDetails(System.Text.StringBuilder,System.String,System.String)">
            <summary>Appends all registered <see cref="T:Animancer.IUpdatable"/>s and <see cref="T:System.IDisposable"/>s.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.RequirePreUpdate(Animancer.IUpdatable)">
            <summary>[Pro-Only]
            Adds the `updatable` to the list that need to be updated before the playables if it was not there already.
            </summary>
            <remarks>
            This method is safe to call at any time, even during an update.
            <para></para>
            The execution order is non-deterministic. Specifically, the most recently added will be updated first and
            <see cref="M:Animancer.AnimancerPlayable.CancelPreUpdate(Animancer.IUpdatable)"/> will change the order by swapping the last one into the place of the removed
            object.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.RequirePostUpdate(Animancer.IUpdatable)">
            <summary>[Pro-Only]
            Adds the `updatable` to the list that need to be updated after the playables if it was not there already.
            </summary>
            <remarks>
            This method is safe to call at any time, even during an update.
            <para></para>
            The execution order is non-deterministic. Specifically, the most recently added will be updated first and
            <see cref="M:Animancer.AnimancerPlayable.CancelPostUpdate(Animancer.IUpdatable)"/> will change the order by swapping the last one into the place of the removed
            object.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.CancelUpdate(Animancer.Key.KeyedList{Animancer.IUpdatable},Animancer.IUpdatable)">
            <summary>Removes the `updatable` from the `updatables`.</summary>
            <remarks>
            This method is safe to call at any time, even during an update.
            <para></para>
            The last element is swapped into the place of the one being removed so that the rest of them do not need to
            be moved down one place to fill the gap. This is more efficient, but means that the update order can change.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.CancelPreUpdate(Animancer.IUpdatable)">
            <summary>Removes the `updatable` from the list of objects that need to be updated before the playables.</summary>
            <remarks>
            This method is safe to call at any time, even during an update.
            <para></para>
            The last element is swapped into the place of the one being removed so that the rest of them do not need to
            be moved down one place to fill the gap. This is more efficient, but means that the update order can change.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.CancelPostUpdate(Animancer.IUpdatable)">
            <summary>Removes the `updatable` from the list of objects that need to be updated after the playebles.</summary>
            <remarks>
            This method is safe to call at any time, even during an update.
            <para></para>
            The last element is swapped into the place of the one being removed so that the rest of them do not need to
            be moved down one place to fill the gap. This is more efficient, but means that the update order can change.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerPlayable.PreUpdatableCount">
            <summary>The number of objects that have been registered by <see cref="M:Animancer.AnimancerPlayable.RequirePreUpdate(Animancer.IUpdatable)"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.PostUpdatableCount">
            <summary>The number of objects that have been registered by <see cref="M:Animancer.AnimancerPlayable.RequirePostUpdate(Animancer.IUpdatable)"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetPreUpdatable(System.Int32)">
            <summary>Returns the object registered by <see cref="M:Animancer.AnimancerPlayable.RequirePreUpdate(Animancer.IUpdatable)"/> at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.GetPostUpdatable(System.Int32)">
            <summary>Returns the object registered by <see cref="M:Animancer.AnimancerPlayable.RequirePostUpdate(Animancer.IUpdatable)"/> at the specified `index`.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.Current">
            <summary>The object currently executing <see cref="M:Animancer.AnimancerPlayable.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.DeltaTime">
            <summary>The current <see cref="P:UnityEngine.Playables.FrameData.deltaTime"/>.</summary>
            <remarks>After <see cref="M:Animancer.AnimancerPlayable.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)"/>, this property will be left at its most recent value.</remarks>
        </member>
        <member name="P:Animancer.AnimancerPlayable.FrameID">
            <summary>The current <see cref="P:UnityEngine.Playables.FrameData.frameId"/>.</summary>
            <remarks>
            After <see cref="M:Animancer.AnimancerPlayable.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)"/>, this property will be left at its most recent value.
            <para></para>
            <see cref="P:Animancer.AnimancerState.Time"/> uses this value to determine whether it has accessed the playable's time
            since it was last updated in order to cache its value.
            </remarks>
        </member>
        <member name="F:Animancer.AnimancerPlayable._CurrentUpdatables">
            <summary>The list <see cref="T:Animancer.IUpdatable"/>s currently being updated.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable._CurrentUpdatable">
            <summary>The index of the <see cref="T:Animancer.IUpdatable"/> currently being updated.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)">
            <summary>[Internal]
            Calls <see cref="M:Animancer.IUpdatable.Update"/> on everything registered using <see cref="M:Animancer.AnimancerPlayable.RequirePreUpdate(Animancer.IUpdatable)"/>.
            </summary>
            <remarks>
            Called by the <see cref="T:UnityEngine.Playables.PlayableGraph"/> before the rest of the <see cref="T:UnityEngine.Playables.Playable"/>s are evaluated.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.UpdateAll(Animancer.Key.KeyedList{Animancer.IUpdatable},System.Single)">
            <summary>Calls <see cref="M:Animancer.IUpdatable.Update"/> on each of the updatables`.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.IsRunningPostUpdate(Animancer.AnimancerPlayable)">
            <summary>Indicates whether the internal <see cref="T:Animancer.AnimancerPlayable.PostUpdate"/> is currently executing.</summary>
        </member>
        <member name="T:Animancer.AnimancerPlayable.PostUpdate">
            <summary>
            A <see cref="T:UnityEngine.Playables.PlayableBehaviour"/> which connects to a later port than the main layer mixer so that its
            <see cref="M:Animancer.AnimancerPlayable.PostUpdate.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)"/> method gets called after all other playables are updated in order to call
            <see cref="M:Animancer.IUpdatable.Update"/> on the <see cref="F:Animancer.AnimancerPlayable._PostUpdatables"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.PostUpdate.Template">
            <summary>See <see cref="F:Animancer.AnimancerPlayable.Template"/>.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.PostUpdate._Root">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> this behaviour is connected to.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.PostUpdate._Playable">
            <summary>The underlying <see cref="T:UnityEngine.Playables.Playable"/> of this behaviour.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.PostUpdate.Create(Animancer.AnimancerPlayable)">
            <summary>Creates a new <see cref="T:Animancer.AnimancerPlayable.PostUpdate"/> for the `root`.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.PostUpdate.OnPlayableCreate(UnityEngine.Playables.Playable)">
            <summary>[Internal] Called by Unity when it creates this <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.PostUpdate.IsConnected">
            <summary>
            Indicates whether this behaviour is connected to the <see cref="T:UnityEngine.Playables.PlayableGraph"/> and thus, whether it
            will receive <see cref="M:Animancer.AnimancerPlayable.PostUpdate.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)"/> calls.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.PostUpdate.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)">
            <summary>[Internal]
            Calls <see cref="M:Animancer.IUpdatable.Update"/> on everything registered using <see cref="M:Animancer.AnimancerPlayable.RequirePostUpdate(Animancer.IUpdatable)"/>.
            </summary>
            <remarks>
            Called by the <see cref="T:UnityEngine.Playables.PlayableGraph"/> after the rest of the <see cref="T:UnityEngine.Playables.Playable"/>s are evaluated.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.RegisterInstance">
            <summary>[Editor-Only]
            Registers this object in the list of things that need to be cleaned up in Edit Mode.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.ShouldStayAlive">
            <summary>Should this playable should stay alive instead of being destroyed?</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.HasChangedToOrFromAnimatePhysics(System.Nullable{UnityEngine.AnimatorUpdateMode},UnityEngine.AnimatorUpdateMode)">
            <summary>[Editor-Only]
            Returns true if the `initial` mode was <see cref="F:UnityEngine.AnimatorUpdateMode.AnimatePhysics"/> and the `current`
            has changed to another mode or if the `initial` mode was something else and the `current` has changed to
            <see cref="F:UnityEngine.AnimatorUpdateMode.AnimatePhysics"/>.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerPlayable.LayerList">
            <summary>A list of <see cref="T:Animancer.AnimancerLayer"/>s with methods to control their mixing and masking.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/blending/layers">Layers</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/LayerList
            
        </member>
        <member name="F:Animancer.AnimancerPlayable.LayerList.Root">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> at the root of the graph.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LayerList._Layers">
            <summary>[Internal] The layers which each manage their own set of animations.</summary>
            <remarks>This field should never be null so it shouldn't need null-checking.</remarks>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LayerList.LayerMixer">
            <summary>The <see cref="T:UnityEngine.Animations.AnimationLayerMixerPlayable"/> which blends the layers.</summary>
        </member>
        <member name="F:Animancer.AnimancerPlayable.LayerList._Count">
            <summary>The number of layers that have actually been created.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.#ctor(Animancer.AnimancerPlayable)">
            <summary>Creates a new <see cref="T:Animancer.AnimancerPlayable.LayerList"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.#ctor(Animancer.AnimancerPlayable,UnityEngine.Playables.Playable@)">
            <summary>[Internal]
            Creates a new <see cref="T:Animancer.AnimancerPlayable.LayerList"/> with an <see cref="T:UnityEngine.Animations.AnimationLayerMixerPlayable"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.Activate(Animancer.AnimancerPlayable)">
            <summary>[Pro-Only]
            Sets the <see cref="P:Animancer.AnimancerPlayable.Layers"/> and assigns the main <see cref="T:UnityEngine.Playables.Playable"/> of this list.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.Activate(Animancer.AnimancerPlayable,UnityEngine.Playables.Playable)">
            <summary>[Pro-Only]
            Sets this list as the <see cref="P:Animancer.AnimancerPlayable.Layers"/> and the <see cref="T:UnityEngine.Playables.Playable"/> used to mix them.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.LayerList.Count">
            <summary>[Pro-Only] The number of layers in this list.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The value is set higher than the <see cref="P:Animancer.AnimancerPlayable.LayerList.DefaultCapacity"/>. This is simply a safety measure,
            so if you do actually need more layers you can just increase the limit.
            </exception>
            <exception cref="T:System.IndexOutOfRangeException">The value is set to a negative number.</exception>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.SetMinCount(System.Int32)">
            <summary>[Pro-Only]
            If the <see cref="P:Animancer.AnimancerPlayable.LayerList.Count"/> is below the specified `min`, this method increases it to that value.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.LayerList.DefaultCapacity">
            <summary>[Pro-Only]
            The maximum number of layers that can be created before an <see cref="T:System.ArgumentOutOfRangeException"/> will
            be thrown (default 4).
            <para></para>
            Lowering this value will not affect layers that have already been created.
            </summary>
            <example>
            To set this value automatically when the application starts, place the following method in any class:
            <para></para><code>
            [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
            private static void SetMaxLayerCount()
            {
                Animancer.AnimancerPlayable.LayerList.DefaultCapacity = 8;
            }
            </code>
            Otherwise you can set the <see cref="P:Animancer.AnimancerPlayable.LayerList.Capacity"/> of each individual list:
            <para></para><code>
            AnimancerComponent animancer;
            animancer.Layers.Capacity = 8;
            </code></example>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.SetMinDefaultCapacity(System.Int32)">
            <summary>[Pro-Only]
            If the <see cref="P:Animancer.AnimancerPlayable.LayerList.DefaultCapacity"/> is below the specified `min`, this method increases it to that value.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.LayerList.Capacity">
            <summary>[Pro-Only]
            The maximum number of layers that can be created before an <see cref="T:System.ArgumentOutOfRangeException"/> will
            be thrown. The initial capacity is determined by <see cref="P:Animancer.AnimancerPlayable.LayerList.DefaultCapacity"/>.
            </summary>
            
            <remarks>
            Lowering this value will destroy any layers beyond the specified value.
            <para></para>
            Changing this value will cause the allocation of a new array and garbage collection of the old one, so
            you should generally set the <see cref="P:Animancer.AnimancerPlayable.LayerList.DefaultCapacity"/> before initializing this list.
            </remarks>
            
            <exception cref="T:System.ArgumentOutOfRangeException">The value is not greater than 0.</exception>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.Add">
            <summary>[Pro-Only] Creates and returns a new <see cref="T:Animancer.AnimancerLayer"/> at the end of this list.</summary>
            <remarks>If the <see cref="P:Animancer.AnimancerPlayable.LayerList.Capacity"/> would be exceeded, it will be doubled.</remarks>
        </member>
        <member name="P:Animancer.AnimancerPlayable.LayerList.Item(System.Int32)">
            <summary>Returns the layer at the specified index. If it didn't already exist, this method creates it.</summary>
            <remarks>To only get an existing layer without creating new ones, use <see cref="M:Animancer.AnimancerPlayable.LayerList.GetLayer(System.Int32)"/> instead.</remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.GetLayer(System.Int32)">
            <summary>Returns the layer at the specified index.</summary>
            <remarks>To create a new layer if the target doesn't exist, use <see cref="P:Animancer.AnimancerPlayable.LayerList.Item(System.Int32)"/> instead.</remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.GetEnumerator">
            <summary>Returns an enumerator that will iterate through all layers.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.System#Collections#Generic#IEnumerable{Animancer#AnimancerLayer}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>] Gathers all the animations in all layers.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.IsAdditive(System.Int32)">
            <summary>[Pro-Only]
            Is the layer at the specified index is set to additive blending?
            Otherwise it will override lower layers.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.SetAdditive(System.Int32,System.Boolean)">
            <summary>[Pro-Only]
            Sets the layer at the specified index to blend additively with earlier layers (if true) or to override them
            (if false). Newly created layers will override by default.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.SetMask(System.Int32,UnityEngine.AvatarMask)">
            <summary>[Pro-Only]
            Sets an <see cref="T:UnityEngine.AvatarMask"/> to determine which bones the layer at the specified index will affect.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.LayerList.SetDebugName(System.Int32,System.String)">
            <summary>[Editor-Conditional] Sets the Inspector display name of the layer at the specified index.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.LayerList.AverageVelocity">
            <summary>
            The average velocity of the root motion of all currently playing animations, taking their current
            <see cref="P:Animancer.AnimancerNode.Weight"/> into account.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerPlayable.StateDictionary">
            <summary>A dictionary of <see cref="T:Animancer.AnimancerState"/>s mapped to their <see cref="P:Animancer.AnimancerState.Key"/>.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/playing/states">States</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/StateDictionary
            
        </member>
        <member name="F:Animancer.AnimancerPlayable.StateDictionary.Root">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> at the root of the graph.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.EqualityComparer">
            <summary>The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> used by every new <see cref="T:Animancer.AnimancerPlayable.StateDictionary"/>.</summary>
            <remarks>
            By default, this will use <see cref="F:Animancer.FastComparer.Instance"/>.
            <para></para>
            Setting it to <see cref="F:Animancer.FastReferenceComparer.Instance"/> would make it slightly faster, but would
            not work for value types such as enums.
            <para></para>
            Changing this value will not affect existing instances.
            </remarks>
        </member>
        <member name="F:Animancer.AnimancerPlayable.StateDictionary.States">
            <summary><see cref="P:Animancer.AnimancerState.Key"/> mapped to <see cref="T:Animancer.AnimancerState"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.#ctor(Animancer.AnimancerPlayable)">
            <summary>[Internal] Creates a new <see cref="T:Animancer.AnimancerPlayable.StateDictionary"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Count">
            <summary>The number of states that have been registered with a <see cref="P:Animancer.AnimancerState.Key"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Create(UnityEngine.AnimationClip)">
            <summary>Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the `clip`.</summary>
            <remarks>
            To create a state on a specific layer, use <c>animancer.Layers[x].CreateState(clip)</c> instead.
            <para></para>
            <see cref="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)"/> is used to determine the <see cref="P:Animancer.AnimancerState.Key"/>.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Create(System.Object,UnityEngine.AnimationClip)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the `clip` and registers it with the `key`.
            </summary>
            <remarks>
            To create a state on a specific layer, use <c>animancer.Layers[x].CreateState(key, clip)</c> instead.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.CreateIfNew(UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.CreateIfNew(UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.CreateIfNew(UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified clips.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.CreateIfNew(UnityEngine.AnimationClip[])">
            <summary>Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(UnityEngine.AnimationClip,System.Boolean)"/> for each of the specified `clips`.</summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Current">
            <summary>
            The <see cref="P:Animancer.AnimancerLayer.CurrentState"/> on layer 0.
            <para></para>
            Specifically, this is the state that was most recently started using any of the Play methods on that layer.
            States controlled individually via methods in the <see cref="T:Animancer.AnimancerState"/> itself will not register in
            this property.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Item(UnityEngine.AnimationClip)">
            <summary>Calls <see cref="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)"/> then returns the state registered with that key.</summary>
            <exception cref="T:System.ArgumentNullException">The key is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">No state is registered with the key.</exception>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Item(Animancer.IHasKey)">
            <summary>Returns the state registered with the <see cref="P:Animancer.IHasKey.Key"/>.</summary>
            <exception cref="T:System.ArgumentNullException">The `key` is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">No state is registered with the `key`.</exception>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Item(System.Object)">
            <summary>Returns the state registered with the `key`.</summary>
            <exception cref="T:System.ArgumentNullException">The `key` is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">No state is registered with the `key`.</exception>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(UnityEngine.AnimationClip,Animancer.AnimancerState@)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)"/> then passes the key to
            <see cref="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(System.Object,Animancer.AnimancerState@)"/> and returns the result.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(Animancer.IHasKey,Animancer.AnimancerState@)">
            <summary>
            Passes the <see cref="P:Animancer.IHasKey.Key"/> into <see cref="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(System.Object,Animancer.AnimancerState@)"/>
            and returns the result.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(System.Object,Animancer.AnimancerState@)">
            <summary>
            If a `state` is registered with the `key`, this method outputs it and returns true. Otherwise the
            `state` is set to null and this method returns false.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(UnityEngine.AnimationClip,System.Boolean)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.GetKey(UnityEngine.AnimationClip)"/> and returns the state which registered with that key or creates one if it
            doesn't exist.
            <para></para>
            If the state already exists but has the wrong <see cref="P:Animancer.AnimancerState.Clip"/>, the `allowSetClip`
            parameter determines what will happen. False causes it to throw an <see cref="T:System.ArgumentException"/> while
            true allows it to change the <see cref="P:Animancer.AnimancerState.Clip"/>. Note that the change is somewhat costly to
            performance so use with caution.
            </summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(Animancer.ITransition)">
            <summary>
            Returns the state registered with the `transition`s <see cref="P:Animancer.IHasKey.Key"/> if there is one. Otherwise
            this method uses <see cref="M:Animancer.ITransition.CreateState"/> to create a new one and registers it with
            that key before returning it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(System.Object,UnityEngine.AnimationClip,System.Boolean)">
            <summary>
            Returns the state which registered with the `key` or creates one if it doesn't exist.
            <para></para>
            If the state already exists but has the wrong <see cref="P:Animancer.AnimancerState.Clip"/>, the `allowSetClip`
            parameter determines what will happen. False causes it to throw an <see cref="T:System.ArgumentException"/> while
            true allows it to change the <see cref="P:Animancer.AnimancerState.Clip"/>. Note that the change is somewhat costly to
            performance to use with caution.
            </summary>
            <exception cref="T:System.ArgumentException"/>
            <remarks>See also: <see cref="M:Animancer.AnimancerLayer.GetOrCreateState(System.Object,UnityEngine.AnimationClip,System.Boolean)"/></remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GetClipMismatchError(System.Object,UnityEngine.AnimationClip,UnityEngine.AnimationClip)">
            <summary>Returns an error message explaining that a state already exists with the specified `key`.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Register(Animancer.AnimancerState)">
            <summary>[Internal]
            Registers the `state` in this dictionary so the <see cref="P:Animancer.AnimancerState.Key"/> can be used to get it
            later on using any of the lookup methods such as <see cref="P:Animancer.AnimancerPlayable.StateDictionary.Item(System.Object)"/> or
            <see cref="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(System.Object,Animancer.AnimancerState@)"/>.
            </summary>
            <remarks>Does nothing if the <see cref="P:Animancer.AnimancerState.Key"/> is <c>null</c>.</remarks>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Unregister(Animancer.AnimancerState)">
            <summary>[Internal] Removes the `state` from this dictionary (the opposite of <see cref="M:Animancer.AnimancerPlayable.StateDictionary.Register(Animancer.AnimancerState)"/>).</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GetEnumerator">
            <summary>Returns an enumerator that will iterate through all registered states.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.System#Collections#Generic#IEnumerable{Animancer#AnimancerState}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>]
            Adds all the animations of states with a <see cref="P:Animancer.AnimancerState.Key"/> to the `clips`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(UnityEngine.AnimationClip)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerState.Destroy"/> on the state associated with the `clip` (if any).
            Returns true if the state existed.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(Animancer.IHasKey)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerState.Destroy"/> on the state associated with the <see cref="P:Animancer.IHasKey.Key"/>
            (if any). Returns true if the state existed.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(System.Object)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerState.Destroy"/> on the state associated with the `key` (if any).
            Returns true if the state existed.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.DestroyAll(System.Collections.Generic.IList{UnityEngine.AnimationClip})">
            <summary>Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(UnityEngine.AnimationClip)"/> on each of the `clips`.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.DestroyAll(System.Collections.Generic.IEnumerable{UnityEngine.AnimationClip})">
            <summary>Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(UnityEngine.AnimationClip)"/> on each of the `clips`.</summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.DestroyAll(UnityEngine.IAnimationClipSource)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(UnityEngine.AnimationClip)"/> on all states gathered by
            <see cref="M:UnityEngine.IAnimationClipSource.GetAnimationClips(System.Collections.Generic.List{UnityEngine.AnimationClip})"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.DestroyAll(Animancer.IAnimationClipCollection)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(UnityEngine.AnimationClip)"/> on all states gathered by
            <see cref="M:Animancer.IAnimationClipCollection.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerPlayable.StateDictionary.Item(Animancer.AnimancerState)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            The whole point of a key is to identify a state in the first place.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.TryGet(Animancer.AnimancerState,Animancer.AnimancerState@)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            The whole point of a key is to identify a state in the first place.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.GetOrCreate(Animancer.AnimancerState,UnityEngine.AnimationClip)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            The whole point of a key is to identify a state in the first place.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerPlayable.StateDictionary.Destroy(Animancer.AnimancerState)">
            <summary>[Warning]
            You should not use an <see cref="T:Animancer.AnimancerState"/> as a key.
            Just call <see cref="M:Animancer.AnimancerState.Destroy"/>.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerState">
            <summary>
            Base class for all states in an <see cref="T:Animancer.AnimancerPlayable"/> graph which manages one or more
            <see cref="T:UnityEngine.Playables.Playable"/>s.
            </summary>
            
            <remarks>
            This class can be used as a custom yield instruction to wait until the animation either stops playing or
            reaches its end.
            <para></para>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/playing/states">States</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/AnimancerState
            
            https://kybernetik.com.au/animancer/api/Animancer/AnimancerState
            https://kybernetik.com.au/animancer/api/Animancer/AnimancerState
        </member>
        <member name="M:Animancer.AnimancerState.SetRoot(Animancer.AnimancerPlayable)">
            <summary>The <see cref="T:Animancer.AnimancerPlayable"/> at the root of the graph.</summary>
            <exception cref="T:System.InvalidOperationException">
            The <see cref="P:Animancer.AnimancerState.Parent"/> has a different <see cref="P:Animancer.AnimancerNode.Root"/>.
            Setting the <see cref="P:Animancer.AnimancerState.Parent"/>'s <see cref="P:Animancer.AnimancerNode.Root"/> will apply to its children recursively
            because they must always match.
            </exception>
        </member>
        <member name="P:Animancer.AnimancerState.Parent">
            <summary>The object which receives the output of the <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.SetParent(Animancer.AnimancerNode,System.Int32)">
            <summary>Connects this state to the `parent` state at the specified `index`.</summary>
            <remarks>
            If the `parent` is null, this state will be disconnected from everything.
            <para></para>
            Use <see cref="M:Animancer.AnimancerLayer.AddChild(Animancer.AnimancerState)"/> instead of this method to connect to a layer.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerState.SetParentInternal(Animancer.AnimancerNode,System.Int32)">
            <summary>[Internal] Directly sets the <see cref="P:Animancer.AnimancerState.Parent"/> without triggering any other connection methods.</summary>
        </member>
        <member name="P:Animancer.AnimancerState.Layer">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.AnimancerState.LayerIndex">
            <summary>
            The index of the <see cref="T:Animancer.AnimancerLayer"/> this state is connected to (determined by the
            <see cref="P:Animancer.AnimancerState.Parent"/>). Returns <c>-1</c> if this state is not connected to a layer.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Key">
            <summary>
            The object used to identify this state in the root <see cref="P:Animancer.AnimancerPlayable.States"/> dictionary.
            Can be null.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Clip">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> which this state plays (if any).</summary>
            <exception cref="T:System.NotSupportedException">This state type doesn't have a clip and you try to set it.</exception>
        </member>
        <member name="P:Animancer.AnimancerState.MainObject">
            <summary>The main object to show in the Inspector for this state (if any).</summary>
            <exception cref="T:System.NotSupportedException">This state type doesn't have a main object and you try to set it.</exception>
            <exception cref="T:System.InvalidCastException">This state can't use the assigned value.</exception>
        </member>
        <member name="M:Animancer.AnimancerState.ChangeMainObject``1(``0@,``0)">
            <summary>
            Sets the `currentObject` and calls <see cref="M:Animancer.AnimancerNode.RecreatePlayable"/>. If the `currentObject` was
            being used as the <see cref="P:Animancer.AnimancerState.Key"/> then it is changed as well.
            </summary>
            <exception cref="T:System.ArgumentNullException">The `newObject` is null.</exception>
        </member>
        <member name="P:Animancer.AnimancerState.AverageVelocity">
            <summary>The average velocity of the root motion caused by this state.</summary>
        </member>
        <member name="F:Animancer.AnimancerState._IsPlaying">
            <summary>Is the <see cref="P:Animancer.AnimancerState.Time"/> automatically advancing?</summary>
        </member>
        <member name="F:Animancer.AnimancerState._IsPlayingDirty">
            <summary>Has <see cref="F:Animancer.AnimancerState._IsPlaying"/> changed since it was last applied to the <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
            <remarks>
            Playables start playing by default so we start dirty to pause it during the first update (unless
            <see cref="P:Animancer.AnimancerState.IsPlaying"/> is set to true before that).
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.IsPlaying">
             <summary>Is the <see cref="P:Animancer.AnimancerState.Time"/> automatically advancing?</summary>
            
             <example><code>
             void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.States.GetOrCreate(clip);
            
                 if (state.IsPlaying)
                     Debug.Log(clip + " is playing");
                 else
                     Debug.Log(clip + " is paused");
            
                 state.IsPlaying = false;// Pause the animation.
            
                 state.IsPlaying = true;// Unpause the animation.
             }
             </code></example>
        </member>
        <member name="M:Animancer.AnimancerState.OnSetIsPlaying">
            <summary>Called when the value of <see cref="P:Animancer.AnimancerState.IsPlaying"/> is changed.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.CreatePlayable">
            <summary>Creates and assigns the <see cref="T:UnityEngine.Playables.Playable"/> managed by this state.</summary>
            <remarks>This method also applies the <see cref="P:Animancer.AnimancerNode.Speed"/> and <see cref="P:Animancer.AnimancerState.IsPlaying"/>.</remarks>
        </member>
        <member name="P:Animancer.AnimancerState.IsActive">
            <summary>
            Returns true if this state is playing and is at or fading towards a non-zero
            <see cref="P:Animancer.AnimancerNode.Weight"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.IsStopped">
            <summary>
            Returns true if this state isn't playing and is at 0 <see cref="P:Animancer.AnimancerNode.Weight"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.Play">
            <summary>
            Plays this state immediately, without any blending.
            <para></para>
            Unlike <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.AnimancerState)"/>, this method only affects this state and won't
            stop any others that are playing.
            </summary>
            <remarks>
            Sets <see cref="P:Animancer.AnimancerState.IsPlaying"/> = true, <see cref="P:Animancer.AnimancerNode.Weight"/> = 1, and clears the
            <see cref="P:Animancer.AnimancerState.Events"/> (unless <see cref="P:Animancer.AnimancerState.AutomaticallyClearEvents"/> is disabled).
            <para></para>
            Doesn't change the <see cref="P:Animancer.AnimancerState.Time"/> so it will continue from its current value.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerState.Stop">
            <summary>Stops the animation and makes it inactive immediately so it no longer affects the output.</summary>
            <remarks>
            Sets <see cref="P:Animancer.AnimancerNode.Weight"/> = 0, <see cref="P:Animancer.AnimancerState.IsPlaying"/> = false, <see cref="P:Animancer.AnimancerState.Time"/> = 0, and
            clears the <see cref="P:Animancer.AnimancerState.Events"/> (unless <see cref="P:Animancer.AnimancerState.AutomaticallyClearEvents"/> is disabled).
            <para></para>
            To freeze the animation in place without ending it, you only need to set <see cref="P:Animancer.AnimancerState.IsPlaying"/> = false
            instead. Or to freeze all animations, you can call <see cref="M:Animancer.AnimancerPlayable.PauseGraph"/>.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerState.OnStartFade">
            <summary>
            Called by <see cref="M:Animancer.AnimancerNode.StartFade(System.Single,System.Single)"/>.
            Clears the <see cref="P:Animancer.AnimancerState.Events"/> (unless <see cref="P:Animancer.AnimancerState.AutomaticallyClearEvents"/> is disabled).
            </summary>
        </member>
        <member name="F:Animancer.AnimancerState._Time">
            <summary>
            The current time of the <see cref="T:UnityEngine.Playables.Playable"/>, retrieved by <see cref="P:Animancer.AnimancerState.Time"/> whenever the
            <see cref="F:Animancer.AnimancerState._TimeFrameID"/> is different from the <see cref="P:Animancer.AnimancerPlayable.FrameID"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerState._MustSetTime">
            <summary>
            Indicates whether the <see cref="F:Animancer.AnimancerState._Time"/> needs to be assigned to the <see cref="T:UnityEngine.Playables.Playable"/> next update.
            </summary>
            <remarks>
            <see cref="T:Animancer.AnimancerState.EventDispatcher"/> executes after all other playables, at which point changes can still be made to
            their time but not their weight which means that if we set the time immediately then it can be out of sync
            with the weight. For example, if an animation ends and you play another, the first animation would be
            stopped and rewinded to the start but would still be at full weight so it would show its first frame before
            the new animation actually takes effect (even if the previous animation was not looping).
            <para></para>
            So instead, we simply delay setting the actual playable time until the next update so that time and weight
            are always in sync.
            </remarks>
        </member>
        <member name="F:Animancer.AnimancerState._TimeFrameID">
            <summary>
            The <see cref="P:Animancer.AnimancerPlayable.FrameID"/> from when the <see cref="P:Animancer.AnimancerState.Time"/> was last retrieved from the
            <see cref="T:UnityEngine.Playables.Playable"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.Time">
             <summary>The number of seconds that have passed since the start of this animation.</summary>
            
             <remarks>
             This value will continue increasing after the animation passes the end of its <see cref="P:Animancer.AnimancerState.Length"/> while
             the animated object either freezes in place or starts again from the beginning according to whether it is
             looping or not.
             <para></para>
             Events and root motion between the old and new time will be skipped when setting this value. Use
             <see cref="M:Animancer.AnimancerState.MoveTime(System.Single,System.Boolean)"/> instead if you don't want that behaviour.
             <para></para>
             This property internally uses <see cref="P:Animancer.AnimancerState.RawTime"/> whenever the value is out of date or gets changed.
             <para></para>
             <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em>
             </remarks>
            
             <example><code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 // Skip 0.5 seconds into the animation:
                 state.Time = 0.5f;
            
                 // Skip 50% of the way through the animation (0.5 in a range of 0 to 1):
                 state.NormalizedTime = 0.5f;
            
                 // Skip to the end of the animation and play backwards.
                 state.NormalizedTime = 1;
                 state.Speed = -1;
             }
             </code></example>
        </member>
        <member name="P:Animancer.AnimancerState.TimeD">
            <summary>The underlying <see cref="T:System.Double"/> value of <see cref="P:Animancer.AnimancerState.Time"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerState.RawTime">
            <summary>
            The internal implementation of <see cref="P:Animancer.AnimancerState.Time"/> which directly gets and sets the underlying value.
            </summary>
            <remarks>
            Setting this value actually calls <see cref="M:UnityEngine.Playables.PlayableExtensions.SetTime``1(``0,System.Double)"/> twice to ensure that animation
            events aren't triggered incorrectly. Calling it only once would trigger any animation events between the
            previous time and the new time. So if an animation plays to the end and you set the time back to 0 (such as
            by calling <see cref="M:Animancer.AnimancerState.Stop"/> or playing a different animation), the next time that animation played it
            would immediately trigger all of its events, then play through and trigger them normally as well.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.NormalizedTime">
             <summary>
             The <see cref="P:Animancer.AnimancerState.Time"/> of this state as a portion of the animation's <see cref="P:Animancer.AnimancerState.Length"/>, meaning the
             value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes.
             </summary>
             
             <remarks>
             This value will continue increasing after the animation passes the end of its <see cref="P:Animancer.AnimancerState.Length"/> while
             the animated object either freezes in place or starts again from the beginning according to whether it is
             looping or not.
             <para></para>
             The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the
             current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has
             been looped.
             <para></para>
             Events and root motion between the old and new time will be skipped when setting this value. Use
             <see cref="M:Animancer.AnimancerState.MoveTime(System.Single,System.Boolean)"/> instead if you don't want that behaviour.
             <para></para>
             <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em>
             </remarks>
            
             <example><code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 // Skip 0.5 seconds into the animation:
                 state.Time = 0.5f;
            
                 // Skip 50% of the way through the animation (0.5 in a range of 0 to 1):
                 state.NormalizedTime = 0.5f;
            
                 // Skip to the end of the animation and play backwards.
                 state.NormalizedTime = 1;
                 state.Speed = -1;
             }
             </code></example>
        </member>
        <member name="P:Animancer.AnimancerState.NormalizedTimeD">
            <summary>The underlying <see cref="T:System.Double"/> value of <see cref="P:Animancer.AnimancerState.NormalizedTime"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.MoveTime(System.Single,System.Boolean)">
            <summary>
            Sets the <see cref="P:Animancer.AnimancerState.Time"/> or <see cref="P:Animancer.AnimancerState.NormalizedTime"/>, but unlike those properties this method
            applies any Root Motion and Animation Events (but not Animancer Events) between the old and new time.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.MoveTime(System.Double,System.Boolean)">
            <summary>
            Sets the <see cref="P:Animancer.AnimancerState.Time"/> or <see cref="P:Animancer.AnimancerState.NormalizedTime"/>, but unlike those properties this method
            applies any Root Motion and Animation Events (but not Animancer Events) between the old and new time.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.CancelSetTime">
            <summary>Prevents the <see cref="P:Animancer.AnimancerState.RawTime"/> from being applied.</summary>
        </member>
        <member name="P:Animancer.AnimancerState.NormalizedEndTime">
            <summary>[Pro-Only]
            The <see cref="P:Animancer.AnimancerState.NormalizedTime"/> after which the <see cref="P:Animancer.AnimancerEvent.Sequence.OnEnd"/> callback will
            be invoked every frame.
            </summary>
            <remarks>
            This is a wrapper around <see cref="P:Animancer.AnimancerEvent.Sequence.NormalizedEndTime"/> so that if the value has
            not been set (<see cref="F:System.Single.NaN"/>) it can be determined based on the
            <see cref="P:Animancer.AnimancerNode.EffectiveSpeed"/>: positive speed ends at 1 and negative speed ends at 0.
            <para></para>
            <em>Animancer Lite does not allow this value to be changed in runtime builds.</em>
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.Duration">
             <summary>
             The number of seconds the animation will take to play fully at its current
             <see cref="P:Animancer.AnimancerNode.EffectiveSpeed"/>.
             </summary>
             
             <remarks>
             For the time remaining from now until it reaches the end, use <see cref="P:Animancer.AnimancerState.RemainingDuration"/> instead.
             <para></para>
             Setting this value modifies the <see cref="P:Animancer.AnimancerNode.EffectiveSpeed"/>, not the <see cref="P:Animancer.AnimancerState.Length"/>.
             <para></para>
             <em>Animancer Lite does not allow this value to be changed in runtime builds.</em>
             </remarks>
            
             <example><code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 state.Duration = 1;// Play fully in 1 second.
                 state.Duration = 2;// Play fully in 2 seconds.
                 state.Duration = 0.5f;// Play fully in half a second.
                 state.Duration = -1;// Play backwards fully in 1 second.
                 state.NormalizedTime = 1; state.Duration = -1;// Play backwards from the end in 1 second.
             }
             </code></example>
        </member>
        <member name="P:Animancer.AnimancerState.RemainingDuration">
             <summary>
             The number of seconds this state will take to go from its current <see cref="P:Animancer.AnimancerState.NormalizedTime"/> to the
             <see cref="P:Animancer.AnimancerState.NormalizedEndTime"/> at its current <see cref="P:Animancer.AnimancerNode.EffectiveSpeed"/>.
             </summary>
             
             <remarks>
             For the time it would take to play fully from the start, use the <see cref="P:Animancer.AnimancerState.Duration"/> instead.
             <para></para>
             Setting this value modifies the <see cref="P:Animancer.AnimancerNode.EffectiveSpeed"/>, not the <see cref="P:Animancer.AnimancerState.Length"/>.
             <para></para>
             <em>Animancer Lite does not allow this value to be changed in runtime builds.</em>
             </remarks>
            
             <example><code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 state.RemainingDuration = 1;// Play from the current time to the end in 1 second.
                 state.RemainingDuration = 2;// Play from the current time to the end in 2 seconds.
                 state.RemainingDuration = 0.5f;// Play from the current time to the end in half a second.
                 state.RemainingDuration = -1;// Play from the current time away from the end.
             }
             </code></example>
        </member>
        <member name="P:Animancer.AnimancerState.Length">
            <summary>The total time this state would take to play in seconds when <see cref="P:Animancer.AnimancerNode.Speed"/> = 1.</summary>
        </member>
        <member name="P:Animancer.AnimancerState.IsLooping">
            <summary>Will this state loop back to the start when it reaches the end?</summary>
        </member>
        <member name="M:Animancer.AnimancerState.Update(System.Boolean@)">
            <summary>
            Updates the <see cref="P:Animancer.AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent
            mixer, and plays or pauses the <see cref="T:UnityEngine.Playables.Playable"/> if its state is dirty.
            </summary>
            <remarks>
            If the <see cref="P:Animancer.AnimancerState.Parent"/>'s <see cref="P:Animancer.AnimancerNode.KeepChildrenConnected"/> is set to false, this
            method will also connect/disconnect this node from the <see cref="P:Animancer.AnimancerState.Parent"/> in the playable graph.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerState.Destroy">
            <summary>Destroys the <see cref="T:UnityEngine.Playables.Playable"/> and cleans up this state.</summary>
            <remarks>
            This method is NOT called automatically, so when implementing a custom state type you must use
            <see cref="P:Animancer.AnimancerPlayable.Disposables"/> if you need to guarantee that things will get cleaned up.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerState.Clone">
            <summary>Creates a copy of this state with the same <see cref="P:Animancer.AnimancerNode.Root"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.Clone(Animancer.AnimancerPlayable)">
            <summary>Creates a copy of this state with the specified <see cref="P:Animancer.AnimancerNode.Root"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.SetNewCloneRoot(Animancer.AnimancerPlayable)">
            <summary>Sets the <see cref="P:Animancer.AnimancerNode.Root"/>.</summary>
            <remarks>
            This method skips several steps of <see cref="M:Animancer.AnimancerState.SetRoot(Animancer.AnimancerPlayable)"/> and is intended to only be called on states
            immediately after their creation.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerState.Animancer#ICopyable{Animancer#AnimancerState}#CopyFrom(Animancer.AnimancerState)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.AnimancerState.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:Animancer.IAnimationClipCollection"/>] Gathers all the animations in this state.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.IsPlayingAndNotEnding">
            <summary>
            Returns true if the animation is playing and has not yet passed the
            <see cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/>.
            </summary>
            <remarks>
            This method is called by <see cref="M:System.Collections.IEnumerator.MoveNext"/> so this object can be used as a custom yield
            instruction to wait until it finishes.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerState.ToString">
            <summary>
            Returns the <see cref="P:Animancer.AnimancerNode.DebugName"/> if one is set, otherwise a string describing the type of this
            state and the name of the <see cref="P:Animancer.AnimancerState.MainObject"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.CreateDrawer">
            <summary>[Editor-Only] Returns a custom drawer for this state.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.AppendDetails(System.Text.StringBuilder,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.AnimancerState.GetPath">
            <summary>Returns the hierarchy path of this state through its <see cref="P:Animancer.AnimancerState.Parent"/>s.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.AppendPath(System.Text.StringBuilder,Animancer.AnimancerNode)">
            <summary>Appends the hierarchy path of this state through its <see cref="P:Animancer.AnimancerState.Parent"/>s.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.AppendPortAndType(System.Text.StringBuilder)">
            <summary>Appends "[Index] -> GetType().Name".</summary>
        </member>
        <member name="T:Animancer.AnimancerState.DelayedPause">
            <summary>
            Uses <see cref="M:Animancer.AnimancerPlayable.RequirePostUpdate(Animancer.IUpdatable)"/> to pause a <see cref="F:Animancer.AnimancerNode._Playable"/>.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.DelayedPause.Root">
            <summary>The <see cref="P:Animancer.AnimancerNode.Root"/>.</summary>
        </member>
        <member name="P:Animancer.AnimancerState.DelayedPause.State">
            <summary>The state that will be paused.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.DelayedPause.Register(Animancer.AnimancerState)">
            <summary>
            Gets a <see cref="T:Animancer.AnimancerState.DelayedPause"/> from the <see cref="T:Animancer.ObjectPool"/> and initializes it for the `state`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.DelayedPause.Update">
            <summary>
            Pauses the <see cref="P:Animancer.AnimancerState.DelayedPause.State"/> if <see cref="P:Animancer.AnimancerState.IsPlaying"/> hasn't been set to true and returns this
            object to the <see cref="T:Animancer.ObjectPool"/>.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerState._EventDispatcher">
            <summary>The <see cref="T:Animancer.IUpdatable"/> that manages the events of this state.</summary>
            <remarks>
            This field is null by default, acquires its reference from an <see cref="T:Animancer.ObjectPool"/> when accessed, and
            if it contains no events at the end of an update it releases the reference back to the pool.
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.Events">
            <summary>
            A list of <see cref="T:Animancer.AnimancerEvent"/>s that will occur while this state plays as well as one that
            specifically defines when this state ends.
            </summary>
            <remarks>
            Accessing this property will acquire a spare <see cref="T:Animancer.AnimancerEvent.Sequence"/> from the
            <see cref="T:Animancer.ObjectPool"/> if none was already assigned. You can use <see cref="P:Animancer.AnimancerState.HasEvents"/> to check
            beforehand.
            <para></para>
            These events will automatically be cleared by <see cref="M:Animancer.AnimancerState.Play"/>, <see cref="M:Animancer.AnimancerState.Stop"/>, and
            <see cref="M:Animancer.AnimancerState.OnStartFade"/> (unless <see cref="P:Animancer.AnimancerState.AutomaticallyClearEvents"/> is disabled).
            <para></para>
            <em>Animancer Lite does not allow the use of events in runtime builds, except for
            <see cref="P:Animancer.AnimancerEvent.Sequence.OnEnd"/>.</em>
            <para></para>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/events/animancer">Animancer Events</see>
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.HasEvents">
            <summary>Does this state have an <see cref="T:Animancer.AnimancerEvent.Sequence"/>?</summary>
            <remarks>Accessing <see cref="P:Animancer.AnimancerState.Events"/> would automatically get one from the <see cref="T:Animancer.ObjectPool"/>.</remarks>
        </member>
        <member name="P:Animancer.AnimancerState.AutomaticallyClearEvents">
            <summary>
            Should the <see cref="P:Animancer.AnimancerState.Events"/> be cleared automatically whenever <see cref="M:Animancer.AnimancerState.Play"/>, <see cref="M:Animancer.AnimancerState.Stop"/>,
            or <see cref="M:Animancer.AnimancerState.OnStartFade"/> are called? Default true.
            </summary>
            <remarks>
            Disabling this property is not usually recommended since it would allow events to continue being triggered
            while a state is fading out. For example, if a <em>Flinch</em> animation interrupts an <em>Attack</em>, you
            probably don't want the <em>Attack</em>'s <em>Hit</em> event to still get triggered while it's fading out.
            <para></para>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/events/animancer#clear-automatically">
            Clear Automatically</see>
            </remarks>
        </member>
        <member name="P:Animancer.AnimancerState.UnsupportedEventsMessage">
            <summary>[Assert-Only]
            Returns <c>null</c> if Animancer Events will work properly on this type of state, or a message explaining
            why they might not work.
            </summary>
        </member>
        <member name="T:Animancer.AnimancerState.EventDispatcher">
            <summary>An <see cref="T:Animancer.IUpdatable"/> which triggers events in an <see cref="T:Animancer.AnimancerEvent.Sequence"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer/EventDispatcher
            
        </member>
        <member name="M:Animancer.AnimancerState.EventDispatcher.Acquire(Animancer.AnimancerState)">
            <summary>
            If the `state` has no <see cref="T:Animancer.AnimancerState.EventDispatcher"/>, this method gets one from the
            <see cref="T:Animancer.ObjectPool"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.EventDispatcher.Release">
            <summary>Returns this <see cref="T:Animancer.AnimancerState.EventDispatcher"/> to the <see cref="T:Animancer.ObjectPool"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.EventDispatcher.TryClear(Animancer.AnimancerState.EventDispatcher)">
            <summary>
            If the <see cref="T:Animancer.AnimancerEvent.Sequence"/> was acquired from the <see cref="T:Animancer.ObjectPool"/>, this
            method clears it. Otherwise it simply discards the reference.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerState.EventDispatcher.RecalculateEventIndex">
            <summary>
            A special value used by the <see cref="F:Animancer.AnimancerState.EventDispatcher._NextEventIndex"/> to indicate that it needs to be recalculated.
            </summary>
        </member>
        <member name="F:Animancer.AnimancerState.EventDispatcher.SequenceVersionException">
            <summary>
            This system accounts for external modifications to the sequence, but modifying it while checking which
            of its events to update is not allowed because it would be impossible to efficiently keep track of
            which events have been checked/invoked and which still need to be checked.
            </summary>
        </member>
        <member name="P:Animancer.AnimancerState.EventDispatcher.HasEvents">
            <summary>Does this dispatcher have an <see cref="T:Animancer.AnimancerEvent.Sequence"/>?</summary>
            <remarks>Accessing <see cref="P:Animancer.AnimancerState.EventDispatcher.Events"/> would automatically get one from the <see cref="T:Animancer.ObjectPool"/>.</remarks>
        </member>
        <member name="P:Animancer.AnimancerState.EventDispatcher.Events">
            <summary>The events managed by this dispatcher.</summary>
            <remarks>If <c>null</c>, a new sequence will be acquired from the <see cref="T:Animancer.ObjectPool"/>.</remarks>
        </member>
        <member name="M:Animancer.AnimancerState.EventDispatcher.ValidateBeforeEndEvent">
            <summary>[Assert-Conditional]
            Called after the <see cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/> is triggered to log a warning if the
            <see cref="F:Animancer.AnimancerState.EventDispatcher._State"/> was not interrupted or the `callback` contains multiple calls to the same method.
            </summary>
            <remarks>
            It would be better if we could validate the callback when it is assigned to get a useful stack trace,
            but that is unfortunately not possible since <see cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/> needs to be
            a field for efficiency.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerState.EventDispatcher.ValidateAfterEndEvent(System.Action)">
            <summary>[Assert-Conditional]
            Called after the <see cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/> is triggered to log a warning if the
            <see cref="F:Animancer.AnimancerState.EventDispatcher._State"/> was not interrupted or the `callback` contains multiple calls to the same method.
            </summary>
            <remarks>
            It would be better if we could validate the callback when it is assigned to get a useful stack trace,
            but that is unfortunately not possible since <see cref="P:Animancer.AnimancerEvent.Sequence.EndEvent"/> needs to be
            a field for efficiency.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerState.EventDispatcher.ShouldLogEndEventInterrupt(System.Action)">
            <summary>Should <see cref="F:Animancer.OptionalWarning.EndEventInterrupt"/> be logged?</summary>
        </member>
        <member name="M:Animancer.AnimancerState.EventDispatcher.OnTimeChanged">
            <summary>Notifies this dispatcher that the target's <see cref="P:Animancer.AnimancerState.Time"/> has changed.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.EventDispatcher.UpdateZeroLength">
            <summary>If the state has zero length, trigger its end event every frame.</summary>
        </member>
        <member name="M:Animancer.AnimancerState.EventDispatcher.GetLoopDelta(System.Single,System.Single,System.Single)">
            <summary>
            Calculates the number of times an event at `eventTime` should be invoked when the
            <see cref="P:Animancer.AnimancerState.NormalizedTime"/> goes from `previousTime` to `nextTime` on a looping animation.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerState.EventDispatcher.ToString">
            <summary>Returns "<see cref="T:Animancer.AnimancerState.EventDispatcher"/> (Target State)".</summary>
        </member>
        <member name="T:Animancer.AnimancerUtilities">
            <summary>Various extension methods and utilities.</summary>
            https://kybernetik.com.au/animancer/api/Animancer/AnimancerUtilities
            
            https://kybernetik.com.au/animancer/api/Animancer/AnimancerUtilities
            https://kybernetik.com.au/animancer/api/Animancer/AnimancerUtilities
            https://kybernetik.com.au/animancer/api/Animancer/AnimancerUtilities
            https://kybernetik.com.au/animancer/api/Animancer/AnimancerUtilities
            https://kybernetik.com.au/animancer/api/Animancer/AnimancerUtilities
        </member>
        <member name="F:Animancer.AnimancerUtilities.IsAnimancerPro">
            <summary>This is Animancer Lite.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Wrap01(System.Single)">
            <summary>Loops the `value` so that <c>0 &lt;= value &lt; 1</c>.</summary>
            <remarks>This is more efficient than using <see cref="M:Animancer.AnimancerUtilities.Wrap(System.Single,System.Single)"/> with a <c>length</c> of 1.</remarks>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Wrap(System.Single,System.Single)">
            <summary>Loops the `value` so that <c>0 &lt;= value &lt; length</c>.</summary>
            <remarks>Unike <see cref="M:UnityEngine.Mathf.Repeat(System.Single,System.Single)"/>, this method will never return the `length`.</remarks>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Round(System.Single)">
            <summary>
            Rounds the `value` to the nearest integer using <see cref="F:System.MidpointRounding.AwayFromZero"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Round(System.Single,System.Single)">
            <summary>
            Rounds the `value` to be a multiple of the `multiple` using <see cref="F:System.MidpointRounding.AwayFromZero"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.IsFinite(System.Single)">
            <summary>[Animancer Extension] Is the `value` not NaN or Infinity?</summary>
            <remarks>Newer versions of the .NET framework apparently have a <c>float.IsFinite</c> method.</remarks>
        </member>
        <member name="M:Animancer.AnimancerUtilities.IsFinite(System.Double)">
            <summary>[Animancer Extension] Is the `value` not NaN or Infinity?</summary>
            <remarks>Newer versions of the .NET framework apparently have a <c>double.IsFinite</c> method.</remarks>
        </member>
        <member name="M:Animancer.AnimancerUtilities.IsFinite(UnityEngine.Vector2)">
            <summary>[Animancer Extension] Are all components of the `value` not NaN or Infinity?</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.ToStringOrNull(System.Object)">
            <summary>
            If `obj` exists, this method returns <see cref="M:System.Object.ToString"/>.
            Or if it is <c>null</c>, this method returns <c>"Null"</c>.
            Or if it is an <see cref="T:UnityEngine.Object"/> that has been destroyed, this method returns <c>"Null (ObjectType)"</c>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.CopyExactArray``1(``0[],``0[]@)">
            <summary>Ensures that the length and contents of `copyTo` match `copyFrom`.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Swap``1(``0[],System.Int32,System.Int32)">
            <summary>[Animancer Extension] Swaps <c>array[a]</c> with <c>array[b]</c>.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.IsNullOrEmpty``1(``0[])">
            <summary>[Animancer Extension]
            Is the `array` <c>null</c> or its <see cref="P:System.Array.Length"/> <c>0</c>?
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.SetLength``1(``0[]@,System.Int32)">
            <summary>
            If the `array` is <c>null</c> or its <see cref="P:System.Array.Length"/> isn't equal to the specified `length`, this
            method creates a new array with that `length` and returns <c>true</c>.
            </summary>
            <remarks>
            Unlike <see cref="M:System.Array.Resize``1(``0[]@,System.Int32)"/>, this method doesn't copy over the contents of the old
            `array` into the new one.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerUtilities.IsValid(Animancer.AnimancerNode)">
            <summary>[Animancer Extension] Is the `node` is not null and <see cref="P:Animancer.AnimancerNode.IsValid"/>?</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.IsValid(Animancer.ITransitionDetailed)">
            <summary>[Animancer Extension] Is the `transition` not null and <see cref="P:Animancer.ITransitionDetailed.IsValid"/>?</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)">
            <summary>[Animancer Extension] Calls <see cref="M:Animancer.ITransition.CreateState"/> and <see cref="M:Animancer.ITransition.Apply(Animancer.AnimancerState)"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.RemovePlayable(UnityEngine.Playables.Playable,System.Boolean)">
            <summary>[Pro-Only] Reconnects the input of the specified `playable` to its output.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.HasEvent(Animancer.IAnimationClipCollection,System.String)">
            <summary>
            Checks if any <see cref="T:UnityEngine.AnimationClip"/> in the `source` has an animation event with the specified
            `functionName`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.HasEvent(UnityEngine.AnimationClip,System.String)">
            <summary>Checks if the `clip` has an animation event with the specified `functionName`.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.CalculateThresholdsFromAverageVelocityXZ(Animancer.MixerState{UnityEngine.Vector2})">
            <summary>[Animancer Extension] [Pro-Only]
            Calculates all thresholds in the `mixer` using the <see cref="P:Animancer.AnimancerState.AverageVelocity"/> of each
            state on the X and Z axes.
            <para></para>
            Note that this method requires the <c>Root Transform Position (XZ) -> Bake Into Pose</c> toggle to be
            disabled in the Import Settings of each <see cref="T:UnityEngine.AnimationClip"/> in the mixer.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.CopyParameterValue(UnityEngine.Animator,UnityEngine.Animator,UnityEngine.AnimatorControllerParameter)">
            <summary>Copies the value of the `parameter` from `copyFrom` to `copyTo`.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.CopyParameterValue(UnityEngine.Animations.AnimatorControllerPlayable,UnityEngine.Animations.AnimatorControllerPlayable,UnityEngine.AnimatorControllerParameter)">
            <summary>Copies the value of the `parameter` from `copyFrom` to `copyTo`.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GetParameterValue(UnityEngine.Animator,UnityEngine.AnimatorControllerParameter)">
            <summary>Gets the value of the `parameter` in the `animator`.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GetParameterValue(UnityEngine.Animations.AnimatorControllerPlayable,UnityEngine.AnimatorControllerParameter)">
            <summary>Gets the value of the `parameter` in the `playable`.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.SetParameterValue(UnityEngine.Animator,UnityEngine.AnimatorControllerParameter,System.Object)">
            <summary>Sets the `value` of the `parameter` in the `animator`.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.SetParameterValue(UnityEngine.Animations.AnimatorControllerPlayable,UnityEngine.AnimatorControllerParameter,System.Object)">
            <summary>Sets the `value` of the `parameter` in the `playable`.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.CreateNativeReference``1">
            <summary>
            Creates a <see cref="T:Unity.Collections.NativeArray`1"/> containing a single element so that it can be used like a reference
            in Unity's C# Job system which does not allow regular reference types.
            </summary>
            <remarks>Note that you must call <see cref="M:Unity.Collections.NativeArray`1.Dispose"/> when you're done with the array.</remarks>
        </member>
        <member name="M:Animancer.AnimancerUtilities.ConvertToTransformStreamHandles(System.Collections.Generic.IList{UnityEngine.Transform},UnityEngine.Animator)">
            <summary>
            Creates a <see cref="T:Unity.Collections.NativeArray`1"/> of <see cref="T:UnityEngine.Animations.TransformStreamHandle"/>s for each of the `transforms`.
            </summary>
            <remarks>Note that you must call <see cref="M:Unity.Collections.NativeArray`1.Dispose"/> when you're done with the array.</remarks>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GetUnsupportedMessage``1(``0)">
            <summary>Returns a string stating that the `value` is unsupported.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.CreateUnsupportedArgumentException``1(``0)">
            <summary>Returns an exception stating that the `value` is unsupported.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.AddAnimancerComponent``1(UnityEngine.Animator)">
            <summary>[Animancer Extension]
            Adds the specified type of <see cref="T:Animancer.IAnimancerComponent"/>, links it to the `animator`, and returns it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GetOrAddAnimancerComponent``1(UnityEngine.Animator)">
            <summary>[Animancer Extension]
            Returns the <see cref="T:Animancer.IAnimancerComponent"/> on the same <see cref="T:UnityEngine.GameObject"/> as the `animator` if
            there is one. Otherwise this method adds a new one and returns it.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GetComponentInParentOrChildren``1(UnityEngine.GameObject)">
            <summary>
            Returns the first <typeparamref name="T"/> component on the `gameObject` or its parents or children (in
            that order).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GetComponentInParentOrChildren``1(UnityEngine.GameObject,``0@)">
            <summary>
            If the `component` is <c>null</c>, this method tries to find one on the `gameObject` or its parents or
            children (in that order).
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Assert(System.Boolean,System.Object)">
            <summary>[Assert-Conditional]
            Throws an <see cref="T:UnityEngine.Assertions.AssertionException"/> if the `condition` is false.
            </summary>
            <remarks>
            This method is similar to <see cref="M:UnityEngine.Debug.Assert(System.Boolean,System.Object)"/>, but it throws an exception instead of
            just logging the `message`.
            </remarks>
        </member>
        <member name="M:Animancer.AnimancerUtilities.SetDirty(UnityEngine.Object)">
            <summary>[Editor-Conditional] Indicates that the `target` needs to be re-serialized.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.EditModeSampleAnimation(UnityEngine.AnimationClip,UnityEngine.Component,System.Single)">
            <summary>[Editor-Conditional]
            Applies the effects of the animation `clip` to the <see cref="P:UnityEngine.Component.gameObject"/>.
            </summary>
            <remarks>This method is safe to call during <see cref="T:UnityEngine.MonoBehaviour"/><c>.OnValidate</c>.</remarks>
            <param name="clip">The animation to apply. If <c>null</c>, this method does nothing.</param>
            <param name="component">
            The animation will be applied to an <see cref="T:UnityEngine.Animator"/> or <see cref="T:UnityEngine.Animation"/> component on the same
            object as this or on any of its parents or children. If <c>null</c>, this method does nothing.
            </param>
            <param name="time">Determines which part of the animation to apply (in seconds).</param>
            <seealso cref="M:Animancer.AnimancerUtilities.EditModePlay(UnityEngine.AnimationClip,UnityEngine.Component)"/>
        </member>
        <member name="M:Animancer.AnimancerUtilities.EditModePlay(UnityEngine.AnimationClip,UnityEngine.Component)">
            <summary>[Editor-Conditional] Plays the specified `clip` if called in Edit Mode.</summary>
            <remarks>This method is safe to call during <see cref="T:UnityEngine.MonoBehaviour"/><c>.OnValidate</c>.</remarks>
            <param name="clip">The animation to apply. If <c>null</c>, this method does nothing.</param>
            <param name="component">
            The animation will be played on an <see cref="T:Animancer.IAnimancerComponent"/> on the same object as this or on any
            of its parents or children. If <c>null</c>, this method does nothing.
            </param>
            <seealso cref="M:Animancer.AnimancerUtilities.EditModeSampleAnimation(UnityEngine.AnimationClip,UnityEngine.Component,System.Single)"/>
        </member>
        <member name="M:Animancer.AnimancerUtilities.TryGetInvocationListNonAlloc(System.MulticastDelegate,System.Delegate[]@)">
            <summary>[Assert-Only]
            Uses reflection to achieve the same as <see cref="M:System.Delegate.GetInvocationList"/> without allocating
            garbage every time.
            <list type="bullet">
            <item>If the delegate is <c>null</c> or , this method returns <c>false</c> and outputs <c>null</c>.</item>
            <item>If the underlying <c>delegate</c> field was not found, this method returns <c>false</c> and outputs <c>null</c>.</item>
            <item>If the delegate is not multicast, this method this method returns <c>true</c> and outputs <c>null</c>.</item>
            <item>If the delegate is multicast, this method this method returns <c>true</c> and outputs its invocation list.</item>
            </list>
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)">
            <summary>[Animancer Extension]
            Adds the `clip` to the `clips` if it wasn't there already.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Collections.Generic.IList{UnityEngine.AnimationClip})">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)"/> for each of the `newClips`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Collections.Generic.IEnumerable{UnityEngine.AnimationClip})">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)"/> for each of the `newClips`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GatherFromAsset(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.Playables.PlayableAsset)">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)"/> for each clip in the `asset`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GatherFromTracks(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Collections.IEnumerable)">
            <summary>Gathers all the animations in the `tracks`.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GatherFromSource(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.IAnimationClipSource)">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)"/> for each clip gathered by
            <see cref="M:UnityEngine.IAnimationClipSource.GetAnimationClips(System.Collections.Generic.List{UnityEngine.AnimationClip})"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GatherFromSource(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Collections.IEnumerable)">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.GatherFromSource(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Object)"/> for each item in the `source`.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GatherFromSource(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},System.Object)">
            <summary>[Animancer Extension]
            Calls <see cref="M:Animancer.AnimancerUtilities.Gather(System.Collections.Generic.ICollection{UnityEngine.AnimationClip},UnityEngine.AnimationClip)"/> for each clip in the `source`,
            supporting both <see cref="T:UnityEngine.IAnimationClipSource"/> and <see cref="T:Animancer.IAnimationClipCollection"/>.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.TryGetFrameRate(System.Object,System.Single@)">
            <summary>
            Attempts to get the <see cref="P:UnityEngine.AnimationClip.frameRate"/> from the `clipSource` and returns true if
            successful. If it has multiple animations with different rates, this method returns false.
            </summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.Clone``1(``0)">
            <summary>Creates a new <typeparamref name="T"/> and calls <see cref="M:Animancer.ICopyable`1.CopyFrom(`0)"/> on it.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.TryGetAverageAngularSpeed(System.Object,System.Single@)">
            <summary>Outputs the <see cref="P:UnityEngine.Motion.averageAngularSpeed"/> or <see cref="P:Animancer.IMotion.AverageAngularSpeed"/>.</summary>
            <remarks>Returns false if the `motion` is null or an unsupported type.</remarks>
        </member>
        <member name="M:Animancer.AnimancerUtilities.TryGetAverageVelocity(System.Object,UnityEngine.Vector3@)">
            <summary>Outputs the <see cref="P:UnityEngine.Motion.averageSpeed"/> or <see cref="P:Animancer.IMotion.AverageVelocity"/>.</summary>
            <remarks>Returns false if the `motion` is null or an unsupported type.</remarks>
        </member>
        <member name="M:Animancer.AnimancerUtilities.IsValid(Animancer.ITransition)">
            <summary>Returns the <see cref="P:Animancer.ITransitionDetailed.IsValid"/> with support for <see cref="T:Animancer.IWrapper"/>.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.TryGetIsLooping(System.Object,System.Boolean@)">
            <summary>Outputs the <see cref="P:UnityEngine.Motion.isLooping"/> or <see cref="P:Animancer.ITransitionDetailed.IsLooping"/>.</summary>
            <remarks>Returns false if the `motionOrTransition` is null or an unsupported type.</remarks>
        </member>
        <member name="M:Animancer.AnimancerUtilities.TryGetLength(System.Object,System.Single@)">
            <summary>Outputs the <see cref="P:UnityEngine.AnimationClip.length"/> or <see cref="P:Animancer.ITransitionDetailed.MaximumDuration"/>.</summary>
            <remarks>Returns false if the `motionOrTransition` is null or an unsupported type.</remarks>
        </member>
        <member name="M:Animancer.AnimancerUtilities.GetWrappedObject(System.Object)">
            <summary>Returns the <see cref="P:Animancer.IWrapper.WrappedObject"/> recursively.</summary>
        </member>
        <member name="M:Animancer.AnimancerUtilities.TryGetWrappedObject``1(System.Object,``0@)">
            <summary>
            Returns the `wrapper` or first <see cref="P:Animancer.IWrapper.WrappedObject"/> which is a <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="T:Animancer.ClipState">
            <summary>An <see cref="T:Animancer.AnimancerState"/> which plays an <see cref="T:UnityEngine.AnimationClip"/>.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/playing/states">States</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/ClipState
            
        </member>
        <member name="T:Animancer.ClipState.ITransition">
            <summary>An <see cref="T:Animancer.ITransition`1"/> that creates a <see cref="T:Animancer.ClipState"/>.</summary>
        </member>
        <member name="F:Animancer.ClipState._Clip">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ClipState.Clip">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ClipState.MainObject">
            <summary>The <see cref="T:UnityEngine.AnimationClip"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.ClipState.Length">
            <summary>The <see cref="P:UnityEngine.AnimationClip.length"/>.</summary>
        </member>
        <member name="P:Animancer.ClipState.IsLooping">
            <summary>The <see cref="P:UnityEngine.Motion.isLooping"/>.</summary>
        </member>
        <member name="P:Animancer.ClipState.AverageVelocity">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.ClipState.ApplyAnimatorIK">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.ClipState.ApplyFootIK">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ClipState.#ctor(UnityEngine.AnimationClip)">
            <summary>Creates a new <see cref="T:Animancer.ClipState"/> and sets its <see cref="P:Animancer.ClipState.Clip"/>.</summary>
            <exception cref="T:System.ArgumentNullException">The `clip` is null.</exception>
        </member>
        <member name="M:Animancer.ClipState.CreatePlayable(UnityEngine.Playables.Playable@)">
            <summary>Creates and assigns the <see cref="T:UnityEngine.Animations.AnimationClipPlayable"/> managed by this node.</summary>
        </member>
        <member name="M:Animancer.ClipState.Destroy">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ClipState.Clone(Animancer.AnimancerPlayable)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ClipState.CreateDrawer">
            <summary>[Editor-Only] Returns a <see cref="T:Animancer.ClipState.Drawer"/> for this state.</summary>
        </member>
        <member name="T:Animancer.ClipState.Drawer">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ClipState.Drawer.#ctor(Animancer.ClipState)">
            <summary>Creates a new <see cref="T:Animancer.ClipState.Drawer"/> to manage the Inspector GUI for the `state`.</summary>
        </member>
        <member name="M:Animancer.ClipState.Drawer.AddContextMenuFunctions(UnityEditor.GenericMenu)">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.FadeMode">
            <summary>Determines how <see cref="M:Animancer.AnimancerLayer.Play(Animancer.AnimancerState,System.Single,Animancer.FadeMode)"/> works.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/blending/fading/modes">Fade Modes</see>
            <para></para>
            Example: <see href="https://kybernetik.com.au/animancer/docs/examples/basics/transitions">Transitions</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/FadeMode
            
        </member>
        <member name="F:Animancer.FadeMode.FixedSpeed">
             <summary>
             Calculate the fade speed to bring the <see cref="P:Animancer.AnimancerNode.Weight"/> from 0 to 1 over the specified
             fade duration (in seconds), regardless of the actual starting weight.
             </summary>
            
             <example>
             A fade duration of 0.5 would make the fade last for 0.5 seconds, regardless of how long the animation is.
             <para></para>
             This is generally the same as <see cref="F:Animancer.FadeMode.FixedDuration"/> but differs when starting the fade from a
             non-zero <see cref="P:Animancer.AnimancerNode.Weight"/>, for example:
             <list type="bullet">
             <item>Fade Duration: 0.25</item>
             <item>To fade from 0 to 1 with either mode would get a speed of 4 and take 0.25 seconds</item>
             <item>To fade from 0.5 to 1 with <see cref="F:Animancer.FadeMode.FixedDuration"/> would get a speed of 2 and take 0.25 seconds.
             It has half the distance to cover so it goes half as fast to maintain the expected duration.</item>
             <item>To fade from 0.5 to 1 with <see cref="F:Animancer.FadeMode.FixedSpeed"/> would get a speed of 4 and take 0.125 seconds.
             It gets the same speed regardless of the distance to cover, so with less distance it completes faster.</item>
             </list>
             </example>
            
             <exception cref="T:System.InvalidOperationException">The <see cref="P:Animancer.AnimancerState.Clip"/> is null.</exception>
            
             <exception cref="T:System.ArgumentOutOfRangeException">
             More states have been created for the <see cref="P:Animancer.AnimancerState.Clip"/> than the
             <see cref="P:Animancer.AnimancerLayer.MaxCloneCount"/> allows.
             </exception>
        </member>
        <member name="F:Animancer.FadeMode.FixedDuration">
             <summary>
             Calculate the fade speed to bring the <see cref="P:Animancer.AnimancerNode.Weight"/> to the target value over the
             specified fade duration (in seconds).
             </summary>
            
             <example>
             A fade duration of 0.5 would make the fade last for 0.5 seconds, regardless of how long the animation is.
             <para></para>
             This is generally the same as <see cref="F:Animancer.FadeMode.FixedSpeed"/>, but differs when starting the fade from a
             non-zero <see cref="P:Animancer.AnimancerNode.Weight"/>:
             <list type="bullet">
             <item>Fade Duration: 0.25</item>
             <item>To fade from 0 to 1 with either mode would get a speed of 4 and take 0.25 seconds</item>
             <item>To fade from 0.5 to 1 with <see cref="F:Animancer.FadeMode.FixedDuration"/> would get a speed of 2 and take 0.25 seconds.
             It has half the distance to cover so it goes half as fast to maintain the expected duration.</item>
             <item>To fade from 0.5 to 1 with <see cref="F:Animancer.FadeMode.FixedSpeed"/> would get a speed of 4 and take 0.125 seconds.
             It gets the same speed regardless of the distance to cover, so with less distance it completes faster.</item>
             </list>
             </example>
            
             <remarks>
             This was how fading worked prior to the introduction of <see cref="T:Animancer.FadeMode"/>s in Animancer v4.0.
             </remarks>
        </member>
        <member name="F:Animancer.FadeMode.FromStart">
             <summary>
             If the <see cref="P:Animancer.AnimancerNode.Weight"/> is above the <see cref="P:Animancer.AnimancerLayer.WeightlessThreshold"/>,
             this mode will use <see cref="M:Animancer.AnimancerLayer.GetOrCreateWeightlessState(Animancer.AnimancerState)"/> to get a copy of it that is at 0
             weight so it can fade the copy in while the original fades out with all other states. This allows an
             animation to fade into itself.
             </summary>
            
             <example>
             This mode can be useful when you want to repeat an action while the previous animation is still fading out.
             For example, if you play an 'Attack' animation, it ends and starts fading back to 'Idle', and while it is
             doing so you want to start another 'Attack' with the same animation. The previous 'Attack' can't simply
             snap back to the start, so you can use this mode to create a second 'Attack' state to fade in while the old
             one fades out.
             </example>
             
             <remarks>
             Using this mode repeatedly on subsequent frames will probably have undesirable effects because it will
             create a new state each time. In such a situation you most likely want <see cref="F:Animancer.FadeMode.FixedSpeed"/> instead.
             <para></para>
             This mode only works for <see cref="T:Animancer.ClipState"/>s.
             <para></para>
             The <see href="https://kybernetik.com.au/animancer/docs/manual/blending/fading/modes">Fade Modes</see> page
             explains this mode in more detail.
             </remarks>
        </member>
        <member name="F:Animancer.FadeMode.NormalizedSpeed">
            <summary>
            Like <see cref="F:Animancer.FadeMode.FixedSpeed"/>, except that the fade duration is multiplied by the animation length.
            </summary>
        </member>
        <member name="F:Animancer.FadeMode.NormalizedDuration">
            <summary>
            Like <see cref="F:Animancer.FadeMode.FixedDuration"/>, except that the fade duration is multiplied by the animation length.
            </summary>
        </member>
        <member name="F:Animancer.FadeMode.NormalizedFromStart">
            <summary>
            Like <see cref="F:Animancer.FadeMode.FromStart"/>, except that the fade duration is multiplied by the animation length.
            </summary>
        </member>
        <member name="T:Animancer.PlayableAssetState">
            <summary>[Pro-Only] An <see cref="T:Animancer.AnimancerState"/> which plays a <see cref="T:UnityEngine.Playables.PlayableAsset"/>.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/timeline">Timeline</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/PlayableAssetState
            
        </member>
        <member name="T:Animancer.PlayableAssetState.ITransition">
            <summary>An <see cref="T:Animancer.ITransition`1"/> that creates a <see cref="T:Animancer.PlayableAssetState"/>.</summary>
        </member>
        <member name="F:Animancer.PlayableAssetState._Asset">
            <summary>The <see cref="T:UnityEngine.Playables.PlayableAsset"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Asset">
            <summary>The <see cref="T:UnityEngine.Playables.PlayableAsset"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.MainObject">
            <summary>The <see cref="T:UnityEngine.Playables.PlayableAsset"/> which this state plays.</summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.Length">
            <summary>The <see cref="P:UnityEngine.Playables.PlayableAsset.duration"/>.</summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.OnSetIsPlaying">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.PlayableAssetState.CopyIKFlags(Animancer.AnimancerNode)">
            <summary>IK cannot be dynamically enabled on a <see cref="T:Animancer.PlayableAssetState"/>.</summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.ApplyAnimatorIK">
            <summary>IK cannot be dynamically enabled on a <see cref="T:Animancer.PlayableAssetState"/>.</summary>
        </member>
        <member name="P:Animancer.PlayableAssetState.ApplyFootIK">
            <summary>IK cannot be dynamically enabled on a <see cref="T:Animancer.PlayableAssetState"/>.</summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.#ctor(UnityEngine.Playables.PlayableAsset)">
            <summary>Creates a new <see cref="T:Animancer.PlayableAssetState"/> to play the `asset`.</summary>
            <exception cref="T:System.ArgumentNullException">The `asset` is null.</exception>
        </member>
        <member name="M:Animancer.PlayableAssetState.CreatePlayable(UnityEngine.Playables.Playable@)">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.PlayableAssetState.Bindings">
            <summary>The objects controlled by each track in the asset.</summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.SetBindings(UnityEngine.Object[])">
            <summary>Sets the <see cref="P:Animancer.PlayableAssetState.Bindings"/>.</summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.GetBindingDetails(UnityEngine.Playables.PlayableBinding,System.String@,System.Type@,System.Boolean@)">
            <summary>Should the `binding` be skipped when determining how to map the <see cref="P:Animancer.PlayableAssetState.Bindings"/>?</summary>
        </member>
        <member name="M:Animancer.PlayableAssetState.Destroy">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.PlayableAssetState.Clone(Animancer.AnimancerPlayable)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.PlayableAssetState.Animancer#ICopyable{Animancer#PlayableAssetState}#CopyFrom(Animancer.PlayableAssetState)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.PlayableAssetState.AppendDetails(System.Text.StringBuilder,System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.SoloAnimationInternal">
            <summary>Plays a single <see cref="T:UnityEngine.AnimationClip"/>.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/playing/component-types">Component Types</see>
            </remarks>
            <example>
            <see href="https://kybernetik.com.au/animancer/docs/examples/fine-control/solo-animation">Solo Animation</see>
            </example>
            https://kybernetik.com.au/animancer/api/Animancer/SoloAnimation
            
        </member>
        <member name="F:Animancer.SoloAnimationInternal.DefaultExecutionOrder">
            <summary>Initialize before anything else tries to use this component.</summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.Animator">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>]
            The <see cref="T:UnityEngine.Animator"/> component which this script controls.
            </summary>
            <remarks>
            If you need to set this value at runtime you are likely better off using a proper
            <see cref="!:AnimancerComponent"/>.
            </remarks>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.Clip">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The <see cref="T:UnityEngine.AnimationClip"/> that will be played.</summary>
            <remarks>
            If you need to set this value at runtime you are likely better off using a proper
            <see cref="!:AnimancerComponent"/>.
            </remarks>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.StopOnDisable">
            <summary>
            If true, disabling this object will stop and rewind the animation. Otherwise it will simply be paused
            and will resume from its current state when it is re-enabled.
            </summary>
            <remarks>
            The default value is true.
            <para></para>
            This property wraps <see cref="P:UnityEngine.Animator.keepAnimatorControllerStateOnDisable"/> and inverts its value.
            The value is serialized by the <see cref="T:UnityEngine.Animator"/>.
            </remarks>
        </member>
        <member name="F:Animancer.SoloAnimationInternal._Graph">
            <summary>The <see cref="T:UnityEngine.Playables.PlayableGraph"/> being used to play the <see cref="P:Animancer.SoloAnimationInternal.Clip"/>.</summary>
        </member>
        <member name="F:Animancer.SoloAnimationInternal._Playable">
            <summary>The <see cref="T:UnityEngine.Animations.AnimationClipPlayable"/> being used to play the <see cref="P:Animancer.SoloAnimationInternal.Clip"/>.</summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.IsPlaying">
            <summary>Is the animation playing (true) or paused (false)?</summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.Speed">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] The speed at which the animation is playing (default 1).</summary>
            <exception cref="T:System.ArgumentException">This component is not yet <see cref="P:Animancer.SoloAnimationInternal.IsInitialized"/>.</exception>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.FootIK">
            <summary>[<see cref="T:UnityEngine.SerializeField"/>] Should Foot IK will be applied to the model (if it is Humanoid)?</summary>
            <remarks>
            The developers of Unity have stated that they believe it looks better with this enabled, but more often
            than not it just makes the legs end up in a slightly different pose to what the animator intended.
            </remarks>
            <exception cref="T:System.ArgumentException">This component is not yet <see cref="P:Animancer.SoloAnimationInternal.IsInitialized"/>.</exception>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.Time">
            <summary>The number of seconds that have passed since the start of the animation.</summary>
            <exception cref="T:System.ArgumentException">This component is not yet <see cref="P:Animancer.SoloAnimationInternal.IsInitialized"/>.</exception>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.NormalizedTime">
            <summary>
            The <see cref="P:Animancer.SoloAnimationInternal.Time"/> of this state as a portion of the <see cref="P:UnityEngine.AnimationClip.length"/>, meaning the
            value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes.
            </summary>
            <remarks>
            This value will continue increasing after the animation passes the end of its length and it will either
            freeze in place or start again from the beginning according to whether it is looping or not.
            <para></para>
            The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the
            current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has
            been looped.
            </remarks>
            <exception cref="T:System.ArgumentException">This component is not yet <see cref="P:Animancer.SoloAnimationInternal.IsInitialized"/>.</exception>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.IsInitialized">
            <summary>Indicates whether the <see cref="T:UnityEngine.Playables.PlayableGraph"/> is valid.</summary>
        </member>
        <member name="P:Animancer.SoloAnimationInternal.ApplyInEditMode">
            <summary>[Editor-Only] Should the <see cref="P:Animancer.SoloAnimationInternal.Clip"/> be automatically applied to the object in Edit Mode?</summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.Reset">
            <summary>[Editor-Only]
            Tries to find an <see cref="T:UnityEngine.Animator"/> component on this <see cref="T:UnityEngine.GameObject"/> or its
            children or parents (in that order).
            </summary>
            <remarks>
            Called by the Unity Editor when this component is first added (in Edit Mode) and whenever the Reset command
            is executed from its context menu.
            </remarks>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.OnValidate">
            <summary>[Editor-Only]
            Applies the <see cref="P:Animancer.SoloAnimationInternal.Speed"/>, <see cref="P:Animancer.SoloAnimationInternal.FootIK"/>, and <see cref="P:Animancer.SoloAnimationInternal.ApplyInEditMode"/>.
            </summary>
            <remarks>Called in Edit Mode whenever this script is loaded or a value is changed in the Inspector.</remarks>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.Play">
            <summary>Plays the <see cref="P:Animancer.SoloAnimationInternal.Clip"/>.</summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.Play(UnityEngine.AnimationClip)">
            <summary>Plays the `clip`.</summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.OnEnable">
            <summary>Plays the <see cref="P:Animancer.SoloAnimationInternal.Clip"/> on the target <see cref="P:Animancer.SoloAnimationInternal.Animator"/>.</summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.Update">
            <summary>
            Checks if the animation is done so it can pause the <see cref="T:UnityEngine.Playables.PlayableGraph"/> to improve performance.
            </summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.OnDisable">
            <summary>Ensures that the <see cref="F:Animancer.SoloAnimationInternal._Graph"/> is properly cleaned up.</summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.OnDestroy">
            <summary>Ensures that the <see cref="T:UnityEngine.Playables.PlayableGraph"/> is properly cleaned up.</summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.Finalize">
            <summary>[Editor-Only] Ensures that the <see cref="T:UnityEngine.Playables.PlayableGraph"/> is destroyed.</summary>
        </member>
        <member name="M:Animancer.SoloAnimationInternal.GetAnimationClips(System.Collections.Generic.List{UnityEngine.AnimationClip})">
            <summary>[<see cref="T:UnityEngine.IAnimationClipSource"/>] Adds the <see cref="P:Animancer.SoloAnimationInternal.Clip"/> to the list.</summary>
        </member>
        <member name="T:Animancer.DefaultFadeValueAttribute">
            <summary>[Editor-Conditional]
            A <see cref="T:Animancer.DefaultValueAttribute"/> which uses the <see cref="P:Animancer.AnimancerPlayable.DefaultFadeDuration"/> and 0.
            </summary>
            https://kybernetik.com.au/animancer/api/Animancer/DefaultFadeValueAttribute
            
        </member>
        <member name="P:Animancer.DefaultFadeValueAttribute.Primary">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.DefaultFadeValueAttribute.#ctor">
            <summary>Creates a new <see cref="T:Animancer.DefaultValueAttribute"/>.</summary>
        </member>
        <member name="T:Animancer.DefaultValueAttribute">
            <summary>[Editor-Conditional] Specifies the default value of a field and a secondary fallback.</summary>
            https://kybernetik.com.au/animancer/api/Animancer/DefaultValueAttribute
            
        </member>
        <member name="P:Animancer.DefaultValueAttribute.Primary">
            <summary>The main default value.</summary>
        </member>
        <member name="P:Animancer.DefaultValueAttribute.Secondary">
            <summary>The fallback value to use if the target value was already equal to the <see cref="P:Animancer.DefaultValueAttribute.Primary"/>.</summary>
        </member>
        <member name="M:Animancer.DefaultValueAttribute.#ctor(System.Object,System.Object)">
            <summary>Creates a new <see cref="T:Animancer.DefaultValueAttribute"/>.</summary>
        </member>
        <member name="M:Animancer.DefaultValueAttribute.#ctor">
            <summary>Creates a new <see cref="T:Animancer.DefaultValueAttribute"/>.</summary>
        </member>
        <member name="M:Animancer.DefaultValueAttribute.SetToDefault``1(``0@,UnityEditor.SerializedProperty)">
            <summary>[Editor-Only]
            If the field represented by the `property` has a <see cref="T:Animancer.DefaultValueAttribute"/>, this method sets
            the `value` to its <see cref="P:Animancer.DefaultValueAttribute.Primary"/> value. If it was already at the value, it sets it to the
            <see cref="P:Animancer.DefaultValueAttribute.Secondary"/> value instead. And if the field has no attribute, it uses the default for the type.
            </summary>
        </member>
        <member name="M:Animancer.DefaultValueAttribute.SetToDefault``1(``0@,System.Reflection.FieldInfo)">
            <summary>[Editor-Only]
            If the field represented by the `property` has a <see cref="T:Animancer.DefaultValueAttribute"/>, this method sets
            the `value` to its <see cref="P:Animancer.DefaultValueAttribute.Primary"/> value. If it was already at the value, it sets it to the
            <see cref="P:Animancer.DefaultValueAttribute.Secondary"/> value instead. And if the field has no attribute, it uses the default for the type.
            </summary>
        </member>
        <member name="M:Animancer.DefaultValueAttribute.SetToDefault``1(``0@)">
            <summary>[Editor-Only]
            Sets the `value` equal to the <see cref="P:Animancer.DefaultValueAttribute.Primary"/> value. If it was already at the value, it sets it equal
            to the <see cref="P:Animancer.DefaultValueAttribute.Secondary"/> value instead.
            </summary>
        </member>
        <member name="M:Animancer.DefaultValueAttribute.SetToDefault``1(``0@,``0,``0)">
            <summary>[Editor-Only]
            Sets the `value` equal to the `primary` value. If it was already at the value, it sets it equal to the
            `secondary` value instead.
            </summary>
        </member>
        <member name="T:Animancer.DrawAfterEventsAttribute">
            <summary>[Editor-Conditional]
            Causes an Inspector field in an <see cref="T:Animancer.ITransition"/> to be drawn after its events where the events would
            normally be drawn last.
            </summary>
            https://kybernetik.com.au/animancer/api/Animancer/DrawAfterEventsAttribute
            
        </member>
        <member name="T:Animancer.EventNamesAttribute">
            <summary>[Editor-Conditional]
            Specifies a set of acceptable names for <see cref="T:Animancer.AnimancerEvent"/>s so they can be displayed using a dropdown
            menu instead of a text field.
            </summary>
            
            <remarks>
            Placing this attribute on a type applies it to all fields in that type.
            <para></para>
            Note that values selected using the dropdown menu are still stored as strings. Modifying the names in the
            script will NOT automatically update any values previously set in the Inspector.
            <para></para>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/events/animancer/usage#event-names">Event Names</see>
            </remarks>
            
            <example><code>
            [EventNames(...)]// Apply to all fields in this class.
            public class AttackState
            {
                [SerializeField]
                [EventNames(...)]// Apply to only this field.
                private ClipTransition _Action;
            }
            </code>
            See the constructors for examples of their usage.
            </example>
            
            https://kybernetik.com.au/animancer/api/Animancer/EventNamesAttribute
            
        </member>
        <member name="F:Animancer.EventNamesAttribute.Names">
            <summary>[Editor-Only] The names that can be used for events in the attributed field.</summary>
        </member>
        <member name="M:Animancer.EventNamesAttribute.#ctor(System.String[])">
            <summary>Creates a new <see cref="T:Animancer.EventNamesAttribute"/> containing the specified `names`.</summary>
            <exception cref="T:System.ArgumentNullException"/>
            <exception cref="T:System.ArgumentOutOfRangeException">`names` contains no elements.</exception>
            <example><code>
            public class AttackState
            {
                [SerializeField]
                [EventNames("Hit Start", "Hit End")]
                private ClipTransition _Animation;
            
                private void Awake()
                {
                    _Animation.Events.SetCallback("Hit Start", OnHitStart);
                    _Animation.Events.SetCallback("Hit End", OnHitEnd);
                }
            
                private void OnHitStart() { }
                private void OnHitEnd() { }
            }
            </code></example>
        </member>
        <member name="M:Animancer.EventNamesAttribute.#ctor(System.Type)">
            <summary>Creates a new <see cref="T:Animancer.EventNamesAttribute"/> with <see cref="F:Animancer.EventNamesAttribute.Names"/> from the `type`.</summary>
            
            <remarks>
            If the `type` is an enum, all of its values will be used.
            <para></para>
            Otherwise the values of all static <see cref="T:System.String"/> fields (including constants) will be used.
            </remarks>
            <exception cref="T:System.ArgumentNullException"/>
            
            <example><code>
            public class AttackState
            {
                public static class Events
                {
                    public const string HitStart = "Hit Start";
                    public const string HitEnd = "Hit End";
                }
            
                [SerializeField]
                [EventNames(typeof(Events))]// Use all string fields in the Events class.
                private ClipTransition _Animation;
            
                private void Awake()
                {
                    _Animation.Events.SetCallback(Events.HitStart, OnHitStart);
                    _Animation.Events.SetCallback(Events.HitEnd, OnHitEnd);
                }
            
                private void OnHitStart() { }
                private void OnHitEnd() { }
            }
            </code></example>
        </member>
        <member name="M:Animancer.EventNamesAttribute.#ctor(System.Type,System.String)">
            <summary>
            Creates a new <see cref="T:Animancer.EventNamesAttribute"/> with <see cref="F:Animancer.EventNamesAttribute.Names"/> from a member in the `type`
            with the specified `name`.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
            <exception cref="T:System.ArgumentException">No member with the specified `name` exists in the `type`.</exception>
            
            <remarks>
            The specified member must be static and can be a Field, Property, or Method.
            <para></para>
            The member type can be anything implementing <see cref="T:System.Collections.IEnumerable"/> (including arrays, lists, and
            coroutines).
            </remarks>
            
            <example><code>
            public class AttackState
            {
                public static readonly string[] Events = { "Hit Start", "Hit End" };
            
                [SerializeField]
                [EventNames(typeof(AttackState), nameof(Events))]// Get the names from AttackState.Events.
                private ClipTransition _Animation;
            
                private void Awake()
                {
                    _Animation.Events.SetCallback(Events[0], OnHitStart);
                    _Animation.Events.SetCallback(Events[1], OnHitEnd);
                }
            
                private void OnHitStart() { }
                private void OnHitEnd() { }
            }
            </code></example>
        </member>
        <member name="F:Animancer.EventNamesAttribute.NoName">
            <summary>The entry used for the menu function to clear the name (U+202F Narrow No-Break Space).</summary>
        </member>
        <member name="T:Animancer.SelfDrawerAttribute">
            <summary>[Editor-Conditional]
            A <see cref="T:UnityEngine.PropertyAttribute"/> which draws itself rather than needing a separate <see cref="T:UnityEditor.PropertyDrawer"/>.
            </summary>
            https://kybernetik.com.au/animancer/api/Animancer/SelfDrawerAttribute
            
        </member>
        <member name="M:Animancer.SelfDrawerAttribute.CanCacheInspectorGUI(UnityEditor.SerializedProperty)">
            <summary>[Editor-Only] Can the GUI for the `property` be cached?</summary>
        </member>
        <member name="M:Animancer.SelfDrawerAttribute.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>[Editor-Only] Calculates the height of the GUI for the `property`.</summary>
        </member>
        <member name="M:Animancer.SelfDrawerAttribute.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>[Editor-Only] Draws the GUI for the `property`.</summary>
        </member>
        <member name="T:Animancer.ThresholdLabelAttribute">
            <summary>[Editor-Conditional]
            Specifies a custom display label for the <c>Thresholds</c> column of a mixer transition.
            </summary>
            https://kybernetik.com.au/animancer/api/Animancer/ThresholdLabelAttribute
            
        </member>
        <member name="F:Animancer.ThresholdLabelAttribute.Label">
            <summary>[Editor-Only] The label.</summary>
        </member>
        <member name="M:Animancer.ThresholdLabelAttribute.#ctor(System.String)">
            <summary>Creates a new <see cref="T:Animancer.ThresholdLabelAttribute"/>.</summary>
        </member>
        <member name="T:Animancer.Units.AnimationSpeedAttribute">
            <summary>[Editor-Conditional] Applies a different GUI for an animation speed field.</summary>
            https://kybernetik.com.au/animancer/api/Animancer.Units/AnimationSpeedAttribute
            
        </member>
        <member name="M:Animancer.Units.AnimationSpeedAttribute.#ctor">
            <summary>Creates a new <see cref="T:Animancer.Units.AnimationTimeAttribute"/>.</summary>
        </member>
        <member name="F:Animancer.Units.AnimationSpeedAttribute.DisplayConverters">
            <summary>A converter that adds an <c>x</c> suffix.</summary>
        </member>
        <member name="M:Animancer.Units.AnimationSpeedAttribute.GetLineCount(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.Units.AnimationTimeAttribute">
            <summary>[Editor-Conditional] Causes a float field to display using 3 fields: Normalized, Seconds, and Frames.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions#time-fields">Time Fields</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer.Units/AnimationTimeAttribute
            
        </member>
        <member name="T:Animancer.Units.AnimationTimeAttribute.Units">
            <summary>A unit of measurement used by the <see cref="T:Animancer.Units.AnimationTimeAttribute"/>.</summary>
        </member>
        <member name="F:Animancer.Units.AnimationTimeAttribute.Units.Normalized">
            <summary>A value of 1 represents the end of the animation.</summary>
        </member>
        <member name="F:Animancer.Units.AnimationTimeAttribute.Units.Seconds">
            <summary>A value of 1 represents 1 second.</summary>
        </member>
        <member name="F:Animancer.Units.AnimationTimeAttribute.Units.Frames">
            <summary>A value of 1 represents 1 frame.</summary>
        </member>
        <member name="F:Animancer.Units.AnimationTimeAttribute.Tooltip">
            <summary>An explanation of the suffixes used in fields drawn by this attribute.</summary>
        </member>
        <member name="M:Animancer.Units.AnimationTimeAttribute.#ctor(Animancer.Units.AnimationTimeAttribute.Units)">
            <summary>Cretes a new <see cref="T:Animancer.Units.AnimationTimeAttribute"/>.</summary>
        </member>
        <member name="F:Animancer.Units.AnimationTimeAttribute.XSuffix">
            <summary>[Editor-Only] A converter that adds an 'x' suffix to the given number.</summary>
        </member>
        <member name="F:Animancer.Units.AnimationTimeAttribute.nextDefaultValue">
            <summary>[Editor-Only] The default value to be used for the next field drawn by this attribute.</summary>
        </member>
        <member name="M:Animancer.Units.AnimationTimeAttribute.GetLineCount(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Units.AnimationTimeAttribute.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Units.AnimationTimeAttribute.OnGUI(UnityEngine.Rect,UnityEngine.GUIContent,System.Single@)">
            <summary>[Editor-Only] Draws the GUI for this attribute.</summary>
        </member>
        <member name="T:Animancer.Units.AnimationTimeAttribute.Settings">
            <summary>[Editor-Only] Options to determine how <see cref="T:Animancer.Units.AnimationTimeAttribute"/> displays.</summary>
        </member>
        <member name="F:Animancer.Units.AnimationTimeAttribute.Settings.showApproximations">
            <summary>Should time fields show approximations if the value is too long for the GUI?</summary>
            <remarks>This setting is used by <see cref="T:Animancer.Editor.CompactUnitConversionCache"/>.</remarks>
        </member>
        <member name="F:Animancer.Units.AnimationTimeAttribute.Settings.showNormalized">
            <summary>Should the <see cref="F:Animancer.Units.AnimationTimeAttribute.Units.Normalized"/> field be shown?</summary>
            <remarks>This setting is ignored for fields which directly store the normalized value.</remarks>
        </member>
        <member name="F:Animancer.Units.AnimationTimeAttribute.Settings.showSeconds">
            <summary>Should the <see cref="F:Animancer.Units.AnimationTimeAttribute.Units.Seconds"/> field be shown?</summary>
            <remarks>This setting is ignored for fields which directly store the seconds value.</remarks>
        </member>
        <member name="F:Animancer.Units.AnimationTimeAttribute.Settings.showFrames">
            <summary>Should the <see cref="F:Animancer.Units.AnimationTimeAttribute.Units.Frames"/> field be shown?</summary>
            <remarks>This setting is ignored for fields which directly store the frame value.</remarks>
        </member>
        <member name="T:Animancer.Units.UnitsAttribute">
            <summary>[Editor-Conditional]
            Causes a float field to display a suffix to indicate what kind of units the value represents as well as
            displaying it as several different fields which convert the value between different units.
            </summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/other/units">Units Attribute</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer.Units/UnitsAttribute
            
        </member>
        <member name="P:Animancer.Units.UnitsAttribute.Rule">
            <summary>The validation rule applied to the value.</summary>
        </member>
        <member name="M:Animancer.Units.UnitsAttribute.#ctor">
            <summary>Creates a new <see cref="T:Animancer.Units.UnitsAttribute"/>.</summary>
        </member>
        <member name="M:Animancer.Units.UnitsAttribute.#ctor(System.String)">
            <summary>Creates a new <see cref="T:Animancer.Units.UnitsAttribute"/>.</summary>
        </member>
        <member name="M:Animancer.Units.UnitsAttribute.#ctor(System.Single[],System.String[],System.Int32)">
            <summary>Creates a new <see cref="T:Animancer.Units.UnitsAttribute"/>.</summary>
        </member>
        <member name="P:Animancer.Units.UnitsAttribute.Multipliers">
            <summary>[Editor-Only] The unit conversion ratios.</summary>
            <remarks><c>valueInUnitX = valueInBaseUnits * Multipliers[x];</c></remarks>
        </member>
        <member name="P:Animancer.Units.UnitsAttribute.DisplayConverters">
            <summary>[Editor-Only] The converters used to generate display strings for each of the fields.</summary>
        </member>
        <member name="P:Animancer.Units.UnitsAttribute.UnitIndex">
            <summary>[Editor-Only] The index of the <see cref="P:Animancer.Units.UnitsAttribute.DisplayConverters"/> for the attributed serialized value.</summary>
        </member>
        <member name="P:Animancer.Units.UnitsAttribute.IsOptional">
            <summary>[Editor-Only] Should the field have a toggle to set its value to <see cref="F:System.Single.NaN"/>?</summary>
        </member>
        <member name="P:Animancer.Units.UnitsAttribute.DefaultValue">
            <summary>[Editor-Only] The value to display if the actual value is <see cref="F:System.Single.NaN"/>.</summary>
        </member>
        <member name="M:Animancer.Units.UnitsAttribute.SetUnits(System.Single[],Animancer.Editor.CompactUnitConversionCache[],System.Int32)">
            <summary>[Editor-Only] Sets the unit details.</summary>
        </member>
        <member name="P:Animancer.Units.UnitsAttribute.StandardSpacing">
            <summary>[Editor-Only] Returns <see cref="P:Animancer.Editor.AnimancerGUI.StandardSpacing"/>.</summary>
        </member>
        <member name="P:Animancer.Units.UnitsAttribute.LineHeight">
            <summary>[Editor-Only] Returns <see cref="P:Animancer.Editor.AnimancerGUI.LineHeight"/>.</summary>
        </member>
        <member name="M:Animancer.Units.UnitsAttribute.GetPropertyHeight(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.Units.UnitsAttribute.GetLineCount(UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>[Editor-Only] Determines how many lines tall the `property` should be.</summary>
        </member>
        <member name="M:Animancer.Units.UnitsAttribute.BeginProperty(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent@,System.Single@)">
            <summary>[Editor-Only] Begins a GUI property block to be ended by <see cref="M:Animancer.Units.UnitsAttribute.EndProperty(UnityEngine.Rect,UnityEditor.SerializedProperty,System.Single@)"/>.</summary>
        </member>
        <member name="M:Animancer.Units.UnitsAttribute.EndProperty(UnityEngine.Rect,UnityEditor.SerializedProperty,System.Single@)">
            <summary>[Editor-Only] Ends a GUI property block started by <see cref="M:Animancer.Units.UnitsAttribute.BeginProperty(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent@,System.Single@)"/>.</summary>
        </member>
        <member name="M:Animancer.Units.UnitsAttribute.OnGUI(UnityEngine.Rect,UnityEditor.SerializedProperty,UnityEngine.GUIContent)">
            <summary>[Editor-Only] Draws this attribute's fields for the `property`.</summary>
        </member>
        <member name="M:Animancer.Units.UnitsAttribute.DoFieldGUI(UnityEngine.Rect,UnityEngine.GUIContent,System.Single@)">
            <summary>[Editor-Only] Draws this attribute's fields.</summary>
        </member>
        <member name="M:Animancer.Units.UnitsAttribute.DoSpecialFloatField(UnityEngine.Rect,UnityEngine.GUIContent,System.Single,Animancer.Editor.CompactUnitConversionCache)">
            <summary>[Editor-Only]
            Draws a <see cref="M:UnityEditor.EditorGUI.FloatField(UnityEngine.Rect,UnityEngine.GUIContent,System.Single)"/> with an alternate string when it is not
            selected (for example, "1" might become "1s" to indicate "seconds").
            </summary>
            <remarks>
            This method treats most <see cref="T:UnityEngine.EventType"/>s normally, but for <see cref="F:UnityEngine.EventType.Repaint"/> it
            instead draws a text field with the converted string.
            </remarks>
        </member>
        <member name="M:Animancer.Units.UnitsAttribute.GetDisplayValue(System.Single,System.Single)">
            <summary>[Editor-Only] Returns the value that should be displayed for a given field.</summary>
        </member>
        <member name="T:Animancer.OptionalWarning">
            <summary>
            Bitwise flags used by <see cref="M:Animancer.Validate.IsEnabled(Animancer.OptionalWarning)"/> and <see cref="M:Animancer.Validate.Disable(Animancer.OptionalWarning)"/> to determine which
            warnings Animancer should give.
            <para></para>
            <strong>These warnings are all optional</strong>. Feel free to disable any of them if you understand the
            <em>potential</em> issues they are referring to.
            </summary>
            
            <remarks>
            All warnings are enabled by default, but are compiled out of runtime builds (except development builds).
            <para></para>
            You can manually disable warnings using the Settings in the <see cref="T:Animancer.Editor.Tools.AnimancerToolsWindow"/>
            (<c>Window/Animation/Animancer Tools</c>).
            </remarks>
            
            <example>
            You can put the following method in any class to disable whatever warnings you don't want on startup:
            <para></para><code>
            #if UNITY_ASSERTIONS
            [UnityEngine.RuntimeInitializeOnLoadMethod(UnityEngine.RuntimeInitializeLoadType.BeforeSceneLoad)]
            private static void DisableAnimancerWarnings()
            {
                Animancer.OptionalWarning.ProOnly.Disable();
                
                // You could disable OptionalWarning.All, but that is not recommended for obvious reasons.
            }
            #endif
            </code></example>
            https://kybernetik.com.au/animancer/api/Animancer/OptionalWarning
            
        </member>
        <member name="F:Animancer.OptionalWarning.ProOnly">
            <summary>
            A <see href="https://kybernetik.com.au/animancer/docs/introduction/features">Pro-Only Feature</see> has been
            used in <see href="https://kybernetik.com.au/animancer/redirect/lite">Animancer Lite</see>.
            </summary>
            
            <remarks>
            Some <see href="https://kybernetik.com.au/animancer/docs/introduction/features">Features</see> are only
            available in <see href="https://kybernetik.com.au/animancer/redirect/pro">Animancer Pro</see>.
            <para></para>
            <see href="https://kybernetik.com.au/animancer/redirect/lite">Animancer Lite</see> allows you to try out those
            features in the Unity Editor and gives this warning the first time each one is used to inform you that they
            will not work in runtime builds.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.CreateGraphWhileDisabled">
            <summary>
            An <see cref="!:AnimancerComponent.Playable"/> is being initialized while its <see cref="T:UnityEngine.GameObject"/> is
            inactive.
            </summary>
            
            <remarks>
            Unity will not call <see cref="!:AnimancerComponent.OnDestroy"/> if the <see cref="T:UnityEngine.GameObject"/> is never
            enabled. That would prevent it from destroying the internal <see cref="T:UnityEngine.Playables.PlayableGraph"/>, leading to a
            memory leak.
            <para></para>
            Animations usually shouldn't be played on inactive objects so you most likely just need to call
            <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)"/> first.
            <para></para>
            If you do intend to use it while inactive, you will need to disable this warning and call
            <see cref="!:AnimancerComponent.OnDestroy"/> manually when the object is destroyed (such as when its scene is
            unloaded).
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.CreateGraphDuringGuiEvent">
            <summary>
            An <see cref="!:AnimancerComponent.Playable"/> is being initialized during a type of GUI event that shouldn't
            cause side effects.
            </summary>
            
            <remarks>
            <see cref="F:UnityEngine.EventType.Layout"/> and <see cref="F:UnityEngine.EventType.Repaint"/> should display the current details of
            things, but they should not modify things.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.AnimatorDisabled">
            <summary>
            The <see cref="!:AnimancerComponent.Animator"/> is disabled so Animancer won't be able to play animations.
            </summary>
            
            <remarks>
            The <see cref="T:UnityEngine.Animator"/> doesn't need an Animator Controller, it just needs to be enabled via the
            checkbox in the Inspector or by setting <c>animancerComponent.Animator.enabled = true;</c> in code.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.NativeControllerHumanoid">
            <summary>
            An <see cref="P:UnityEngine.Animator.runtimeAnimatorController"/> is assigned but the Rig is Humanoid so it can't be
            blended with Animancer.
            </summary>
            
            <remarks>
            <see href="https://kybernetik.com.au/animancer/docs/manual/animator-controllers#native">Native</see>
            Animator Controllers can blend with Animancer on Generic Rigs, but not on Humanoid Rigs (you can swap back
            and forth between the Animator Controller and Animancer, but it won't smoothly blend between them).
            <para></para>
            If you don't intend to blend between them, you can just disable this warning.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.NativeControllerHybrid">
            <summary>
            An <see cref="P:UnityEngine.Animator.runtimeAnimatorController"/> is assigned while also using a
            <see cref="!:HybridAnimancerComponent"/>.
            </summary>
            
            <remarks>
            Either assign the <see cref="P:UnityEngine.Animator.runtimeAnimatorController"/> to use it as a Native Animator
            Controller or assign the <see cref="!:HybridAnimancerComponent.Controller"/> to use it as a Hybrid Animator
            Controller. The differences are explained in the
            <see href="https://kybernetik.com.au/animancer/docs/manual/animator-controllers">Documentation</see>
            <para></para>
            It is possible to use both, but it usually only happens when misunderstanding how the system works. If you
            do want both, just disable this warning.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.DuplicateEvent">
            <summary>
            An <see href="https://kybernetik.com.au/animancer/docs/manual/events/animancer">Animancer Event</see> is
            being added to an <see cref="T:Animancer.AnimancerEvent.Sequence"/> which already contains an identical event.
            </summary>
            
            <remarks>
            This warning often occurs due to a misunderstanding about the way events are
            <see href="https://kybernetik.com.au/animancer/docs/manual/events/animancer#auto-clear">Automatically
            Cleared</see>.
            <para></para>
            If you play an <see cref="T:UnityEngine.AnimationClip"/>, its <see cref="P:Animancer.AnimancerState.Events"/> will be empty so you
            can add whatever events you want.
            <para></para>
            But <see href="https://kybernetik.com.au/animancer/docs/manual/transitions">Transitions</see> store their own
            events, so if you play one then modify its <see cref="P:Animancer.AnimancerState.Events"/> you are actually modifying
            the transition's events. Then if you play the same transition again, you will modify the events again,
            often leading to the same event being added multiple times.
            <para></para>
            If that is not the case, you can simply disable this warning. There is nothing inherently wrong with having
            multiple identical events in the same sequence.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.EndEventInterrupt">
            <summary>
            An <see href="https://kybernetik.com.au/animancer/docs/manual/events/end">End Event</see> did not actually
            end the animation.
            </summary>
            
            <remarks>
            <see href="https://kybernetik.com.au/animancer/docs/manual/events/end">End Events</see> are triggered every
            frame after their time has passed, so in this case it might be necessary to explicitly clear the event or
            simply use a regular <see href="https://kybernetik.com.au/animancer/docs/manual/events/animancer">Animancer Event</see>.
            <para></para>
            If you intend for the event to keep getting triggered, you can just disable this warning.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.UselessEvent">
            <summary>
            An <see cref="T:Animancer.AnimancerEvent"/> that does nothing was invoked. Most likely it was not configured correctly.
            </summary>
            
            <remarks>
            Unused events should be removed to avoid wasting performance checking and invoking them.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.LockedEvents">
            <summary>
            An <see cref="T:Animancer.AnimancerEvent.Sequence"/> is being modified even though its
            <see cref="P:Animancer.AnimancerEvent.Sequence.ShouldNotModifyReason"/> is set.
            </summary>
            
            <remarks>
            This is primarily used by transitions. Their events should generally be configured on startup rather
            than repeating the setup on the state after the transition is played because such modifications will apply
            back to the transition's events (which is usually not intended).
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.UnsupportedEvents">
            <summary>
            <see href="https://kybernetik.com.au/animancer/docs/manual/events/animancer">Animancer Events</see> are
            being used on a state that does not properly support them so they might not work as intended.
            </summary>
            
            <remarks>
            <see href="https://kybernetik.com.au/animancer/docs/manual/events/animancer">Animancer Events</see> on a
            <see cref="T:Animancer.ControllerState"/> will be triggered based on its <see cref="P:Animancer.AnimancerState.NormalizedTime"/>,
            which comes from the current state of its Animator Controller regardless of which state that may be.
            <para></para>
            If you intend for the event to be associated with a specific state inside the Animator Controller, you need
            to use <see href="https://kybernetik.com.au/animancer/docs/manual/events/animation">Animation Events</see>
            instead.
            <para></para>
            But if you intend the event to be triggered by any state inside the Animator Controller, then you can
            simply disable this warning.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.UnsupportedSpeed">
            <summary><see cref="P:Animancer.AnimancerNode.Speed"/> is being used on a state that doesn't support it.</summary>
            
            <remarks>
            <see cref="M:UnityEngine.Playables.PlayableExtensions.SetSpeed``1(``0,System.Double)"/> does nothing on <see cref="T:Animancer.ControllerState"/>s so there is no
            way to directly control their speed. The
            <see href="https://kybernetik.com.au/animancer/docs/bugs/animator-controller-speed">Animator Controller Speed</see>
            page explains a possible workaround for this issue.
            <para></para>
            The only reason you would disable this warning is if you are setting the speed of states in general and
            not depending on it to actually take effect.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.UnsupportedIK">
            <summary>
            <see href="https://kybernetik.com.au/animancer/docs/manual/ik">Inverse Kinematics</see> cannot be
            dynamically enabled on some <see href="https://kybernetik.com.au/animancer/docs/manual/playing/states">States</see>
            Types.
            </summary>
            
            <remarks>
            To use IK on a <see cref="T:Animancer.ControllerState"/> you must instead enable it on the desired layer inside the
            Animator Controller.
            <para></para>
            IK is not supported by <see cref="T:Animancer.PlayableAssetState"/>.
            <para></para>
            Setting <see cref="P:Animancer.AnimancerNode.ApplyAnimatorIK"/> on such a state will simply do nothing, so feel free to
            disable this warning if you are enabling IK on states without checking their type.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.MixerMinChildren">
            <summary>
            A <see cref="T:Animancer.ManualMixerState"/> is being initialized with its <see cref="P:Animancer.AnimancerNode.ChildCount"/> &lt;= 1.
            </summary>
            
            <remarks>
            The purpose of a mixer is to mix multiple child states so you are probably initializing it with incorrect
            parameters.
            <para></para>
            A mixer with only one child will simply play that child, so feel free to disable this warning if that is
            what you intend to do.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.MixerSynchronizeZeroLength">
            <summary>
            A <see cref="T:Animancer.ManualMixerState"/> is synchronizing a child with <see cref="P:Animancer.AnimancerState.Length"/> = 0.
            </summary>
            
            <remarks>
            Synchronization is based on the <see cref="P:Animancer.AnimancerState.NormalizedTime"/> which can't be calculated if
            the <see cref="P:Animancer.AnimancerState.Length"/> is 0.
            <para></para>
            Some state types can change their <see cref="P:Animancer.AnimancerState.Length"/>, in which case you can just disable
            this warning. But otherwise, the indicated state should not be added to the synchronization list.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.CustomFadeBounds">
            <summary>
            A <see href="https://kybernetik.com.au/animancer/docs/manual/blending/fading#custom-fade">Custom Fade</see>
            is being started but its weight calculation does not go from 0 to 1.
            </summary>
            
            <remarks>
            The <see cref="!:CustomFade.CalculateWeight"/> method is expected to return 0 when the parameter is 0 and
            1 when the parameter is 1. It can do anything you want with other values, but violating that guideline will
            trigger this warning because it would likely lead to undesirable results.
            <para></para>
            If your <see cref="!:CustomFade.CalculateWeight"/> method is expensive you could disable this warning to save
            some performance, but violating the above guidelines is not recommended.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.CustomFadeNotNull">
            <summary>
            A weight calculation method was not specified when attempting to start a
            <see href="https://kybernetik.com.au/animancer/docs/manual/blending/fading#custom-fade">Custom Fade</see>.
            </summary>
            
            <remarks>
            Passing a <c>null</c> parameter into <see cref="!:CustomFade.Apply(AnimancerState, AnimationCurve)"/> and
            other similar methods will trigger this warning and return <c>null</c> because a <see cref="!:CustomFade"/>
            serves no purpose if it doesn't have a method for calculating the weight.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.AnimatorSpeed">
            <summary>
            The <see cref="P:UnityEngine.Animator.speed"/> property does not affect Animancer. 
            Use <see cref="P:Animancer.AnimancerPlayable.Speed"/> instead.
            </summary>
            
            <remarks>
            The <see cref="P:UnityEngine.Animator.speed"/> property only works with Animator Controllers but does not affect the
            Playables API so Animancer has its own <see cref="P:Animancer.AnimancerPlayable.Speed"/> property.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.UnusedNode">
            <summary>An <see cref="P:Animancer.AnimancerNode.Root"/> is null during finalization (garbage collection).</summary>
            <remarks>
            This probably means that node was never used for anything and should not have been created.
            <para></para>
            This warning can be prevented for a specific node by passing it into <see cref="M:System.GC.SuppressFinalize(System.Object)"/>.
            <para></para>
            To minimise the performance cost of checking this warning, it does not capture the stack trace of the
            node's creation by default. However, you can enable <see cref="P:Animancer.AnimancerNode.TraceConstructor"/> on startup
            so that it can include the stack trace in the warning message for any nodes that end up being unused.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.PlayableAssetAnimatorBinding">
            <summary>
            <see cref="M:Animancer.PlayableAssetState.InitializeBindings"/> is trying to bind to the same <see cref="T:UnityEngine.Animator"/>
            that is being used by Animancer.
            </summary>
            <remarks>
            Doing this will replace Animancer's output so its animations would not work anymore.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.CloneComplexState">
            <summary>
            <see cref="M:Animancer.AnimancerLayer.GetOrCreateWeightlessState(Animancer.AnimancerState)"/> is cloning a complex state such as a
            <see cref="T:Animancer.ManualMixerState"/> or <see cref="T:Animancer.ControllerState"/>. This has a larger performance cost than cloning
            a <see cref="T:Animancer.ClipState"/> and these states generally have parameters that need to be controlled which may
            result in undesired behaviour if your scripts are only expecting to have one state to control.
            </summary>
            <remarks>
            The <see href="https://kybernetik.com.au/animancer/docs/manual/blending/fading/modes">Fade Modes</see> page
            explains why clones are created.
            </remarks>
        </member>
        <member name="F:Animancer.OptionalWarning.All">
            <summary>All warning types.</summary>
        </member>
        <member name="T:Animancer.Validate">
            https://kybernetik.com.au/animancer/api/Animancer/Validate
            <summary>
            Enforces various rules throughout the system, most of which are compiled out if UNITY_ASSERTIONS is not defined
            (by default, it is only defined in the Unity Editor and in Development Builds).
            </summary>
            https://kybernetik.com.au/animancer/api/Animancer/Validate
            
            https://kybernetik.com.au/animancer/api/Animancer/Validate
        </member>
        <member name="F:Animancer.Validate._DisabledWarnings">
            <summary>[Assert-Only] The <see cref="T:Animancer.OptionalWarning"/> flags that are currently disabled (default none).</summary>
        </member>
        <member name="M:Animancer.Validate.Disable(Animancer.OptionalWarning)">
            <summary>[Animancer Extension] [Assert-Conditional]
            Disables the specified warning type. Supports bitwise combinations.
            </summary>
            <example>
            You can put the following method in any class to disable whatever warnings you don't want on startup:
            <para></para><code>
            #if UNITY_ASSERTIONS
            [UnityEngine.RuntimeInitializeOnLoadMethod(UnityEngine.RuntimeInitializeLoadType.BeforeSceneLoad)]
            private static void DisableAnimancerWarnings()
            {
                Animancer.OptionalWarning.EndEventInterrupt.Disable();
                
                // You could disable OptionalWarning.All, but that is not recommended for obvious reasons.
            }
            #endif
            </code></example>
        </member>
        <member name="M:Animancer.Validate.Enable(Animancer.OptionalWarning)">
            <summary>[Animancer Extension] [Assert-Conditional]
            Enables the specified warning type. Supports bitwise combinations.
            </summary>
        </member>
        <member name="M:Animancer.Validate.SetEnabled(Animancer.OptionalWarning,System.Boolean)">
            <summary>[Animancer Extension] [Assert-Conditional]
            Enables or disables the specified warning type. Supports bitwise combinations.
            </summary>
        </member>
        <member name="M:Animancer.Validate.Log(Animancer.OptionalWarning,System.String,System.Object)">
            <summary>[Animancer Extension] [Assert-Conditional]
            Logs the `message` as a warning if the `type` is enabled.
            </summary>
        </member>
        <member name="M:Animancer.Validate.IsEnabled(Animancer.OptionalWarning)">
            <summary>[Animancer Extension] [Assert-Only] Are none of the specified warning types disabled?</summary>
        </member>
        <member name="M:Animancer.Validate.IsDisabled(Animancer.OptionalWarning)">
            <summary>[Animancer Extension] [Assert-Only] Are all of the specified warning types disabled?</summary>
        </member>
        <member name="M:Animancer.Validate.DisableTemporarily(Animancer.OptionalWarning)">
            <summary>[Animancer Extension] [Assert-Only]
            Disables the specified warnings and returns those that were previously enabled.
            </summary>
            <remarks>Call <see cref="M:Animancer.Validate.Enable(Animancer.OptionalWarning)"/> on the returned value to re-enable it.</remarks>
        </member>
        <member name="P:Animancer.Validate.PermanentlyDisabledWarnings">
            <summary>[Assert-Only] Warnings that are automatically disabled and stored in <see cref="T:UnityEngine.PlayerPrefs"/>.</summary>
        </member>
        <member name="M:Animancer.Validate.AssertNotLegacy(UnityEngine.AnimationClip)">
            <summary>[Assert-Conditional] Throws if the `clip` is marked as <see cref="P:UnityEngine.AnimationClip.legacy"/>.</summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.Validate.AssertRoot(Animancer.AnimancerNode,Animancer.AnimancerPlayable)">
            <summary>[Assert-Conditional] Throws if the <see cref="P:Animancer.AnimancerNode.Root"/> is not the `root`.</summary>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:Animancer.Validate.AssertPlayable(Animancer.AnimancerNode)">
            <summary>[Assert-Conditional] Throws if the `node`'s <see cref="T:UnityEngine.Playables.Playable"/> is invalid.</summary>
            <exception cref="T:System.InvalidOperationException"/>
        </member>
        <member name="M:Animancer.Validate.AssertCanRemoveChild(Animancer.AnimancerState,System.Collections.Generic.IList{Animancer.AnimancerState},System.Int32)">
            <summary>[Assert-Conditional]
            Throws if the `state` was not actually assigned to its specified <see cref="P:Animancer.AnimancerNode.Index"/> in
            the `states`.
            </summary>
            <exception cref="T:System.InvalidOperationException"/>
            <exception cref="T:System.IndexOutOfRangeException">
            The <see cref="P:Animancer.AnimancerNode.Index"/> is larger than the number of `states`.
            </exception>
        </member>
        <member name="M:Animancer.Validate.LiteFadeDuration(System.Single@,System.Object)">
            <summary>[Internal] [Lite-Only]
            Ensures that only 0 or the default 0.25s fade duration can be used (warn in Editor, enforce at Runtime).
            </summary>
        </member>
        <member name="M:Animancer.Validate.LiteWeight(System.Single@,System.Object)">
            <summary>[Internal] [Lite-Only]
            Ensures that only 0 or 1 weight can be used (warn in Editor, enforce at Runtime).
            </summary>
        </member>
        <member name="M:Animancer.Validate.LiteSpeed(System.Single@,System.Object)">
            <summary>[Internal] [Lite-Only]
            Ensures that only 1 speed can be used (warn in Editor, enforce at Runtime).
            </summary>
        </member>
        <member name="M:Animancer.Validate.LiteTime(System.Double@,System.Object)">
            <summary>[Internal] [Lite-Only]
            Ensures that only 0 time can be used (warn in Editor, enforce at Runtime).
            </summary>
        </member>
        <member name="M:Animancer.Validate.LiteLayerListType(Animancer.AnimancerPlayable.LayerList)">
            <summary>[Internal] [Lite-Only]
            Ensures that only the inbuilt <see cref="T:Animancer.AnimancerPlayable.LayerList"/> can be used (warn in Editor,
            enforce at Runtime).
            </summary>
        </member>
        <member name="M:Animancer.Validate.LiteNodeType(Animancer.AnimancerNode)">
            <summary>[Internal] [Lite-Only]
            Ensures that only inbuilt <see cref="T:Animancer.AnimancerNode"/> types can be used (warn in Editor, enforce at
            Runtime).
            </summary>
        </member>
        <member name="M:Animancer.Validate.LiteUpdatableType(Animancer.IUpdatable,System.Object)">
            <summary>[Internal] [Lite-Only]
            Ensures that only inbuilt <see cref="T:Animancer.AnimancerNode"/> types can be used (warn in Editor, enforce at
            Runtime).
            </summary>
        </member>
        <member name="F:Animancer.Validate.ProOnlyMessage">
            <summary>[Lite-Only]
            A message which explains that some features are only available in the Unity Editor for trial purposes in
            Animancer Lite, but not at runtime.
            </summary>
        </member>
        <member name="M:Animancer.Validate.LogProOnlyFeature(System.String,System.String,System.Object)">
            <summary>[Internal] [Lite-Only]
            Logs a message the first time each Pro-Only `feature` is used.
            </summary>
        </member>
        <member name="T:Animancer.Validate.Value">
            <summary>A rule that defines which values are valid.</summary>
            https://kybernetik.com.au/animancer/api/Animancer/Value
        </member>
        <member name="F:Animancer.Validate.Value.Any">
            <summary>Any value is allowed.</summary>
        </member>
        <member name="F:Animancer.Validate.Value.ZeroToOne">
            <summary>Only values between 0 (inclusive) and 1 (inclusive) are allowed.</summary>
        </member>
        <member name="F:Animancer.Validate.Value.IsNotNegative">
            <summary>Only 0 or positive values are allowed.</summary>
        </member>
        <member name="F:Animancer.Validate.Value.IsFinite">
            <summary>Infinity and NaN are not allowed.</summary>
        </member>
        <member name="F:Animancer.Validate.Value.IsFiniteOrNaN">
            <summary>Infinity is not allowed.</summary>
        </member>
        <member name="M:Animancer.Validate.ValueRule(System.Single@,Animancer.Validate.Value)">
            <summary>Enforces the `rule` on the `value`.</summary>
        </member>
        <member name="T:Animancer.IPolymorphic">
            <summary>An object that will be drawn by a <see cref="T:Animancer.Editor.PolymorphicDrawer"/>.</summary>
        </member>
        <member name="T:Animancer.IPolymorphicReset">
            <summary>An <see cref="T:Animancer.IPolymorphic"/> with a <see cref="M:Animancer.IPolymorphicReset.Reset"/> method.</summary>
        </member>
        <member name="M:Animancer.IPolymorphicReset.Reset">
            <summary>Called when an instance of this type is created in a [<see cref="T:UnityEngine.SerializeReference"/>] field.</summary>
        </member>
        <member name="T:Animancer.PolymorphicAttribute">
            <summary>The attributed field will be drawn by a <see cref="T:Animancer.Editor.PolymorphicDrawer"/>.</summary>
        </member>
        <member name="T:Animancer.SimpleTimer">
            <summary>A very simple timer system based on a <see cref="T:System.Diagnostics.Stopwatch"/>.</summary>
        </member>
        <member name="F:Animancer.SimpleTimer.Stopwatch">
            <summary>The system used to track time.</summary>
        </member>
        <member name="P:Animancer.SimpleTimer.CurrentTime">
            <summary>The amount of time that has passed (in seconds) since the first timer was started.</summary>
        </member>
        <member name="F:Animancer.SimpleTimer.name">
            <summary>An optional prefix for <see cref="M:Animancer.SimpleTimer.ToString"/>.</summary>
        </member>
        <member name="F:Animancer.SimpleTimer.startTime">
            <summary>The <see cref="P:Animancer.SimpleTimer.CurrentTime"/> from when this timer instance was started.</summary>
        </member>
        <member name="F:Animancer.SimpleTimer.total">
            <summary>The total amount of time this timer instance has been running (in seconds).</summary>
        </member>
        <member name="F:Animancer.SimpleTimer.Format">
            <summary>The number format used by <see cref="M:Animancer.SimpleTimer.ToString"/>.</summary>
        </member>
        <member name="P:Animancer.SimpleTimer.IsStarted">
            <summary>Has <see cref="M:Animancer.SimpleTimer.Start"/> been called and <see cref="M:Animancer.SimpleTimer.Stop"/> not?</summary>
        </member>
        <member name="M:Animancer.SimpleTimer.#ctor(System.String)">
            <summary>Creates a new <see cref="T:Animancer.SimpleTimer"/> with the specified `name`.</summary>
            <remarks>
            You will need to call <see cref="M:Animancer.SimpleTimer.Start"/> to start the timer. Or use the static
            <see cref="M:Animancer.SimpleTimer.Start(System.String)"/>
            </remarks>
        </member>
        <member name="M:Animancer.SimpleTimer.Start(System.String)">
            <summary>Creates a new <see cref="T:Animancer.SimpleTimer"/> with the specified `name` and starts it.</summary>
        </member>
        <member name="M:Animancer.SimpleTimer.Start">
            <summary>
            Stores the <see cref="P:Animancer.SimpleTimer.CurrentTime"/> in <see cref="F:Animancer.SimpleTimer.startTime"/> so that <see cref="M:Animancer.SimpleTimer.Stop"/> will be able to
            calculate how much time has passed.
            </summary>
            <remarks>Does nothing if the <see cref="F:Animancer.SimpleTimer.startTime"/> was already set.</remarks>
        </member>
        <member name="M:Animancer.SimpleTimer.Stop">
            <summary>
            Adds the amount of time that has passed since the <see cref="F:Animancer.SimpleTimer.startTime"/> to the <see cref="F:Animancer.SimpleTimer.total"/> and
            clears the <see cref="F:Animancer.SimpleTimer.startTime"/>.
            </summary>
            <remarks>Does nothing if the <see cref="F:Animancer.SimpleTimer.startTime"/> was already cleared (or not set).</remarks>
        </member>
        <member name="M:Animancer.SimpleTimer.ToString">
            <summary>Calls <see cref="M:Animancer.SimpleTimer.Stop"/> and returns a string representation of the <see cref="F:Animancer.SimpleTimer.total"/>.</summary>
        </member>
        <member name="M:Animancer.SimpleTimer.Dispose">
            <summary>Calls <see cref="M:Animancer.SimpleTimer.ToString"/> and logs the result.</summary>
        </member>
        <member name="T:Animancer.Strings">
            <summary>Various string constants used throughout <see cref="N:Animancer"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer/Strings
            
        </member>
        <member name="F:Animancer.Strings.ProductName">
            <summary>The name of this product.</summary>
        </member>
        <member name="F:Animancer.Strings.MenuPrefix">
            <summary>The standard prefix for <see cref="T:UnityEngine.AddComponentMenu"/>.</summary>
        </member>
        <member name="F:Animancer.Strings.CreateMenuPrefix">
            <summary>The standard prefix for the asset creation menu (for <see cref="T:UnityEditor.MenuItem"/>).</summary>
        </member>
        <member name="F:Animancer.Strings.ExamplesMenuPrefix">
            <summary>The standard prefix for <see cref="T:UnityEngine.AddComponentMenu"/> for the examples.</summary>
        </member>
        <member name="F:Animancer.Strings.AnimancerToolsMenuPath">
            <summary>The menu path of the <see cref="T:Animancer.Editor.Tools.AnimancerToolsWindow"/>.</summary>
        </member>
        <member name="F:Animancer.Strings.AssetMenuOrder">
            <summary>
            The base value for <see cref="P:UnityEngine.CreateAssetMenuAttribute.order"/> to group
            "Assets/Create/Animancer/..." menu items just under "Avatar Mask".
            </summary>
        </member>
        <member name="F:Animancer.Strings.UnityEditor">
            <summary>The conditional compilation symbol for Editor-Only code.</summary>
        </member>
        <member name="F:Animancer.Strings.Assertions">
            <summary>The conditional compilation symbol for assertions.</summary>
        </member>
        <member name="F:Animancer.Strings.Indent">
            <summary>4 spaces for indentation.</summary>
        </member>
        <member name="F:Animancer.Strings.ProOnlyTag">
            <summary>A prefix for tooltips on Pro-Only features.</summary>
            <remarks><c>"[Pro-Only] "</c> in Animancer Lite or <c>""</c> in Animancer Pro.</remarks>
        </member>
        <member name="F:Animancer.Strings.NoRename">
            <summary>[Internal] [Lite-Only]
            Disables member renaming in a [<see cref="T:System.Reflection.ObfuscationAttribute"/>].
            </summary>
        </member>
        <member name="F:Animancer.Strings.MustBeFinite">
            <summary>An error message for when <see cref="M:Animancer.AnimancerUtilities.IsFinite(System.Single)"/> fails.</summary>
        </member>
        <member name="F:Animancer.Strings.AnimatorDisabledMessage">
            <summary>[Assert-Only] A message for <see cref="F:Animancer.OptionalWarning.AnimatorDisabled"/>.</summary>
        </member>
        <member name="T:Animancer.Strings.DocsURLs">
            <summary>URLs of various documentation pages.</summary>
            https://kybernetik.com.au/animancer/api/Animancer/DocsURLs
            
        </member>
        <member name="F:Animancer.Strings.DocsURLs.Documentation">
            <summary>The URL of the website where the Animancer documentation is hosted.</summary>
        </member>
        <member name="F:Animancer.Strings.DocsURLs.APIDocumentation">
            <summary>The URL of the website where the Animancer API documentation is hosted.</summary>
        </member>
        <member name="F:Animancer.Strings.DocsURLs.ExampleAPIDocumentation">
            <summary>The URL of the website where the Animancer API documentation is hosted.</summary>
        </member>
        <member name="F:Animancer.Strings.DocsURLs.DeveloperEmail">
            <summary>The email address which handles support for Animancer.</summary>
        </member>
        <member name="F:Animancer.Strings.DocsURLs.LatestVersion">
            <summary>The URL of the file which lists Animancer's latest version.</summary>
        </member>
        <member name="T:Animancer.Strings.Tooltips">
            <summary>Tooltips for various fields.</summary>
            https://kybernetik.com.au/animancer/api/Animancer/Tooltips
            
        </member>
        <member name="T:Animancer.IAnimancerComponent">
            <summary>Interface for components that manage an <see cref="T:Animancer.AnimancerPlayable"/>.</summary>
            <remarks>
            Despite the name, this interface is not necessarily limited to only <see cref="T:UnityEngine.Component"/>s.
            <para></para>
            This interface allows Animancer Lite to reference an <see cref="!:AnimancerComponent"/> inside the pre-compiled
            DLL while allowing that component to remain outside as a regular script. Otherwise everything would need to be
            in the DLL which would cause Unity to lose all the script references when upgrading from Animancer Lite to Pro.
            <para></para>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/playing/component-types">Component Types</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/IAnimancerComponent
            
        </member>
        <member name="P:Animancer.IAnimancerComponent.enabled">
            <summary>Will this component be updated?</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.gameObject">
            <summary>The <see cref="T:UnityEngine.GameObject"/> this component is attached to.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.Animator">
            <summary>The <see cref="T:UnityEngine.Animator"/> component which this script controls.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.Playable">
            <summary>The internal system which manages the playing animations.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.IsPlayableInitialized">
            <summary>Has the <see cref="P:Animancer.IAnimancerComponent.Playable"/> been initialized?</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.ResetOnDisable">
            <summary>Will the object be reset to its original values when disabled?</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.UpdateMode">
            <summary>
            Determines when animations are updated and which time source is used. This property is mainly a wrapper
            around the <see cref="P:UnityEngine.Animator.updateMode"/>.
            </summary>
        </member>
        <member name="M:Animancer.IAnimancerComponent.GetKey(UnityEngine.AnimationClip)">
            <summary>Returns the dictionary key to use for the `clip`.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.AnimatorFieldName">
            <summary>[Editor-Only] The name of the serialized backing field for the <see cref="P:Animancer.IAnimancerComponent.Animator"/> property.</summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.ActionOnDisableFieldName">
            <summary>[Editor-Only]
            The name of the serialized backing field for the <see cref="!:AnimancerComponent.ActionOnDisable"/> property.
            </summary>
        </member>
        <member name="P:Animancer.IAnimancerComponent.InitialUpdateMode">
            <summary>[Editor-Only] The <see cref="P:Animancer.IAnimancerComponent.UpdateMode"/> that was first used when this script initialized.</summary>
            <remarks>
            This is used to give a warning when changing to or from <see cref="F:UnityEngine.AnimatorUpdateMode.AnimatePhysics"/> at
            runtime since it won't work correctly.
            </remarks>
        </member>
        <member name="T:Animancer.IAnimationClipCollection">
            <summary>
            A variant of <see cref="T:UnityEngine.IAnimationClipSource"/> which uses a <see cref="T:System.Collections.Generic.ICollection`1"/> instead of a
            <see cref="T:System.Collections.Generic.List`1"/> so that it can take a <see cref="T:System.Collections.Generic.HashSet`1"/> to efficiently avoid adding duplicates.
            <see cref="T:Animancer.AnimancerUtilities"/> contains various extension methods for this purpose.
            </summary>
            <remarks>
            <see cref="T:UnityEngine.IAnimationClipSource"/> still needs to be the main point of entry for the Animation Window, so this
            interface is only used internally.
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/IAnimationClipCollection
            
        </member>
        <member name="M:Animancer.IAnimationClipCollection.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <summary>Adds all the animations associated with this object to the `clips`.</summary>
        </member>
        <member name="T:Animancer.ICharacterRoot">
            <summary>
            Interface for components to indicate which <see cref="T:UnityEngine.GameObject"/> is the root of a character when
            <see cref="M:Animancer.Editor.AnimancerEditorUtilities.FindRoot(UnityEngine.GameObject)"/> is called.
            </summary>
            https://kybernetik.com.au/animancer/api/Animancer/ICharacterRoot
            
        </member>
        <member name="P:Animancer.ICharacterRoot.transform">
             <summary>
             The <see cref="T:UnityEngine.Transform"/> to search for <see cref="T:UnityEngine.AnimationClip"/>s beneath.
             </summary>
            
             <example>
             Implementing this interface in a <see cref="T:UnityEngine.MonoBehaviour"/> will automatically inherit this property so
             you do not need to do anything else:
             <para></para><code>
             public class MyComponent : MonoBehaviour, IAnimancerRoot
             {
             }
             </code>
             But if you want to have your script point to a different object as the root, you can explicitly implement
             this property:
             <para></para><code>
             public class MyComponent : MonoBehaviour, IAnimancerRoot
             {
                 Transform IAnimancerRoot.transform => ???;
             }
             </code></example>
        </member>
        <member name="T:Animancer.ICopyable`1">
            <summary>Interface for objects that can be copied.</summary>
            https://kybernetik.com.au/animancer/api/Animancer/ICopyable_1
            https://kybernetik.com.au/flexi-motion/api/FlexiMotion/ICopyable_1
            
        </member>
        <member name="M:Animancer.ICopyable`1.CopyFrom(`0)">
            <summary>Copies the contents of `copyFrom` into this object, replacing its previous contents.</summary>
            <remarks><see cref="M:Animancer.AnimancerUtilities.Clone``1(``0)"/> uses this method internally.</remarks>
        </member>
        <member name="T:Animancer.IHasEvents">
            <summary>An object which has an <see cref="T:Animancer.AnimancerEvent.Sequence.Serializable"/>.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/events/animancer">Animancer Events</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/IHasEvents
            
        </member>
        <member name="P:Animancer.IHasEvents.Events">
            <summary>Events which will be triggered as the animation plays.</summary>
        </member>
        <member name="P:Animancer.IHasEvents.SerializedEvents">
            <summary>Events which will be triggered as the animation plays.</summary>
        </member>
        <member name="T:Animancer.ITransitionWithEvents">
            <summary>A combination of <see cref="T:Animancer.ITransition"/> and <see cref="T:Animancer.IHasEvents"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer/ITransitionWithEvents
            
        </member>
        <member name="T:Animancer.IHasKey">
            <summary>Exposes a <see cref="P:Animancer.IHasKey.Key"/> object that can be used for dictionaries and hash sets.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/playing/keys">Keys</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/IHasKey
            
        </member>
        <member name="P:Animancer.IHasKey.Key">
            <summary>An identifier object that can be used for dictionaries and hash sets.</summary>
        </member>
        <member name="T:Animancer.IMotion">
            <summary>An object with an <see cref="P:Animancer.IMotion.AverageAngularSpeed"/> and <see cref="P:Animancer.IMotion.AverageVelocity"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer/IMotion
            
        </member>
        <member name="P:Animancer.IMotion.AverageAngularSpeed">
            <summary>The initial <see cref="P:UnityEngine.Motion.averageAngularSpeed"/> that the created state will have.</summary>
            <remarks>The actual average can vary in states like <see cref="T:Animancer.ManualMixerState"/>.</remarks>
        </member>
        <member name="P:Animancer.IMotion.AverageVelocity">
            <summary>The initial <see cref="P:UnityEngine.Motion.averageSpeed"/> that the created state will have.</summary>
            <remarks>The actual average can vary in states like <see cref="T:Animancer.ManualMixerState"/>.</remarks>
        </member>
        <member name="T:Animancer.IPlayableWrapper">
            <summary>Interface for objects that manage a <see cref="T:UnityEngine.Playables.Playable"/>.</summary>
            https://kybernetik.com.au/animancer/api/Animancer/IPlayableWrapper
            
        </member>
        <member name="P:Animancer.IPlayableWrapper.Parent">
            <summary>The object which receives the output of the <see cref="P:Animancer.IPlayableWrapper.Playable"/>.</summary>
        </member>
        <member name="P:Animancer.IPlayableWrapper.Weight">
            <summary>The current blend weight of this node which determines how much it affects the final output.</summary>
        </member>
        <member name="P:Animancer.IPlayableWrapper.Playable">
            <summary>The <see cref="T:UnityEngine.Playables.Playable"/> managed by this object.</summary>
        </member>
        <member name="P:Animancer.IPlayableWrapper.ChildCount">
            <summary>The number of nodes using this object as their <see cref="P:Animancer.IPlayableWrapper.Parent"/>.</summary>
        </member>
        <member name="M:Animancer.IPlayableWrapper.GetChild(System.Int32)">
            <summary>Returns the state connected to the specified `index` as a child of this object.</summary>
        </member>
        <member name="P:Animancer.IPlayableWrapper.KeepChildrenConnected">
            <summary>
            Indicates whether child playables should stay connected to the graph at all times.
            <para></para>
            If false, playables will be disconnected from the graph while they are at 0 weight to stop it from
            evaluating them every frame.
            </summary>
            <seealso cref="P:Animancer.AnimancerPlayable.KeepChildrenConnected"/>
        </member>
        <member name="P:Animancer.IPlayableWrapper.Speed">
             <summary>How fast the <see cref="P:Animancer.AnimancerState.Time"/> is advancing every frame.</summary>
             
             <remarks>
             1 is the normal speed.
             <para></para>
             A negative value will play the animation backwards.
             <para></para>
             <em>Animancer Lite does not allow this value to be changed in runtime builds.</em>
             </remarks>
            
             <example><code>
             void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
             {
                 var state = animancer.Play(clip);
            
                 state.Speed = 1;// Normal speed.
                 state.Speed = 2;// Double speed.
                 state.Speed = 0.5f;// Half speed.
                 state.Speed = -1;// Normal speed playing backwards.
             }
             </code></example>
        </member>
        <member name="P:Animancer.IPlayableWrapper.ApplyAnimatorIK">
            <summary>
            Should Unity call <c>OnAnimatorIK</c> on the animated object while this object and its children have any
            <see cref="P:Animancer.AnimancerNode.Weight"/>?
            </summary>
            <remarks>
            This is equivalent to the "IK Pass" toggle in Animator Controller layers, except that due to limitations in
            the Playables API the <c>layerIndex</c> will always be zero.
            <para></para>
            This value starts false by default, but can be automatically changed by
            <see cref="M:Animancer.AnimancerNode.CopyIKFlags(Animancer.AnimancerNode)"/> when the <see cref="P:Animancer.IPlayableWrapper.Parent"/> is set.
            <para></para>
            IK only takes effect while at least one <see cref="T:Animancer.ClipState"/> has a <see cref="P:Animancer.AnimancerNode.Weight"/>
            above zero. Other node types either store the value to apply to their children or don't support IK.
            <para></para>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/ik#ik-pass">IK Pass</see>
            </remarks>
        </member>
        <member name="P:Animancer.IPlayableWrapper.ApplyFootIK">
            <summary>Should this object and its children apply IK to the character's feet?</summary>
            <remarks>
            This is equivalent to the "Foot IK" toggle in Animator Controller states.
            <para></para>
            This value starts true by default for <see cref="T:Animancer.ClipState"/>s (false for others), but can be automatically
            changed by <see cref="M:Animancer.AnimancerNode.CopyIKFlags(Animancer.AnimancerNode)"/> when the <see cref="P:Animancer.IPlayableWrapper.Parent"/> is set.
            <para></para>
            IK only takes effect while at least one <see cref="T:Animancer.ClipState"/> has a <see cref="P:Animancer.AnimancerNode.Weight"/>
            above zero. Other node types either store the value to apply to their children or don't support IK.
            <para></para>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/ik#foot-ik">Foot IK</see>
            </remarks>
        </member>
        <member name="T:Animancer.ITransition">
            <summary>An object which can create an <see cref="T:Animancer.AnimancerState"/> and set its details.</summary>
            <remarks>
            Transitions are generally used as arguments for <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>.
            <para></para>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions">Transitions</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/ITransition
            
        </member>
        <member name="M:Animancer.ITransition.CreateState">
            <summary>
            Creates and returns a new <see cref="T:Animancer.AnimancerState"/>.
            <para></para>
            Note that using methods like <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> will also call
            <see cref="M:Animancer.ITransition.Apply(Animancer.AnimancerState)"/>, so if you call this method manually you may want to call that method as well. Or you
            can just use <see cref="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)"/>.
            </summary>
            <remarks>
            The first time a transition is used on an object, this method is called to create the state and register it
            in the internal dictionary using the <see cref="P:Animancer.IHasKey.Key"/> so that it can be reused later on.
            </remarks>
        </member>
        <member name="P:Animancer.ITransition.FadeDuration">
            <summary>The amount of time this transition should take (in seconds).</summary>
        </member>
        <member name="P:Animancer.ITransition.FadeMode">
            <summary>
            The <see cref="T:Animancer.FadeMode"/> which should be used when this transition is passed into
            <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>.
            </summary>
        </member>
        <member name="M:Animancer.ITransition.Apply(Animancer.AnimancerState)">
            <summary>
            Called by <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/> to apply any modifications to the `state`.
            </summary>
            <remarks>
            Unlike <see cref="M:Animancer.ITransition.CreateState"/>, this method is called every time the transition is used so it can do
            things like set the <see cref="P:Animancer.AnimancerState.Events"/> or starting <see cref="P:Animancer.AnimancerState.Time"/>.
            </remarks>
        </member>
        <member name="T:Animancer.ITransition`1">
            <summary>An <see cref="T:Animancer.ITransition"/> which creates a specific type of <see cref="T:Animancer.AnimancerState"/>.</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions">Transitions</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/ITransition_1
            
        </member>
        <member name="P:Animancer.ITransition`1.State">
            <summary>
            The state that was created by this object. Specifically, this is the state that was most recently
            passed into <see cref="M:Animancer.ITransition.Apply(Animancer.AnimancerState)"/> (usually by <see cref="M:Animancer.AnimancerPlayable.Play(Animancer.ITransition)"/>).
            </summary>
        </member>
        <member name="M:Animancer.ITransition`1.CreateState">
            <summary>Creates and returns a new <typeparamref name="TState"/>.</summary>
        </member>
        <member name="T:Animancer.ITransitionDetailed">
            <summary>An <see cref="T:Animancer.ITransition"/> with some additional details (mainly for the Unity Editor GUI).</summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions">Transitions</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/ITransitionDetailed
            
        </member>
        <member name="P:Animancer.ITransitionDetailed.IsValid">
            <summary>Can this transition create a valid <see cref="T:Animancer.AnimancerState"/>?</summary>
        </member>
        <member name="P:Animancer.ITransitionDetailed.IsLooping">
            <summary>What will the value of <see cref="P:Animancer.AnimancerState.IsLooping"/> be for the created state?</summary>
        </member>
        <member name="P:Animancer.ITransitionDetailed.NormalizedStartTime">
            <summary>The <see cref="P:Animancer.AnimancerState.NormalizedTime"/> to start the animation at.</summary>
            <remarks><see cref="F:System.Single.NaN"/> allows the animation to continue from its current time.</remarks>
        </member>
        <member name="P:Animancer.ITransitionDetailed.MaximumDuration">
            <summary>The maximum amount of time the animation is expected to take (in seconds).</summary>
            <remarks>The actual duration can vary in states like <see cref="T:Animancer.ManualMixerState"/>.</remarks>
        </member>
        <member name="P:Animancer.ITransitionDetailed.Speed">
            <summary>The <see cref="P:Animancer.AnimancerNode.Speed"/> to play the animation at.</summary>
        </member>
        <member name="T:Animancer.IUpdatable">
             <summary>[Pro-Only] An object that can be updated during Animancer's animation updates.</summary>
            
             <example>
             Register to receive updates using <see cref="M:Animancer.AnimancerPlayable.RequirePreUpdate(Animancer.IUpdatable)"/> or
             <see cref="M:Animancer.AnimancerPlayable.RequirePostUpdate(Animancer.IUpdatable)"/> and stop
             receiving updates using <see cref="M:Animancer.AnimancerPlayable.CancelPreUpdate(Animancer.IUpdatable)"/> or
             <see cref="M:Animancer.AnimancerPlayable.CancelPostUpdate(Animancer.IUpdatable)"/>.
             <para></para><code>
             public sealed class MyUpdatable : Key, IUpdatable
             {
                 private AnimancerComponent _Animancer;
            
                 public void StartUpdating(AnimancerComponent animancer)
                 {
                     _Animancer = animancer;
                     
                     // If you want Update to be called before the playables get updated.
                     _Animancer.Playable.RequirePreUpdate(this);
                     
                     // If you want Update to be called after the playables get updated.
                     _Animancer.Playable.RequirePostUpdate(this);
                 }
            
                 public void StopUpdating()
                 {
                     // If you used RequirePreUpdate.
                     _Animancer.Playable.CancelPreUpdate(this);
                     
                     // If you used RequirePostUpdate.
                     _Animancer.Playable.CancelPostUpdate(this);
                 }
            
                 void IUpdatable.Update()
                 {
                     // Called during every animation update.
                     
                     // AnimancerPlayable.Current can be used to access the system it is being updated by.
                 }
             }
             </code></example>
             
             https://kybernetik.com.au/animancer/api/Animancer/IUpdatable
             
        </member>
        <member name="M:Animancer.IUpdatable.Update">
            <summary>Called during every <see cref="T:UnityEngine.Animator"/> update.</summary>
            <remarks>The <see cref="P:UnityEngine.Animator.updateMode"/> determines the update rate.</remarks>
        </member>
        <member name="T:Animancer.IWrapper">
            <summary>An object which wraps a <see cref="P:Animancer.IWrapper.WrappedObject"/> object.</summary>
            https://kybernetik.com.au/animancer/api/Animancer/IWrapper
            
        </member>
        <member name="P:Animancer.IWrapper.WrappedObject">
            <summary>The wrapped object.</summary>
            <remarks>
            Use <see cref="M:Animancer.AnimancerUtilities.GetWrappedObject(System.Object)"/> in case the <see cref="P:Animancer.IWrapper.WrappedObject"/> is also an
            <see cref="T:Animancer.IWrapper"/>.
            </remarks>
        </member>
        <member name="T:Animancer.CartesianMixerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which blends an array of other states together based on a two dimensional
            parameter and thresholds using Gradient Band Interpolation.
            </summary>
            <remarks>
            This mixer type is similar to the 2D Freeform Cartesian Blend Type in Mecanim Blend Trees.
            <para></para>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/blending/mixers">Mixers</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/CartesianMixerState
            
        </member>
        <member name="P:Animancer.CartesianMixerState.ParameterX">
            <summary><see cref="P:Animancer.MixerState`1.Parameter"/>.x.</summary>
        </member>
        <member name="P:Animancer.CartesianMixerState.ParameterY">
            <summary><see cref="P:Animancer.MixerState`1.Parameter"/>.y.</summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.GetParameterError(UnityEngine.Vector2)">
            <inheritdoc/>
        </member>
        <member name="F:Animancer.CartesianMixerState._BlendFactors">
            <summary>Precalculated values to speed up the recalculation of weights.</summary>
        </member>
        <member name="F:Animancer.CartesianMixerState._BlendFactorsDirty">
            <summary>Indicates whether the <see cref="F:Animancer.CartesianMixerState._BlendFactors"/> need to be recalculated.</summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.OnThresholdsChanged">
            <summary>
            Called whenever the thresholds are changed. Indicates that the internal blend factors need to be
            recalculated and calls <see cref="M:Animancer.CartesianMixerState.ForceRecalculateWeights"/>.
            </summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.ForceRecalculateWeights">
            <summary>
            Recalculates the weights of all <see cref="P:Animancer.ManualMixerState.ChildStates"/> based on the current value of the
            <see cref="P:Animancer.MixerState`1.Parameter"/> and the <see cref="F:Animancer.MixerState`1._Thresholds"/>.
            </summary>
        </member>
        <member name="M:Animancer.CartesianMixerState.Clone(Animancer.AnimancerPlayable)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.CartesianMixerState.Animancer#ICopyable{Animancer#CartesianMixerState}#CopyFrom(Animancer.CartesianMixerState)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.CartesianMixerState.AppendParameter(System.Text.StringBuilder,UnityEngine.Vector2)">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.CartesianMixerState.ParameterCount">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.CartesianMixerState.GetParameterName(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.CartesianMixerState.GetParameterType(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.CartesianMixerState.GetParameterValue(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.CartesianMixerState.SetParameterValue(System.Int32,System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.DirectionalMixerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which blends an array of other states together based on a two dimensional
            parameter and thresholds using Polar Gradient Band Interpolation.
            </summary>
            <remarks>
            This mixer type is similar to the 2D Freeform Directional Blend Type in Mecanim Blend Trees.
            <para></para>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/blending/mixers">Mixers</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/DirectionalMixerState
            
        </member>
        <member name="P:Animancer.DirectionalMixerState.ParameterX">
            <summary><see cref="P:Animancer.MixerState`1.Parameter"/>.x.</summary>
        </member>
        <member name="P:Animancer.DirectionalMixerState.ParameterY">
            <summary><see cref="P:Animancer.MixerState`1.Parameter"/>.y.</summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.GetParameterError(UnityEngine.Vector2)">
            <inheritdoc/>
        </member>
        <member name="F:Animancer.DirectionalMixerState._ThresholdMagnitudes">
            <summary>Precalculated magnitudes of all thresholds to speed up the recalculation of weights.</summary>
        </member>
        <member name="F:Animancer.DirectionalMixerState._BlendFactors">
            <summary>Precalculated values to speed up the recalculation of weights.</summary>
        </member>
        <member name="F:Animancer.DirectionalMixerState._BlendFactorsDirty">
            <summary>Indicates whether the <see cref="F:Animancer.DirectionalMixerState._BlendFactors"/> need to be recalculated.</summary>
        </member>
        <member name="F:Animancer.DirectionalMixerState.AngleFactor">
            <summary>The multiplier that controls how much an angle (in radians) is worth compared to normalized distance.</summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.OnThresholdsChanged">
            <summary>
            Called whenever the thresholds are changed. Indicates that the internal blend factors need to be
            recalculated and calls <see cref="M:Animancer.DirectionalMixerState.ForceRecalculateWeights"/>.
            </summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.ForceRecalculateWeights">
            <summary>
            Recalculates the weights of all <see cref="P:Animancer.ManualMixerState.ChildStates"/> based on the current value of the
            <see cref="P:Animancer.MixerState`1.Parameter"/> and the thresholds.
            </summary>
        </member>
        <member name="M:Animancer.DirectionalMixerState.Clone(Animancer.AnimancerPlayable)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.DirectionalMixerState.Animancer#ICopyable{Animancer#DirectionalMixerState}#CopyFrom(Animancer.DirectionalMixerState)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.DirectionalMixerState.AppendParameter(System.Text.StringBuilder,UnityEngine.Vector2)">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.DirectionalMixerState.ParameterCount">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.DirectionalMixerState.GetParameterName(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.DirectionalMixerState.GetParameterType(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.DirectionalMixerState.GetParameterValue(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.DirectionalMixerState.SetParameterValue(System.Int32,System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.LinearMixerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which blends an array of other states together using linear interpolation
            between the specified thresholds.
            </summary>
            <remarks>
            This mixer type is similar to the 1D Blend Type in Mecanim Blend Trees.
            <para></para>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/blending/mixers">Mixers</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/LinearMixerState
            
        </member>
        <member name="T:Animancer.LinearMixerState.ITransition">
            <summary>An <see cref="T:Animancer.ITransition`1"/> that creates a <see cref="T:Animancer.LinearMixerState"/>.</summary>
        </member>
        <member name="P:Animancer.LinearMixerState.ExtrapolateSpeed">
            <summary>
            Should setting the <see cref="P:Animancer.MixerState`1.Parameter"/> above the highest threshold increase the
            <see cref="P:Animancer.AnimancerNode.Speed"/> of this mixer proportionally?
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.GetParameterError(System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.LinearMixerState.Clone(Animancer.AnimancerPlayable)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.LinearMixerState.Animancer#ICopyable{Animancer#LinearMixerState}#CopyFrom(Animancer.LinearMixerState)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.LinearMixerState.OnThresholdsChanged">
            <summary>
            Called whenever the thresholds are changed. Indicates that <see cref="M:Animancer.LinearMixerState.AssertThresholdsSorted"/> needs to
            be called by the next <see cref="M:Animancer.LinearMixerState.ForceRecalculateWeights"/> if UNITY_ASSERTIONS is defined, then calls
            <see cref="M:Animancer.MixerState`1.OnThresholdsChanged"/>.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.AssertThresholdsSorted">
            <summary>
            Throws an <see cref="T:System.ArgumentException"/> if the thresholds are not sorted from lowest to highest without
            any duplicates.
            </summary>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:System.InvalidOperationException">The thresholds have not been initialized.</exception>
        </member>
        <member name="M:Animancer.LinearMixerState.ForceRecalculateWeights">
            <summary>
            Recalculates the weights of all <see cref="P:Animancer.ManualMixerState.ChildStates"/> based on the
            <see cref="P:Animancer.MixerState`1.Parameter"/> and the thresholds.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.AssignLinearThresholds(System.Single,System.Single)">
            <summary>
            Assigns the thresholds to be evenly spaced between the specified min and max (inclusive).
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.AppendDetails(System.Text.StringBuilder,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.LinearMixerState.ParameterCount">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.LinearMixerState.GetParameterName(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.LinearMixerState.GetParameterType(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.LinearMixerState.GetParameterValue(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.LinearMixerState.SetParameterValue(System.Int32,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.LinearMixerState.CreateDrawer">
            <summary>[Editor-Only] Returns a <see cref="T:Animancer.LinearMixerState.Drawer"/> for this state.</summary>
        </member>
        <member name="T:Animancer.LinearMixerState.Drawer">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.LinearMixerState.Drawer.#ctor(Animancer.LinearMixerState)">
            <summary>
            Creates a new <see cref="T:Animancer.LinearMixerState.Drawer"/> to manage the Inspector GUI for the `state`.
            </summary>
        </member>
        <member name="M:Animancer.LinearMixerState.Drawer.AddContextMenuFunctions(UnityEditor.GenericMenu)">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.ManualMixerState">
            <summary>[Pro-Only]
            An <see cref="T:Animancer.AnimancerState"/> which blends multiple child states by allowing you to control their
            <see cref="P:Animancer.AnimancerNode.Weight"/> manually.
            </summary>
            <remarks>
            This mixer type is similar to the Direct Blend Type in Mecanim Blend Trees.
            The official <see href="https://learn.unity.com/tutorial/5c5152bcedbc2a001fd5c696">Direct Blend Trees</see>
            tutorial explains their general concepts and purpose which apply to <see cref="T:Animancer.ManualMixerState"/>s as well.
            <para></para>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/blending/mixers">Mixers</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/ManualMixerState
            
            https://kybernetik.com.au/animancer/api/Animancer/ManualMixerState
        </member>
        <member name="T:Animancer.ManualMixerState.ITransition">
            <summary>An <see cref="T:Animancer.ITransition`1"/> that creates a <see cref="T:Animancer.ManualMixerState"/>.</summary>
        </member>
        <member name="T:Animancer.ManualMixerState.ITransition2D">
            <summary>
            An <see cref="T:Animancer.ITransition`1"/> that creates a <see cref="T:Animancer.MixerState`1"/> for
            <see cref="T:UnityEngine.Vector2"/>.
            </summary>
        </member>
        <member name="P:Animancer.ManualMixerState.KeepChildrenConnected">
            <summary>Returns true because mixers should always keep child playables connected to the graph.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Clip">
            <summary>A <see cref="T:Animancer.ManualMixerState"/> has no <see cref="T:UnityEngine.AnimationClip"/>.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.ChildStates">
            <summary>The states connected to this mixer.</summary>
            <remarks>Only states up to the <see cref="P:Animancer.ManualMixerState.ChildCount"/> should be assigned.</remarks>
        </member>
        <member name="P:Animancer.ManualMixerState.ChildCount">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.ManualMixerState.ChildCapacity">
            <summary>The size of the internal array of <see cref="P:Animancer.ManualMixerState.ChildStates"/>.</summary>
            <remarks>This value starts at 0 then expands to <see cref="P:Animancer.ManualMixerState.ChildCapacity"/> when the first child is added.</remarks>
        </member>
        <member name="M:Animancer.ManualMixerState.OnChildCapacityChanged">
            <summary>Called when the <see cref="P:Animancer.ManualMixerState.ChildCapacity"/> is changed.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.DefaultChildCapacity">
            <summary><see cref="P:Animancer.ManualMixerState.ChildCapacity"/> starts at 0 then expands to this value when the first child is added.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.EnsureRemainingChildCapacity(System.Int32)">
            <summary>
            Ensures that the remaining unused <see cref="P:Animancer.ManualMixerState.ChildCapacity"/> is greater than or equal to the
            `minimumCapacity`.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.GetChild(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ManualMixerState.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ManualMixerState.OnSetIsPlaying">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.ManualMixerState.IsLooping">
            <summary>Are any child states looping?</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.RawTime">
            <summary>
            The weighted average <see cref="P:Animancer.AnimancerState.Time"/> of each child state according to their
            <see cref="P:Animancer.AnimancerNode.Weight"/>.
            </summary>
            <remarks>
            If there are any <see cref="P:Animancer.ManualMixerState.SynchronizedChildren"/>, only those states will be included in the getter
            calculation.
            </remarks>
        </member>
        <member name="M:Animancer.ManualMixerState.MoveTime(System.Double,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ManualMixerState.GetSynchronizedTimeDetails(System.Single@,System.Single@,System.Single@)">
            <summary>Gets the time details based on the <see cref="P:Animancer.ManualMixerState.SynchronizedChildren"/>.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.GetTimeDetails(System.Single@,System.Single@,System.Single@)">
            <summary>Gets the time details based on all child states.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Length">
            <summary>
            The weighted average <see cref="P:Animancer.AnimancerState.Length"/> of each child state according to their
            <see cref="P:Animancer.AnimancerNode.Weight"/>.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.#ctor">
            <summary>Creates a new <see cref="T:Animancer.ManualMixerState"/>.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.CreatePlayable(UnityEngine.Playables.Playable@)">
            <summary>Creates and assigns the <see cref="T:UnityEngine.Animations.AnimationMixerPlayable"/> managed by this state.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.OnAddChild(Animancer.AnimancerState)">
            <summary>Connects the `state` to this mixer at its <see cref="P:Animancer.AnimancerNode.Index"/>.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.OnRemoveChild(Animancer.AnimancerState)">
            <summary>Disconnects the `state` from this mixer at its <see cref="P:Animancer.AnimancerNode.Index"/>.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Destroy">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ManualMixerState.Clone(Animancer.AnimancerPlayable)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ManualMixerState.Animancer#ICopyable{Animancer#ManualMixerState}#CopyFrom(Animancer.ManualMixerState)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ManualMixerState.Add(Animancer.AnimancerState)">
            <summary>Assigns the `state` as a child of this mixer.</summary>
            <remarks>The `state` must not be null. To remove a child, call <see cref="M:Animancer.ManualMixerState.Remove(System.Int32,System.Boolean)"/> instead.</remarks>
        </member>
        <member name="M:Animancer.ManualMixerState.Add(UnityEngine.AnimationClip)">
            <summary>Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the `clip` as a child of this mixer.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Add(Animancer.ITransition)">
            <summary>Calls <see cref="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)"/> then <see cref="M:Animancer.ManualMixerState.Add(Animancer.AnimancerState)"/>.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Add(System.Object)">
            <summary>Calls one of the other <see cref="M:Animancer.ManualMixerState.Add(System.Object)"/> overloads as appropriate for the `child`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.AddRange(System.Collections.Generic.IList{UnityEngine.AnimationClip})">
            <summary>Calls <see cref="M:Animancer.ManualMixerState.Add(UnityEngine.AnimationClip)"/> for each of the `clips`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.AddRange(UnityEngine.AnimationClip[])">
            <summary>Calls <see cref="M:Animancer.ManualMixerState.Add(UnityEngine.AnimationClip)"/> for each of the `clips`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.AddRange(System.Collections.Generic.IList{Animancer.ITransition})">
            <summary>Calls <see cref="M:Animancer.ManualMixerState.Add(Animancer.ITransition)"/> for each of the `transitions`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.AddRange(Animancer.ITransition[])">
            <summary>Calls <see cref="M:Animancer.ManualMixerState.Add(Animancer.ITransition)"/> for each of the `clips`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.AddRange(System.Collections.Generic.IList{System.Object})">
            <summary>Calls <see cref="M:Animancer.ManualMixerState.Add(System.Object)"/> for each of the `children`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.AddRange(System.Object[])">
            <summary>Calls <see cref="M:Animancer.ManualMixerState.Add(System.Object)"/> for each of the `clips`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Remove(System.Int32,System.Boolean)">
            <summary>Removes the child at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Remove(Animancer.AnimancerState,System.Boolean)">
            <summary>Removes the specified `child`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Set(System.Int32,Animancer.AnimancerState,System.Boolean)">
            <summary>Replaces the `child` at the specified `index`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Set(System.Int32,UnityEngine.AnimationClip,System.Boolean)">
            <summary>Replaces the child at the specified `index` with a new <see cref="T:Animancer.ClipState"/>.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Set(System.Int32,Animancer.ITransition,System.Boolean)">
            <summary>Replaces the child at the specified `index` with a <see cref="M:Animancer.ITransition.CreateState"/>.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Set(System.Int32,System.Object,System.Boolean)">
            <summary>Calls one of the other <see cref="M:Animancer.ManualMixerState.Set(System.Int32,System.Object,System.Boolean)"/> overloads as appropriate for the `child`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.IndexOf(Animancer.AnimancerState)">
            <summary>Returns the index of the specified `child` state.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.DestroyChildren">
            <summary>
            Destroys all <see cref="P:Animancer.ManualMixerState.ChildStates"/> connected to this mixer. This operation cannot be undone.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.CreatePlayable``1(Animancer.AnimancerPlayable,``0,System.Boolean)">
            <summary>
            Creates an <see cref="T:UnityEngine.Animations.AnimationScriptPlayable"/> to run the specified Animation Job instead of the usual
            <see cref="T:UnityEngine.Animations.AnimationMixerPlayable"/>.
            </summary>
            <example><code>
            AnimancerComponent animancer = ...;
            var job = new MyJob();// A struct that implements IAnimationJob.
            var mixer = new WhateverMixerState();// e.g. LinearMixerState.
            mixer.CreatePlayable(animancer, job);
            // Use mixer.Initialize, CreateChild, and SetChild to configure the children as normal.
            </code>
            See also: <seealso cref="M:Animancer.ManualMixerState.CreatePlayable``1(UnityEngine.Playables.Playable@,``0,System.Boolean)"/>
            </example>
        </member>
        <member name="M:Animancer.ManualMixerState.CreatePlayable``1(UnityEngine.Playables.Playable@,``0,System.Boolean)">
            <summary>
            Creates an <see cref="T:UnityEngine.Animations.AnimationScriptPlayable"/> to run the specified Animation Job instead of the usual
            <see cref="T:UnityEngine.Animations.AnimationMixerPlayable"/>.
            </summary>
            
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/source/creating-custom-states">Creating Custom States</see>
            </remarks>
            
            <example><code>
            public class MyMixer : LinearMixerState
            {
                protected override void CreatePlayable(out Playable playable)
                {
                    CreatePlayable(out playable, new MyJob());
                }
            
                private struct MyJob : IAnimationJob
                {
                    public void ProcessAnimation(AnimationStream stream)
                    {
                    }
            
                    public void ProcessRootMotion(AnimationStream stream)
                    {
                    }
                }
            }
            </code>
            See also: <seealso cref="M:Animancer.ManualMixerState.CreatePlayable``1(Animancer.AnimancerPlayable,``0,System.Boolean)"/>
            </example>
        </member>
        <member name="M:Animancer.ManualMixerState.GetJobData``1">
            <summary>
            Gets the Animation Job data from the <see cref="T:UnityEngine.Animations.AnimationScriptPlayable"/>.
            </summary>
            <exception cref="T:System.InvalidCastException">
            This mixer was not initialized using <see cref="M:Animancer.ManualMixerState.CreatePlayable``1(Animancer.AnimancerPlayable,``0,System.Boolean)"/>
            or <see cref="M:Animancer.ManualMixerState.CreatePlayable``1(UnityEngine.Playables.Playable@,``0,System.Boolean)"/>.
            </exception>
        </member>
        <member name="M:Animancer.ManualMixerState.SetJobData``1(``0)">
            <summary>
            Sets the Animation Job data in the <see cref="T:UnityEngine.Animations.AnimationScriptPlayable"/>.
            </summary>
            <exception cref="T:System.InvalidCastException">
            This mixer was not initialized using <see cref="M:Animancer.ManualMixerState.CreatePlayable``1(Animancer.AnimancerPlayable,``0,System.Boolean)"/>
            or <see cref="M:Animancer.ManualMixerState.CreatePlayable``1(UnityEngine.Playables.Playable@,``0,System.Boolean)"/>.
            </exception>
        </member>
        <member name="M:Animancer.ManualMixerState.Update(System.Boolean@)">
            <summary>Updates the time of this mixer and all of its child states.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.WeightsAreDirty">
            <summary>Should the weights of all child states be recalculated?</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.RecalculateWeights">
            <summary>
            If <see cref="P:Animancer.ManualMixerState.WeightsAreDirty"/> this method recalculates the weights of all child states and returns true.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.ForceRecalculateWeights">
            <summary>
            Recalculates the weights of all child states based on the current value of the
            <see cref="P:Animancer.MixerState`1.Parameter"/> and the thresholds.
            </summary>
            <remarks>Overrides of this method must set <see cref="P:Animancer.ManualMixerState.WeightsAreDirty"/> = false.</remarks>
        </member>
        <member name="P:Animancer.ManualMixerState.SynchronizeNewChildren">
            <summary>Should newly added children be automatically added to the synchronization list? Default true.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.MinimumSynchronizeChildrenWeight">
            <summary>The minimum total weight of all children for their times to be synchronized. Default 0.01.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.SynchronizedChildren">
            <summary>A copy of the internal list of child states that will have their times synchronized.</summary>
            <remarks>
            If this mixer is a child of another mixer, its synchronized children will be managed by the parent.
            <para></para>
            The getter allocates a new array if <see cref="P:Animancer.ManualMixerState.SynchronizedChildCount"/> is greater than zero.
            </remarks>
        </member>
        <member name="P:Animancer.ManualMixerState.SynchronizedChildCount">
            <summary>The number of <see cref="P:Animancer.ManualMixerState.SynchronizedChildren"/>.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.IsSynchronized(Animancer.AnimancerState)">
            <summary>Is the `state` in the <see cref="P:Animancer.ManualMixerState.SynchronizedChildren"/>?</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.Synchronize(Animancer.AnimancerState)">
            <summary>Adds the `state` to the <see cref="P:Animancer.ManualMixerState.SynchronizedChildren"/>.</summary>
            <remarks>
            The `state` must be a child of this mixer.
            <para></para>
            If this mixer is a child of another mixer, the `state` will be added to the parent's
            <see cref="P:Animancer.ManualMixerState.SynchronizedChildren"/> instead.
            </remarks>
        </member>
        <member name="M:Animancer.ManualMixerState.SynchronizeDirect(Animancer.AnimancerState)">
            <summary>The internal implementation of <see cref="M:Animancer.ManualMixerState.Synchronize(Animancer.AnimancerState)"/>.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.DontSynchronize(Animancer.AnimancerState)">
            <summary>Removes the `state` from the <see cref="P:Animancer.ManualMixerState.SynchronizedChildren"/>.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.DontSynchronizeChildren">
            <summary>Removes all children of this mixer from the <see cref="P:Animancer.ManualMixerState.SynchronizedChildren"/>.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.InitializeSynchronizedChildren(System.Boolean[])">
            <summary>Initializes the internal <see cref="P:Animancer.ManualMixerState.SynchronizedChildren"/> list.</summary>
            <remarks>
            The array can be null or empty. Any elements not in the array will be treated as <c>true</c>.
            <para></para>
            This method can only be called before any <see cref="P:Animancer.ManualMixerState.SynchronizedChildren"/> are added and also before this
            mixer is made the child of another mixer.
            </remarks>
        </member>
        <member name="M:Animancer.ManualMixerState.GetParentMixer">
            <summary>
            Returns the highest <see cref="T:Animancer.ManualMixerState"/> in the hierarchy above this mixer or this mixer itself if
            there are none above it.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.GetParentMixer(Animancer.IPlayableWrapper)">
            <summary>Returns the highest <see cref="T:Animancer.ManualMixerState"/> in the hierarchy above the `state` (inclusive).</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.IsChildOf(Animancer.IPlayableWrapper,Animancer.IPlayableWrapper)">
            <summary>Is the `child` a child of the `parent`?</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.ApplySynchronizeChildren(System.Boolean@)">
            <summary>
            Synchronizes the <see cref="P:Animancer.AnimancerState.NormalizedTime"/>s of the <see cref="P:Animancer.ManualMixerState.SynchronizedChildren"/> by
            modifying their internal playable speeds.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.CalculateRealEffectiveSpeed">
            <summary>
            The multiplied <see cref="M:UnityEngine.Playables.PlayableExtensions.GetSpeed``1(``0)"/> of this mixer and its parents down the
            hierarchy to determine the actual speed its output is being played at.
            </summary>
            <remarks>
            This can be different from the <see cref="P:Animancer.AnimancerNode.EffectiveSpeed"/> because the
            <see cref="P:Animancer.ManualMixerState.SynchronizedChildren"/> have their playable speed modified without setting their
            <see cref="P:Animancer.AnimancerNode.Speed"/>.
            </remarks>
        </member>
        <member name="P:Animancer.ManualMixerState.ApplyAnimatorIK">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.ManualMixerState.ApplyFootIK">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ManualMixerState.CalculateTotalWeight(Animancer.AnimancerState[],System.Int32)">
            <summary>Calculates the sum of the <see cref="P:Animancer.AnimancerNode.Weight"/> of all `states`.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.SetChildrenTime(System.Single,System.Boolean)">
            <summary>
            Sets <see cref="P:Animancer.AnimancerState.Time"/> for all <see cref="P:Animancer.ManualMixerState.ChildStates"/>.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.DisableRemainingStates(System.Int32)">
            <summary>Sets the weight of all states after the `previousIndex` to 0.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.NormalizeWeights(System.Single)">
            <summary>Divides the weight of all child states by the `totalWeight`.</summary>
            <remarks>
            If the `totalWeight` is equal to the total <see cref="P:Animancer.AnimancerNode.Weight"/> of all child states, then the
            new total will become 1.
            </remarks>
        </member>
        <member name="M:Animancer.ManualMixerState.GetDisplayKey(Animancer.AnimancerState)">
            <summary>Gets a user-friendly key to identify the `state` in the Inspector.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.AverageVelocity">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ManualMixerState.NormalizeDurations">
            <summary>
            Recalculates the <see cref="P:Animancer.AnimancerState.Duration"/> of all child states so that they add up to 1.
            </summary>
            <exception cref="T:System.NullReferenceException">There are any states with no <see cref="P:Animancer.ManualMixerState.Clip"/>.</exception>
        </member>
        <member name="F:Animancer.ManualMixerState._IsGeneratedName">
            <summary>Has the <see cref="P:Animancer.AnimancerNode.DebugName"/> been generated from the child states?</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.ToString">
            <summary>
            Returns a string describing the type of this mixer and the name of <see cref="P:Animancer.ManualMixerState.Clip"/>s connected to it.
            </summary>
        </member>
        <member name="M:Animancer.ManualMixerState.AppendDetails(System.Text.StringBuilder,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ManualMixerState.GatherAnimationClips(System.Collections.Generic.ICollection{UnityEngine.AnimationClip})">
            <inheritdoc/>
        </member>
        <member name="P:Animancer.ManualMixerState.ParameterCount">
            <summary>The number of parameters being managed by this state.</summary>
        </member>
        <member name="M:Animancer.ManualMixerState.GetParameterName(System.Int32)">
            <summary>Returns the name of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.ManualMixerState.GetParameterType(System.Int32)">
            <summary>Returns the type of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.ManualMixerState.GetParameterValue(System.Int32)">
            <summary>Returns the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.ManualMixerState.SetParameterValue(System.Int32,System.Object)">
            <summary>Sets the value of a parameter being managed by this state.</summary>
            <exception cref="T:System.NotSupportedException">This state doesn't manage any parameters.</exception>
        </member>
        <member name="M:Animancer.ManualMixerState.CreateDrawer">
            <summary>[Editor-Only] Returns a <see cref="T:Animancer.ManualMixerState.Drawer`1"/> for this state.</summary>
        </member>
        <member name="T:Animancer.ManualMixerState.Drawer`1">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ManualMixerState.Drawer`1.#ctor(`0)">
            <summary>Creates a new <see cref="T:Animancer.ManualMixerState.Drawer`1"/> to manage the Inspector GUI for the `state`.</summary>
        </member>
        <member name="P:Animancer.ManualMixerState.Drawer`1.ParameterCount">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ManualMixerState.Drawer`1.GetParameterName(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ManualMixerState.Drawer`1.GetParameterType(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ManualMixerState.Drawer`1.GetParameterValue(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.ManualMixerState.Drawer`1.SetParameterValue(System.Int32,System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Animancer.MixerState`1">
            <summary>[Pro-Only]
            Base class for mixers which blend an array of child states together based on a <see cref="P:Animancer.MixerState`1.Parameter"/>.
            </summary>
            <remarks>
            Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/blending/mixers">Mixers</see>
            </remarks>
            https://kybernetik.com.au/animancer/api/Animancer/MixerState_1
            
        </member>
        <member name="F:Animancer.MixerState`1._Thresholds">
            <summary>The parameter values at which each of the child states are used and blended.</summary>
        </member>
        <member name="P:Animancer.MixerState`1.Parameter">
            <summary>The value used to calculate the weights of the child states.</summary>
            <remarks>
            Setting this value takes effect immediately (during the next animation update) without any
            <see href="https://kybernetik.com.au/animancer/docs/manual/blending/mixers#smoothing">Smoothing</see>.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">The value is NaN or Infinity.</exception>
        </member>
        <member name="M:Animancer.MixerState`1.GetParameterError(`0)">
            <summary>
            Returns an error message if the given `parameter` value can't be assigned to the <see cref="P:Animancer.MixerState`1.Parameter"/>.
            Otherwise returns null.
            </summary>
        </member>
        <member name="P:Animancer.MixerState`1.HasThresholds">
            <summary>
            Has the array of thresholds been initialized with a size at least equal to the
            <see cref="P:Animancer.ManualMixerState.ChildCount"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.GetThreshold(System.Int32)">
            <summary>Returns the value of the threshold associated with the specified `index`.</summary>
        </member>
        <member name="M:Animancer.MixerState`1.SetThreshold(System.Int32,`0)">
            <summary>Sets the value of the threshold associated with the specified `index`.</summary>
        </member>
        <member name="M:Animancer.MixerState`1.SetThresholds(`0[])">
            <summary>
            Assigns the specified array as the thresholds to use for blending.
            <para></para>
            WARNING: if you keep a reference to the `thresholds` array you must call <see cref="M:Animancer.MixerState`1.OnThresholdsChanged"/>
            whenever any changes are made to it, otherwise this mixer may not blend correctly.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.ValidateThresholdCount">
            <summary>
            If the <see cref="P:System.Array.Length"/> of the <see cref="F:Animancer.MixerState`1._Thresholds"/> is below the
            <see cref="P:Animancer.AnimancerNode.ChildCount"/>, this method assigns a new array with size equal to the
            <see cref="P:Animancer.ManualMixerState.ChildCapacity"/> and returns true.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.OnThresholdsChanged">
            <summary>
            Called whenever the thresholds are changed. By default this method simply indicates that the blend weights
            need recalculating but it can be overridden by child classes to perform validation checks or optimisations.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.CalculateThresholds(System.Func{Animancer.AnimancerState,`0})">
            <summary>
            Calls `calculate` for each of the <see cref="P:Animancer.ManualMixerState.ChildStates"/> and stores the returned value
            as the threshold for that state.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.RecreatePlayable">
            <summary>
            Stores the values of all parameters, calls <see cref="M:Animancer.AnimancerNode.DestroyPlayable"/>, then restores the
            parameter values.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.OnChildCapacityChanged">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.MixerState`1.Add(Animancer.AnimancerState,`0)">
            <summary>Assigns the `state` as a child of this mixer and assigns the `threshold` for it.</summary>
        </member>
        <member name="M:Animancer.MixerState`1.Add(UnityEngine.AnimationClip,`0)">
            <summary>
            Creates and returns a new <see cref="T:Animancer.ClipState"/> to play the `clip` as a child of this mixer, and assigns
            the `threshold` for it.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.Add(Animancer.ITransition,`0)">
            <summary>
            Calls <see cref="M:Animancer.AnimancerUtilities.CreateStateAndApply(Animancer.ITransition,Animancer.AnimancerPlayable)"/> then 
            <see cref="M:Animancer.MixerState`1.Add(Animancer.AnimancerState,`0)"/>.
            </summary>
        </member>
        <member name="M:Animancer.MixerState`1.Add(System.Object,`0)">
            <summary>Calls one of the other <see cref="M:Animancer.MixerState`1.Add(System.Object,`0)"/> overloads as appropriate.</summary>
        </member>
        <member name="M:Animancer.MixerState`1.Animancer#ICopyable{Animancer#MixerState{TParameter}}#CopyFrom(Animancer.MixerState{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.MixerState`1.GetDisplayKey(Animancer.AnimancerState)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.MixerState`1.AppendDetails(System.Text.StringBuilder,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Animancer.MixerState`1.AppendParameter(System.Text.StringBuilder,`0)">
            <summary>Appends the `parameter` in a viewer-friendly format.</summary>
        </member>
    </members>
</doc>
